Thinking
in
Java
第二版
Bruce Eckel
President, MindView, Inc.
侯捷/ 王建興
合譯
讀者回應:
此書遠勝我見過的所有Java 書。非常完整地奉行重要性順序…，搭配恰到
好處的範例，以及睿智而不呆板的解說…。和其他許多Java 書籍對照起
來，我認為它超乎尋常地成熟，前後文相互呼應，技術上誠實，文筆流
暢、用語精確。以我個人觀點，我認為它是Java 書籍中的完美典型。
Anatoly Vorobey, Technion University, Haifa, Israel
本書是我所見過的(含括任何語言的)程式設計入門書籍中，最好的一
本。Joakim Ziegler, FIX sysop
謹對這樣一本精采至極的Java 書籍，獻上我最真誠的感謝。Dr. Gavin
Pillay, Registrar, King Edward VIII Hospital, South Africa
再次感謝您這本令人讚嘆不已的書籍。我曾經一度陷入困境(因為我並不
是一個熟悉C 語言的程式員)，但是這本書給了我很大幫助，讓我能夠盡
可能調快自己的閱讀速度。對我而言，一開始就能夠理解底層的原理和觀
念，真是太酷了。我再也不必經由錯誤嘗試來建立心中的觀念模型。我真
的滿心期盼能夠在不久的將來，參加您的研討課程。Randall R. Hawley,
Automation Technician, Eli Lilly & Co.
我所見過的電腦書籍中，最棒的一本。Tom Holland
我所讀過的眾多程式設計絕佳好書中的一本…。以Java 為主題的書籍中，
最好的一本。Ravindra Pai, Oracle Corporation, SUNOS product line
Java 書籍中，我生平所見最佳的一本。您成就的作品真是太偉大了。您的
深度令人讚嘆。此書一旦付梓，一定會出現在我的購買清單中。96 年10
月起我就開始學習Java，這段期間我讀過幾本書，您的這本肯定是「必
讀」的一本。過去幾個月來，我們集中心力於一個完全以Java 開發的產
品，您這本書厚實了我過去以來未能紮穩根基的種種主題，擴展了我的知
識基礎。和合作包商面試時，我甚至引用了您的內容，做為參考的依據。
向他們詢問我自這本書中讀來的資料，便可以掂出他們對Java 的了解程度
(例如，array 和Vector 之間有何差異)。這本書真是無與倫比！Steve
Wilkinson, Senior Staff Specialist, MCI Telecommunications
好書好書！生平所見的Java 最佳書籍。Jeff Sinclair, Software Engineer,
Kestral Computing
向您的《Thinking in Java》致上謝意。因為有您的付出，將單純的語言描
述轉化為富有思想、具洞察力、分析透徹的入門指引，而不必向「那個公
司」卑躬屈膝。我幾乎讀過所有其他書籍- 但只有您和Patrick Winston
的作品，能在我的心中佔有一席之地。我總是將它推薦給其他客戶。再次
謝謝您。Richard Brooks, Java Consultant, Sun Professional Services,
Dallas
其他書籍只涵蓋了Java 的WHAT(只探討了語法和相關類別庫)，或者
只包含了Java 的HOW(實際的程式範例)。《Thinking in Java》則是
我所知道的書籍中，對Java 的WHY 做出詳盡解說的唯一一本。為什麼要
這麼設計、為什麼它會那麼運作、為什麼有時候會發生問題、為什麼它在
某些地方比C++好而某些地方不會。雖然教授程式語言的WHAT 和HOW
也很重要，但是《Thinking in Java》肯定是愛好思想的人們在Java 書籍
中的唯一選擇。Robert S. Stephenson
這麼一本了不起的書，真是叫人感激不盡。愈讀愈叫人愛不釋手。我的學
生們也很喜歡呢。Chuck Iverson
我只是想讚揚您在《Thinking in Java》上的表現。人們喜歡您看重
Internet 的未來遠景，而我只是想感謝您的付出與努力。真是感激不盡
啊。Patrick Barrell, Network Officer Mamco, QAF Mfg. Inc.
大多數市面上的Java 書籍，對於初學用途還算恰當。但大多數也都僅僅到
達那樣的層次，而且有著許多相同的範例。您的書籍顯然是我所見過最佳
的進階思考書籍。快點出版吧！由於《Thinking in Java》的緣故，我也買
了《Thinking in C++》。George Laframboise, LightWorx Technology
Consulting, Inc.
關於您的《Thinking in C++》(當我工作的時候，它總是在書架上佔有最
顯著的位置)，先前我便曾提筆告訴過您我對它的喜愛。現在，我仔細鑽
研了您的電子書，我還必須說：「我愛死它了！」頗具知性與思辨，閱讀
起來不像是無味的教科書。您的書中涵蓋了Java 開發工作中最重要、最核
心的觀念：事物的本質。Sean Brady
您的例子不僅清楚，而且易於理解。您細膩地照顧到Java 之中十分重要的
細節，而這些細節在其他較差的Java 文件中是無法找到的。由於您已經假
設了必備的基本程式設計概念，讀者的時間也不至於被虛耗。Kai Engert,
Innovative Software, Germany
我是《Thinking in C++》的忠實書迷，我也將這本書推薦給我的朋友們。
當我讀完您的Java 書籍電子版時，我真的覺得，您總是維持著高水準的寫
作品質。謝謝您！Peter R. Neuwald
寫得超棒的Java 書籍…我認為您寫作此書的成就實在不凡。身為芝加哥區
域的Java 特殊愛好者團體領導，我已經在我們最近的聚會中讚揚您的這本
書和您的網站許多次了。我想將《Thinking in Java》做為SIG(譯註：
Special Interest Group，特殊愛好者團體)每月聚會的基礎。在聚會中，
我們將依章節順序，進行溫習與討論。Mark Ertes
對於您的努力成果，我由衷感激。您的書是佳作，我將這本書推薦給我們
這兒的使用者與博士班學生。Hugues Leroy // Irisa-Inria Rennes
France, Head of Scientific Computing and Industrial Tranfert
截至目前，雖然我只讀了約40 頁的《Thinking in Java》，卻已經發現，
這本書絕對是我所見過內容呈現方式最為清晰的一本程式設計書籍…我自
己也是一個作者，所以我理應表現出些許的挑剔。我已訂購《Thinking in
C++》，等不及要好好剖析一番- 對於程式設計這門學問，我還算是新
手，因此事事都得學習。這不過是一篇向您的絕佳作品致謝的簡短書信。
在痛苦地遍覽大多數令人食而生厭、平淡無味的電腦書籍後，雖然有些書
籍有著極佳的口碑，我對於電腦書的閱讀熱情卻一度消褪。不過，現在我
又再度重拾信心。Glenn Becker, Educational Theatre Association
謝謝您讓這麼一本精采的書籍降臨人世。當我困惑於Java 和C++ 的同
時，這本書對於最終的認識提供了極大助益。閱讀您的書令人如沐春風。
Felix Bizaoui, Twin Oaks Industries, Louisa, Va.
能夠寫出這麼優秀的作品，除了向您道賀，實在說不出什麼了。基於閱讀
《Thinking in C++》的經驗，我決定讀讀《Thinking in Java》，而事實
證明它並未讓人失望。Jaco van der Merwe, Software Specialist,
DataFusion Systems Ltd, Stellenbosch, South Africa
本書無疑是我所見過最佳的Java 書籍之一。E.F. Pritchard, Senior
Software Engineer, Cambridge Animation Systems Ltd., United
Kingdom
您的書籍使我曾讀過、或曾草草翻閱過的其他Java 書籍，似乎都變得加倍
的無用、該罵。Brett g Porter, Senior Programmer, Art & Logic
我已經持續閱讀您這本書一兩個星期了。相較於之前我所讀過的Java 書
籍，您的書籍似乎更能夠給我一個絕佳的開始。請接受我的恭喜，能寫出
這樣一本出色的作品，真不容易。Rama Krishna Bhupathi, Software
Engineer, TCSI Corporation, San Jose
只是很想告訴您，這本書是一部多麼傑出的作品。我已將這本書做為公司
內部Java 工作上的主要參考資料。我發現目錄的安排十分適當，讓我可以
很快找出我想要的章節。能夠看到一本書籍，不是只重新改寫API，或只
是把程式員當做呆瓜，真是太棒了。Grant Sayer, Java Components
Group Leader, Ceedata Systems Pty Ltd, Australia
噢！這是一本可讀性高、極富深度的Java 書籍。坊間已經有太多品質低落
的Java 書籍。其中雖然也有少數不錯的，但在我看過您的大作之後，我認
為它勢必是最好的。John Root, Web Developer, Department of Social
Security, London
我才剛開始閱讀《Thinking in Java》這本書。我想它肯定好到了極點，因
為我愛死了《Thinking in C++》(我以一個熟悉C++、卻渴望積極提升自
己能力的程式員的身份，來閱讀這本書)。我對Java 較為陌生，但是預料
必能感到滿意。您是一位才華洋溢的作家。Kevin K. Lewis, Technologist,
ObjectSpace, Inc.
我想這是一本了不起的書。我從這本書學到了所有關於Java 的知識。多謝
您讓大家可以從Internet 上免費取得。如果沒有您的付出，我至今仍然對
Java 一無所知。本書最棒的一點，莫過於它同時也說明了Java 不好的一
面，而不像是一本商業宣傳。您的表現真是優秀。Frederik Fix, Belgium
我無時無刻不沉浸在您的書籍之中。幾年以前，當我開始學習C++ 時，是
《C++ Inside & Out》帶領我進入C++ 的迷人世界裡。那本書幫助我的生
命得到更好的種種機會。現在，在追尋更進一步知識的同時，當我興起了
學習Java 的念頭，我無意中又碰見了《Thinking in Java》- 毫無疑問，
我的心中再不認為還需要其他書籍。就是這麼的令人難以置信。持續閱讀
此書的過程，就像重新發掘自我一樣。我學習Java 至今已經一個月，現在
對Java 的體會日益加深，這一切都不得不由衷感謝您。Anand Kumar S.,
Software Engineer, Computervision, India
您的作品做為一般性的導論， 是如此卓越出眾。Peter Robinson,
University of Cambridge Computer Laboratory
本書內容顯然是我所見過Java 教學書籍中最頂尖的。我只是想讓您知道，
我覺得能夠碰上這本書，自己有多麼幸運。謝謝！Chuck Peterson,
Product Leader, Internet Product Line, IVIS International
了不起的一本書。自從我開始學習Java，這已經是第三本書了。至今，我
大概閱讀了三分之二，我打算好好把這本書讀完。我能夠找到這本書，是
因為這本書被用於Lucent Technologies 的某些內部課程，而且有個朋友告
訴我這本書可以在網絡上找到。很棒的作品。Jerry Nowlin, MTS, Lucent
Technologies
在我所讀過的六本Java 書籍中，您的《Thinking in Java》顯然是最好也
最明白易懂的。Michael Van Waas, Ph.D., President, TMR Associates
關於《Thinking in Java》，我有說不盡的感謝。您的作品真是精采超乎尋
常啊！更不必說這本書可以從網絡免費下載了！以學生的身份來看，我想
您的書籍的確是無價珍寶(我也有一本《C++ Inside & Out》，這是一本
偉大的C++ 書籍)，因為您的書不僅教導我應該怎麼做，也教導我背後之
所以如此的原因所在，而這對於C++ 或Java 學習者建立起堅固基礎是相
當重要的。我有許多和我一樣喜愛程式設計的朋友，我也對他們提起您的
書。他們覺得真是太棒了！再次謝謝您！順道一提，我是印尼人，就住在
爪哇。Ray Frederick Djajadinata, Student at Trisakti University,
Jakarta
單是將作品免費置放於網絡的這種氣度，就使我震驚不已。我想，我應該
讓您知道，對於您的作為，我是多麼感激與尊敬。Shane LeBouthillier,
Computer Engineering student, University of Alberta, Canada
每個月都在期待您的專欄。我必須告訴您，我有多麼盼望。做為物件導向
程式設計領域的新手，我感謝您花在種種最基礎主題上的時間和思考。我
已經下載了您的這本書，但我會在這本書出版的同時，馬上搶購。對於您
的種種幫助，我感謝於心。Dan Cashmer, B. C. Ziegler & Co.
能夠完成這麼了不起的作品，可喜可賀。首先，我沒能搞定《Thinking in
Java》的PDF 版本。甚至在我全部讀完之前，我還跑到書店，找出了
《Thinking in C++》。我已從事電腦相關工作超過八年，做過顧問、軟體
工程師、教師/教練，最近則當起了自由業。所以我想我的見識理應足夠
(並非「看盡千帆」，而是「足夠」)。不過，這些書使得我的女朋友稱
我為「怪人」。我並不反對，只不過我認為我已經遠超過這個階段。我發
現我是如此地沉浸在這兩本書中，和其他我曾接觸過、買過的電腦書籍相
比，大大的不同。這兩本書都有極佳的寫作風格，對於每個新主題都有很
好的簡介與說明，而且書中充滿睿智的見解。幹得好。Simon Goland,
simonsez@smartt.com, Simon Says Consulting, Inc.
對於您的《Thinking in Java》，我得說，真是太了不起了。它就是我苦尋
許久而不可得的那種書。尤其那些針砭Java 軟體設計良窳的章節，完全就
是我想要的。Dirk Duehr, Lexikon Verlag, Bertelsmann AG, Germany
謝謝您的兩本了不起的作品：《Thinking in C++》和《Thinking in
Java》。我在物件導向程式設計上的大幅進步，得自於您的助益最多。
Donald Lawson, DCL Enterprises
多謝您願意花費時間來撰寫這麼一本大有用處的Java 書籍。如果教學能夠
讓您明白某些事情的話，那麼，此刻，您肯定對自己極為滿意。Dominic
Turner, GEAC Support
我曾讀過的最棒的Java 書籍- 我真的讀過不少。Jean-Yves MENGANT,
Chief Software Architect NAT-SYSTEM, Paris, France
《Thinking in Java》涵蓋的內容與所做的解說絕對是最好的。極易閱讀，
連程式碼都如此。Ron Chan, Ph.D., Expert Choice, Inc., Pittsburgh PA
您的書極好。我讀過許多談論程式設計的書籍，但是您的這本書依然能夠
將您對程式設計的深刻見解， 帶到我的心中。Ningjian Wang,
Information System Engineer, The Vanguard Group
《Thinking in Java》是本既優秀又具可讀性的書籍。我把它推薦給我所有
的學生。Dr. Paul Gorman, Department of Computer Science,
University of Otago, Dunedin, New Zealand
您打破「天下沒有白吃的午餐」這句不變的真理。而且不是那種施捨性質
的午餐，是連美食家都覺得美味的午餐。Jose Suriol, Scylax Corporation
感謝有這個機會，看到這本書成為一份傑作！在這個主題上，本書絕對是
我所讀過的最佳書籍。Jeff Lapchinsky, Programmer, Net Results
Technologies
您的這本書簡明扼要，易懂，而且讀起來心中充滿喜悅。Keith Ritchie,
Java Research & Development Team, KL Group Inc.
的的確確是我所讀過最好的Java 書籍！Daniel Eng
生平所見最好的Java 書籍！Rich Hoffarth, Senior Architect, West
Group
對於如此精采的一本好書，我應該向您道謝。遍覽各章內容，帶給我極大
的樂趣。Fred Trimble, Actium Corporation
您肯定掌握了悠雅的藝術精髓，同時成功地讓我們對所有細節都心領神
會。您也讓學習過程變得非常簡單，同時令人滿足。對於這麼一份無與倫
比的入門書籍，我得向您致謝。Rajesh Rau, Software Consultant
《Thinking in Java 》撼動了整個免費的世界！ Miko O’Sullivan,
President, Idocs Inc.
關於Thinking in C++:
最好的書！
1995 年軟體開發雜誌(Software Development Magazine)Jolt Award 得主。
本書成就非凡。您應該在架上也擺一本。其中的iostreams 章節，是我所
見表現最廣泛也最容易理解的。
Al Stevens
Contributing Editor, Doctor Dobbs Journal
Eckel 的這本書絕對是唯一如此清晰解說「如何重新思考物件導向程式發
展」的一本書籍。也是透徹了解C++ 的絕佳入門書。
Andrew Binstock
Editor, Unix Review
Bruce 不斷讓我對他的C++ 洞察眼光感到驚奇。《Thinking in C++》則是
他所有絕妙想法的整理沉澱。關於C++ 的種種困擾，如果你需要清楚的解
答，買下這本出眾的書就對了。
Gary Entsminger
Author, The Tao of Objects
《Thinking in C++》有耐心地、極具條理地探討了種種特性的使用時機與
使用方式，包括：inline 函式、reference、運算子多載化、繼承、動態物
件。也包括了許多進階主題，像是template、exception、多重繼承的適當
使用。整個心血結晶完全由Eckel 對物件哲學與程式設計的獨到見解交織
而成。是每個C++ 開發者書架上必備的好書。如果您以C++ 從事正式的
開發工作，那麼《Thinking in C++》是您的必備書籍之一。
Richard Hale Shaw
Contributing Editor, PC Magazine

Thinking
in
Java
第二版
Bruce Eckel
President, MindView, Inc.
侯捷/ 王建興
合譯
Prentice Hall
Upper Saddle River, New Jersey 07458
www.phptr.com
Library of Congress Cataloging-in-Publication Data
Eckel, Bruce.
Thinking in Java / Bruce Eckel.--2nd ed.
p. cm.
ISBN 0-13-027363-5
1. Java (Computer program language) I. Title.
QA76.73.J38E25 2000
005.13'3--dc21 00-037522
CIP
Editorial/Production Supervision: Nicholas Radhuber
Acquisitions Editor: Paul Petralia
Manufacturing Manager: Maura Goldstaub
Marketing Manager: Bryan Gambrel
Cover Design: Daniel Will-Harris
Interior Design: Daniel Will-Harris, www.will-harris.com
c 2000 by Bruce Eckel, President, MindView, Inc.
Published by Prentice Hall PTR
Prentice-Hall, Inc.
Upper Saddle River, NJ 07458
The information in this book is distributed on an “as is” basis, without warranty. While
every precaution has been taken in the preparation of this book, neither the author nor the publisher shall
have any liability to any person or entitle with respect to any liability, loss or damage caused or alleged to
be caused directly or indirectly by instructions contained in this book or by the computer software or
hardware products described herein.
All rights reserved. No part of this book may be reproduced, in any form or by any means, without
permission in writing from the publisher.
Prentice-Hall books are widely used by corporations and government agencies for training, marketing, and
resale. The publisher offers discounts on this book when ordered in bulk quantities. For more information,
contact the Corporate Sales Department at 800-382-3419, fax: 201-236-7141, email:
corpsales@prenhall.com or write: Corporate Sales Department, Prentice Hall PTR, One Lake Street,
Upper Saddle River, New Jersey 07458.
Java is a registered trademark of Sun Microsystems, Inc. Windows 95 and Windows NT are trademarks of
Microsoft Corporation. All other product names and company names mentioned herein are the property of
their respective owners.
Printed in the United States of America
10 9 8 7 6 5 4 3 2 1
ISBN 0-13-027363-5
Prentice-Hall International (UK) Limited, London
Prentice-Hall of Australia Pty. Limited, Sydney
Prentice-Hall Canada, Inc., Toronto
Prentice-Hall Hispanoamericana, S.A., Mexico
Prentice-Hall of India Private Limited, New Delhi
Prentice-Hall of Japan, Inc., Tokyo
Pearson Education Asia Ltd., Singapore
Editora Prentice-Hall do Brasil, Ltda., Rio de Janeiro
Check www.BruceEckel.com
for in-depth details
and the date and location
of the next
Hands-On Java Seminar
• Based on this book
• Taught by Bruce Eckel
• Personal attention from Bruce Eckel
and his seminar assistants
• Includes in-class programming exercises
• Intermediate/Advanced seminars also offered
• Hundreds have already enjoyed this seminar-
Bruce Eckel’s Hands-On Java Seminar
Multimedia CD
It’s like coming to the seminar!
Available at www.BruceEckel.com
  The Hands-On Java Seminar captured on a Multimedia CD!
  Overhead slides and synchronized audio voice narration for all
the lectures. Just play it to see and hear the lectures!
  Created and narrated by Bruce Eckel.
  Based on the material in this book.
  Demo lecture available at www.BruceEckel.com
題獻
獻給那些正在努力創造
更偉大的下一代電腦語言的人們

綜覽
Thinking in Java (2e)
綜覽(Overview)
譯序xxix
Java 環境設定xxxiii
序言(Preface) 1
簡介(Introduction) 9
01: 物件導論(Introduction to Objects) 29
02: 萬事萬物皆物件(Everything is an Object) 101
03: 控制程式流程(Controlling Program Flow) 133
04: 初始化與清理(Initialization & Cleanup) 191
05: 隱藏實作細目(Hiding the Implementation) 243
06: 重複運用Classes(Reusing Classes) 271
07: 多型(Polymorphism) 311
08: 介面與內隱類別(Interfaces & Inner Classes) 349
09: 持有你的物件(Holding Your Objects) 407
10: 透過「異常」處理錯誤(Error Handling with Exceptions) 531
11: Java I/O 系統(The Java I/O System) 573
12: 執行期型別辨識(Run-time Type Identification) 659
13: 產生視窗和網頁小程式(Creating Windows & Applets) 689
14: 多緒(Multiple Threads) 825
15: 分佈式計算(Distributed Computing) 903
A: 物件的傳遞和回傳(Passing & Returning Objects) 1013
B: Java 原生介面(The Java Native Interface，JNI) 1065
C: Java 編程準則(Java Programming Guidelines) 1077
D: 資源(Resources) 1091
索引(Index ) 1099
綜覽
Thinking in Java (2e)
目錄
Thinking in Java (2e)
目錄(What's Inside)
譯序xxix
Java 環境設定xxxiii
序言1
第二版序4
Java2 6
書附光碟(CD-ROM) 7
簡介9
閱讀門檻9
學習Java 10
目標11
線上說明文件12
章節組織13
習題19
多媒體光碟19
原始碼20
撰碼標準22
Java 版本22
研討課程與顧問指導23
關於錯誤23
封面故事24
致謝25
Internet 上的貢獻者28
1: 物件導論29
抽象化的過程30
每個物件都有介面32
被隱藏的實作細節35
重複運用實作碼37
繼承：重複運用介面38
「是一個」vs. 「像是一個」42
隨多型而生的可互換物件44
抽象基礎類別與介面48
物件的形貌與壽命49
群集器和迭代器
Collections and iterators 51
單根繼承體系
The singly rooted hierarchy 53
群集類別庫Collection libraries
及其易用性支援54
管家(housekeeping)面臨的兩難：
誰該負責清理(clean-up)？ 55
異常處理：面對錯誤的發生57
多執行緒(Multithreading) 58
永續性(Persistence) 60
Java 與Internet 60
Web 是什麼？ 60
用戶端程式開發
Client-side programming 63
伺服端程式開發
Server-side programming 70
另一個截然不同的戰場：
應用系統(applications) 71
分析與設計71
階段0：策劃74
階段1：建立什麼？ 75
階段2：如何建立？ 79
階段3：打造核心83
階段4：use cases 的迭代84
目錄
Thinking in Java (2e)
階段5：演化85
取得成功87
Extreme programming
(極限編程) 88
測試優先88
搭檔設計(Pair Programming) 90
Java 為什麼成功91
易於表達、易於理解的系統91
透過程式庫發揮最大槓桿效應92
錯誤處理92
大型程式設計92
過渡策略93
實踐準則93
管理上的障礙95
Java vs. C++? 97
摘要98
2: 萬事萬物皆物件101
Reference 是操控物件之錀101
所有物件都必須由你建立103
儲存在哪裡103
特例：基本型別(primitive types) 105
Java 中的陣列107
你再也不需要摧毀物件107
生存空間(Scoping) 108
物件的生存空間109
建立新的資料型別：class 110
資料成員(Fields)和
函式(methods) 110
函式(methods),引數(arguments),
回傳值(return values) 112
引數列(argument list) 114
打造一個Java 程式115
名稱的可視性115
使用其他組件116
關鍵字static 117
初試啼聲你的第一個Java 程式119
編譯與執行121
註解及內嵌式文件122
寓文件於註解123
語法124
內嵌的HTML 125
@see: 參考其他的classes 125
Class(類別)文件所用標籤126
Variable(變數)文件所用標籤127
Method(函式)文件所用標籤127
文件製作實例128
撰碼風格129
摘要130
練習130
3: 控制程式流程133
使用Java 運算子133
優先序(Precedence) 134
賦值、指派(Assignment) 134
數學運算子
Mathematical operators 137
遞增(increment)和
遞減(decrement) 139
關係運算子(Relational operators) 141
邏輯運算子(Logical operators) 143
位元運算子(Bitwise operators) 146
位移運算子(Shift operators) 147
if-else 三元運算子151
逗號運算子(comma operator) 152
應用於String 身上的operator + 153
使用運算子時的常犯錯誤153
目錄
Thinking in Java (2e)
轉型運算子(Casting operators) 154
Java 沒有"sizeof" 運算子158
再探優先序(Precedence) 158
運算子綜合說明159
流程控制170
true 和false 170
if-else 171
迭代(Iteration) 172
do-while 173
for 173
break 和continue 175
switch 183
摘要187
練習188
4: 初始化與清理191
以建構式(constructor)確保
初始化的進行191
函式多載化(method overloading) 194
區分多載化函式196
搭配基本型別進行多載化197
以回傳值作為多載化的基準202
Default 建構式202
關鍵字this 203
清理(Cleanup)：
終結(finalization)與垃圾回收207
finalize( ) 存在是為了什麼？ 208
你必須執行清理(cleanup)動作209
死亡條件(death condition) 214
垃圾回收器的運作方式215
成員初始化
(Member initialization) 219
指定初值221
以建構式進行初始化動作223
Array 的初始化231
多維度arrays 236
摘要239
練習240
5: 隱藏實作細目243
package: 程式庫單元244
獨一無二的package 命名247
自訂一個程式庫251
利用imports 來改變行為252
使用package 的一些忠告254
Java 存取權限飾詞
(access specifiers) 255
"Friendly"(友善的) 255
public: 介面存取256
private: 不要碰我258
protected: 幾分友善260
介面與實作
(Interface and implementation) 261
Class 的存取權限263
摘要267
練習268
6: 重複運用Classes 271
複合(Composition)語法271
繼承(Inheritance)語法275
base class 的初始化278
兼容複合及繼承281
保證適當清理283
名稱遮蔽(Naming Hiding) 286
複合與繼承之間的抉擇288
protected(受保護的) 290
漸進式開發291
目錄
Thinking in Java (2e)
向上轉型(Upcasting) 291
為什麼需要向上轉型？ 293
關鍵字final 294
Final data 294
Final methods 299
Final classes 301
最後的告誡302
初始化以及class 的載入304
繼承與初始化304
摘要306
練習307
7: 多型(Polymorphism) 311
再探向上轉型(Upcasting) 311
將物件的型別忘掉313
竅門315
Method-call(函式呼叫)繫結方式315
產生正確的行為316
擴充性(Extensibility) 320
覆寫(overriding)vs.
重載(overloading) 324
Abstract classes(抽象類別)和
abstract methods(抽象函式) 325
建構式(Constructors)和
多型(polymorphism) 330
建構式叫用順序330
繼承與finalize( ) 333
多型函式(polymorphic methods)
在建構式中的行為337
將繼承(inheritance)運用於設計339
純粹繼承(Pure inheritance)
vs. 擴充(extension) 341
向下轉型(Downcasting)與
執行期型別辨識
(run-time type identification) 343
摘要346
練習346
8: 介面與內隱類別
Interfaces & Inner Classes 349
Interfaces(介面) 349
Java 的多重繼承354
透過繼承來擴充interface 358
產生常數群359
將interfaces 內的資料成員初始化361
巢狀的(nesting)interfaces 362
Inner classes(內隱類別) 365
Inner classes(內隱類別)與
upcasting(向上轉型) 368
位於methods 和scopes 之內的
Inner classes(內隱類別) 370
匿名的內隱類別
(Anonymous inner classes) 373
與外圍(outer)class 的連結關係376
static inner classes
(靜態內隱類別) 379
取用(referring)outer class 的物件381
從多層巢狀class 向外伸展觸角383
繼承inner classes 384
inner classes 可被覆寫嗎？ 385
Inner class 的識別符號(identifiers)387
為什麼需要inner classes？ 388
Inner classes 和control frameworks 394
摘要402
練習403
9: 持有你的物件407
Arrays(陣列) 407
Arrays 是第一級物件409
目錄
Thinking in Java (2e)
回傳一個array 413
Arrays class 415
array 的充填(filling) 428
array 的複製(copying) 429
arrays 的比較430
array 元素的比較431
arrays 的排序(sorting) 435
在已排序的array 中進行搜尋437
array 總結439
容器(container)簡介439
容器的列印441
容器的充填442
容器的缺點：元素型別未定450
有時候它總是可以運作452
製作一個具有型別意識
(type-conscious)的ArrayList 454
迭代器(Iterators) 456
容器分類學(Container taxonomy)460
Collection 的機能463
List 的機能467
根據LinkedList 製作一個stack 471
根據LinkedList 製作一個queue 472
Set 的機能473
SortedSet 476
Map 的機能476
SortedMap 482
Hashing 和hash codes 482
覆寫hashCode( ) 492
持有references 495
WeakHashMap 498
再論Iterators(迭代器) 500
選擇一份適當的實作品501
在各種Lists 之間抉擇502
在各種Sets 之間抉擇506
在各種Maps 之間抉擇508
Lists 的排序和搜尋511
公用函式(Utilities) 512
讓Collection 或Map
無法被更改513
Collection 或Map 的
同步控制514
未獲支援的操作516
Java 1.0/1.1 的容器519
Vector 和Enumeration 519
Hashtable 521
Stack 521
BitSet 522
摘要524
練習525
10: 透過異常(Exceptions)
處理錯誤531
基本異常(Basic exceptions) 532
異常引數(Exception arguments) 533
異常的捕捉534
try block 535
異常處理常式(Exception handlers)535
撰寫你自己的異常類別537
異常規格(exception specification)542
捕捉所有異常543
重擲(Rethrowing)異常545
Java 標準異常549
RuntimeException 的特殊情況550
目錄
Thinking in Java (2e)
以finally 進行清理(cleanup) 552
為什麼需要finally？ 554
缺憾：異常遺失557
異常的侷限558
建構式(Constructors) 562
異常的比對(matching) 566
異常的使用原則568
摘要568
練習569
11: Java I/O 系統573
File class 574
目錄列示器(a directory lister) 574
目錄的檢查和建立578
輸入和輸出581
InputStream 的類型581
OutputStream 的類型583
附加屬性(attributes)和有用介面585
透過FilterInputStream
自InputStream 讀取資料586
透過FilterOutputStream
將資料寫入OutputStream 587
Readers 和Writers 589
資料的來源(sources)
和去處(sinks) 590
改變stream 的行為591
未曾有任何變化的classes 592
RandomAccessFile 593
I/O streams 的典型運用594
Input streams 597
Output streams 599
這是個臭蟲嗎？ 601
管線化的(piped)streams 602
標準I/O 602
讀取標準輸入603
將System.out 轉換為PrintWriter 604
標準I/O 重導向(Redirecting) 604
壓縮606
運用GZIP 進行單純壓縮607
運用Zip 儲存多份檔案資料608
Java ARchives (JARs) 611
物件次第讀寫(Object serialization) 613
找出class 618
控制次第讀寫(serialization) 619
使用物件永續機制(persistence) 630
被「語彙單元化」(Tokenizing)的
輸入動作639
StreamTokenizer 639
StringTokenizer 642
檢驗大小寫645
摘要655
練習656
12: 執行期型別辨識
Run-time Type Identification 659
為什麼需要RTTI 659
Class 物件662
轉型之前先檢查665
RTTI 語法674
Reflection: 執行期類別資訊677
實作一個函式提取器(extractor) 679
摘要685
練習686
13: 製作視窗和網頁小程式
(Applets) 689
基本的applet 692
Applet 的束縛692
Applet 的優點693
目錄
Thinking in Java (2e)
應用程式框架
(Application frameworks) 694
在Web 瀏覽器上執行applets 695
運用Appletviewer 698
測試applets 698
從命令列執行applets 700
一個顯示框架702
運用Windows Explorer 705
製作一個按鈕(button) 706
捕捉一個事件(event) 707
文字區(Text areas) 711
控制版面佈局712
BorderLayout 713
FlowLayout 714
GridLayout 715
GridBagLayout 716
絕對定位716
BoxLayout 717
最好的方法是什麼？ 721
Swing 的事件模型(event model) 722
事件(event)及監聽器(listener)
的種類723
追蹤多種事件730
Swing 組件一覽734
按鈕(Buttons) 734
圖示(Icons) 738
工具提示(Tool tips) 740
文字欄(Text fields) 740
框線(Borders) 743
JScrollPanes 744
迷你文字編輯器(mini-editor) 747
方鈕，核取方塊(Check boxes) 748
圓鈕(Radio buttons) 750
複合方塊，下拉式清單
(Combo boxes, drop-down lists) 751
清單方塊(List boxes) 753
頁籤式嵌版(Tabbed panes) 755
訊息方塊(Message boxes) 756
功能表(Menus) 759
冒起式功能表(Pop-up menus) 766
繪圖(Drawing) 768
對話方塊(Dialog Boxes) 771
檔案對話方塊(File dialogs) 776
Swing 組件上的HTML 779
滾軸(Sliders)和
進度指示器(progress bars) 780
樹狀組件(Trees) 781
表格(Tables) 784
選擇外觀風格(Look & Feel) 787
剪貼簿(clipboard) 790
將applet 封裝於JAR 檔793
編程技術794
動態繫結事件
(Binding events dynamically) 794
將business logic 和UI logic 隔離796
標準型式799
視覺化程式設計與Beans 800
什麼是Bean？ 801
運用Introspector 提取出BeanInfo 804
一個更為複雜精巧的Bean 811
Bean 的包裝(Packaging a Bean) 816
Bean 所支援的更複雜功能818
其他819
摘要819
練習820
14: 多緒(Multiple Threads)
825
反應靈敏的UI 826
繼承自Thread 828
目錄
Thinking in Java (2e)
運用執行緒打造出反應靈敏的UI 831
結合執行緒和程式主類別834
產生多個執行緒836
Daemon 執行緒840
共享有限資源842
不當的資源存取842
Java 如何共享資源848
再探JavaBeans 854
停滯(阻塞, Blocking) 859
轉為停滯狀態(Becoming blocked)860
死結(Deadlock) 872
優先權(Priorities) 877
優先權的讀取和設定878
執行緒群組(Thread groups) 882
再探Runnable 891
過多的執行緒894
摘要899
練習901
15: 分佈式計算
(Distributed Computing) 903
網絡編程904
機器的識別905
Sockets 909
服務多個用戶917
資料元(Datagrams) 923
在applet 中使用URL 923
更多的網絡相關資訊926
JDBC, Java 資料庫連結機制927
讓本節實例正常運作931
一個GUI 版的查詢程式935
為什麼JDBC API 看起來如此複雜938
一個更複雜的範例939
Servlets 948
Servlet 基本教練949
Servlets 和多緒954
以servlets 處理sessions 955
執行servlet 範例程式960
Java Server Pages(JSP) 960
隱式物件(Implicit objects) 962
JSP 指令(directives) 963
JSP 腳本描述成份964
取出欄位(fields)和
數值(values) 966
JSP 的頁面屬性(page attributes)
和有效範圍(scope) 968
處理JSP 中的sessions 969
產生並修改cookies 971
JSP 摘要972
RMI (Remote Method Invocation)
遠端函式調用973
遠端介面(Remote interfaces) 973
實作出遠端介面974
產生stubs 和skeletons 978
使用遠端物件(remote object) 979
CORBA 980
CORBA 的基本原理981
一個實例983
Java Applets 和CORBA 989
CORBA vs. RMI 989
Enterprise(企業級)JavaBeans 990
JavaBeans vs. EJBs 991
EJB 規格992
EJB 組件993
EJB 組件成份994
目錄
Thinking in Java (2e)
EJB 的各項操作995
EJBs 的類型996
分發(Developing)EJB 997
EJB 摘要1003
Jini: 分佈式服務1003
Jini 的來龍去脈1003
什麼是Jini? 1004
Jini 如何運作1005
Discovery 動作1006
Join 動作1006
Lookup 動作1007
介面和實作的分離1008
將分佈式系統抽象化1009
摘要1010
練習1010
A: 物件的傳遞和回傳1013
References 的傳遞1014
別名(Aliasing) 1014
製作一個區域性副本1017
Pass by value(傳值) 1018
物件的克隆(Cloning) 1018
賦予class 克隆能力1020
成功的克隆1022
Object.clone( ) 的效應1025
克隆一個複合物件
(composed object) 1027
對ArrayList 進行深層拷貝1030
透過serialization 進行深層拷貝1032
將克隆能力加到繼承體系的更下層1034
為什麼要有這種奇怪的設計？ 1035
克隆能力(cloneability)的控制1036
copy 建構式1042
唯讀類別(Read-only classes) 1047
撰寫一個唯讀類別1049
恆常性(immutability)的缺點1050
恆常不變的Strings 1052
String 和StringBuffer 1056
Strings 是特殊的東西1060
摘要1060
練習1062
B: Java 原生介面
Java Native Interface (JNI) 1065
原生函式的調用1066
表頭檔產生器：javah 1067
名稱重整(Name mangling)與
函式標記(function signatures) 1068
實作出你自己的DLL 1068
取用JNI 函式: 透過JNIEnv 引數1069
存取Java Strings 1071
傳遞和運用Java 物件1071
JNI 和Java 異常1074
JNI 和多緒1075
使用既有的程式碼1075
補充資訊1076
目錄
Thinking in Java (2e)
C: Java 編程準則1077
設計1077
實作1084
D: 資源1091
軟體1091
書籍1091
分析& 設計1093
Python 1095
我的著作1096
索引1099
譯序
Thinking in Java (2e)
xxix
譯序(1)
侯捷
我完成942+ 頁的《深入淺出MFC》2/e(著作)和1237+ 頁的《C++ Primer 3e
中文版》(譯作)之後，曾經罹患一種厚書恐懼症。畢竟大部頭書籍的寫作
和翻譯都異常艱巨，包括材料之取捨、用語風格及術語之協調、長時間的工
作過程和期待…，對於作者和譯者的組織力、創作力、毅力都是一種嚴苛的
考驗。
但《Thinking in Java》2e 畢竟不同一般。這本書將在Java programming 基礎
教育上起重要作用。我於是懷著戒慎恐懼(但也開心)的心情再度接下這份
重任。建興和我，以幾近一年的時間，完成了這本1127+ 頁大部頭書籍的翻
譯和版面製作。
Java 的面向太廣太廣，不可能有一本涵蓋全貌的書籍(我們也不應該有「一
次買足」的心理)。就相對全貌而言，《Thinking in Java》是一本取材廣泛而
表現優異的作品。其最大特色就是：(1) 內容涵蓋面大，(2) 許多主題(特別
是物件導向編程技術)極為深入，廣泛而又深刻的論述形成了1127+ 頁的份
量，(3) 英文版由作者Bruce Eckel 免費開放，造福很多人，也因而影響了很
多人(因此你很容易找到一個可以共同討論書中觀點的朋友)。
本書的優異表現，從讀者的熱情回應(摘列於書前)可見一斑。乍看之下這
雖然像是一本初學教本，而它也的確勝任此一角色，但它對某些主題(例如
Polymorphism, Object Serialization, Reflection, RTTI, I/O, Collections)的深入
討論，肯定也能帶給許多Java 老手新的刺激。
譯序
Thinking in Java (2e)
xxx
本書(繁體中文版)延用我個人喜愛的「頁頁對譯」方式，用以和英文版頁
次達成一種直覺對應，並輕鬆保留書內所有交叉參考(cross reference)和書
後完整索引。索引詞條皆不譯，我個人認為值得保留的英文術語亦不譯(第
一次出現或某個頻率下我會讓它英中並陳)。之所以保留英文術語，我已多
次為文闡述個人想法，文章都公佈在侯捷網站上(http://www.jjhou.com)。
做為本書英文版的一個認真讀者，我要說，我確實從這本書學習了許多深刻
的見識。希望透過我和建興的努力，這本中文版能夠協助更多人高效、精準、
深刻地認識並學習Java。
為了仿效並致敬Bruce Eckel 開放《Thinking in Java》2e 英文版的精神，侯捷
網站(http://www.jjhou.com)將開放本中文版前9 章及4 個附錄，佔全書篇
幅幾近1/2。我要特別感謝眳p出版公司對此一決定的鼎力支持。
今年我同時準備了初階、中階、高階共四本Java 書籍中譯本以饗讀者，它們
是：
1. Thinking in Java, 2e, by Bruce Eckel, Prentice Hall, 2000
2. Practical Java, by Peter Haggar, Addison Wesley 2000
3. Effective Java, by Joshua Bloch, Addison Wesley 2001
4. Refactoring - Improving the Design of Existing Code, by Martin Fowler, Addison
Wesley 2000(此書不限Java，只是以Java 為表述工具)
侯捷2002.07.01 臺灣.新竹
http://www.jjhou.com (中文繁體)
http://jjhou.csdn.net (中文簡體)
jjhou@jjhou.com (電子郵箱)
  中文版勘誤維護於侯捷網站http://www.jjhou.com。
  本書英文版前後數頁關於作者Bruce Eckel 個人網站、研討會課程、CD 產
品廣告(圖片和文字)皆不譯，但保留，以示對作者之尊重。
譯序
Thinking in Java (2e)
xxxi
譯序(2)
王建興
呼，好厚的一本書，可不是嗎？
能夠參予這本書籍的翻譯是我的榮幸。以Java 入門書而言，《Thinking in Java》
一直都是我心目中的第一首選。Java 的世界看似複雜其實單純。炫人耳目的
反倒是核心之外的各種library。對於一本入門書來說，首要之務無非是讓讀
者了解語言核心，而《Thinking in Java》成功地做到了這一點。它在內容篇幅
的拿捏上恰到好處，讓讀者深入了解語言核心的同時，又能夠對Java 所涵蓋
極為廣泛的各套API，都能夠有所認識。這是它之所以能夠成為如此成功的
一本書的原因。
這樣的好書，當然值得花這麼多的時間來和它相處。
謝謝侯大哥給予機會參與這本譯作的產生，以及長久以來的指導。也謝謝
CSZone 上的sofar 以及我的妹妹嘉凌，與他們的討論解決了許多我對本書內
容的疑難。當然要謝謝我的媽媽，不時提醒我要加緊腳步。最後要謝謝淑卿，
允許我撥出原本應當屬於她的時間來進行本書的翻譯工作。謝謝大家。
王建興@新竹
譯序
Thinking in Java (2e)
xxxii
關於本書術語，請注意：
  侯捷網站提供一份計算機術語英中繁簡對照(持續完善中)，請參考。
  Java 所謂之method(方法)，即C/C++ 之member function(成員函式)。
將method 譯為「方法」，容易與前後文混雜，不易突顯術語之獨特性，
因此本書一律將method 譯為「函式」或「成員函式」。
  Java 所謂之field(資料欄)，即C/C++ 之data members(資料成員)。
由於field 一詞在其他諸多地方(例如資料庫)也被採用，為避免混淆並
求一致性，本書一律將class field 譯為「資料成員」。
  copy 和clone 在臺灣皆謂之「複製」。然而其中有些不同。clone, cloneable,
cloneability 且為一種Java 技術概念。因此，為求區別，本書將copy 譯為
「複製」或「拷貝」，將clone 譯為「克隆」(音譯，取乎「拷貝」之譯
法。見p1018)。「克隆」在中國大陸是一個被普遍使用的詞。
Java 環境設定
Thinking in Java (2e)
xxxiii
Java
環境設定by 侯捷
本附錄為譯者所加，說明Java 開發工具(JDK)之下載及環境設定。
任何人可於Java 官方網站(http://java.sun.com)自由下載JDK，如圖1。
圖1. Java 官方網站提供JDK 最新版本
下載所得是個可執行檔，一旦被執行起來，便自動解壓縮並進行安裝。安裝程序很簡單，
只要遵循畫面指示進行即可。預設安裝路徑是c:\jdk1.3 或c:\jdk1.4.0(或類似路徑)。
安裝JDK 1.3 後，C:\JDK1.3\BIN\ 內將放置各種開發工具，部分如下：
jar.exe 壓縮工具。請參考p611。
java.exe 執行工具，可接受.class 檔(byte code)並啟動Java 虛擬機器執行之。
請參考p122。
javac.exe 編譯器(其實只是個外包器，wrapper)。可接受.java 檔(程式原始碼)並
產出.class 檔(byte code)。請參考p122。
javadoc.exe 文件製作工具。請參考p123。
javah.exe 表頭檔(header)產生器。請參考p1067。
appletviewer.exe 網頁小程式(applet)執行器。請參考p698。
...
Java 環境設定
Thinking in Java (2e)
xxxiv
我個人習慣為JDK 撰寫一個環境設定批次檔，如以下之jdk13.bat：
@echo off
rem JDK1.3
set PATH=C:\jdk1.3\bin;C:\WINDOWS;C:\WINDOWS\COMMAND
set classpath=.;c:\jdk1.3\lib\tools.jar
將這份環境設定檔設為某個DOS 視窗的「內容」表單下的「程式」附頁中的批次檔，如
圖2。於是，一旦開啟(雙擊)該DOS 視窗，就會自動設定好上述的JDK1.3 開發環境
和執行環境，如圖3。
一個Java 程式可由多個.java 檔(源碼)構成，每個.java 檔內可容納多個classes。編譯
器針對每個class產生對應而獨立的.class 檔(內置byte code)。凡public class 並含有main()
函式者，該函式便可被當做程式進入點，而該class 名稱也就是你應該在java.exe 命令
列中指定的名稱(大小寫必須完全一致)。請見p121「編譯與執行」。
圖2. 設定DOS 視窗，使之執行前述的jdk13.bat，將JDK 環境設定妥當。
Java 環境設定
Thinking in Java (2e)
xxxv
圖3. 開啟(雙擊)圖2 設定之DOS 視窗，便可在其中編譯Java 程式。本畫面顯示以javac.exe
編譯本書第11 章程式MyWorld.java(將獲得可執行檔MyWorld.class)。再以工具java.exe
執行MyWorld.class(命令列中不可指定副檔名".class")。
Java 環境設定
Thinking in Java (2e)
xxxvi
1







1: 物件導論
Introduction to Objects
電腦革命始於機器。因此，程式語言的發軔也始於對機器
的模仿。
不過，電腦並非是那麼冷冰冰的機器。電腦是意念發揮的工具(一如Steve
Jobs 常喜歡說的「意念的自行車」一樣)，並且也是一種不同類型的表達
媒介。這個工具愈偏離機器的長相，就愈像我們頭腦的一部份，一如寫
作、繪畫、雕刻、動畫、電影等意念表達形式。物件導向程式設計
(Object-oriented Programming，OOP)，便是這樣一個以電腦做為表達
媒介的巨大浪潮中的一環。
本章將為你介紹基本的OOP 觀念，並涵括軟體開發方法的概論性介紹。本
章，甚至整本書，都假設你對程序性語言(procedural programming
language)有著某種程度的經驗，我所謂程序性語言不一定得是C。如果
你覺得有必要在接觸此書之前先在程式設計和C 語法上多下功夫，你可以
研讀本書所附的培訓光碟《Thinking in C: Foundations for C++》，其內
容也可以從www.BruceEckel.com 取得。
本章提供的是背景性、補充性的材料。許多人在沒有看清整個物件導向程
式設計方法的完整面貌之前，無法自在地從事此類設計活動。因此，我將
引入許多觀念，為你奠定OOP 的紮實基礎。另外還有許多人在沒有看到某
種程度的實際運作機制之前，無法看清物件導向程式設計方法的完整面
貌。這樣的人如果沒有程式碼在手，很容易迷失方向。如果你正是這種
人，而且渴望早點知道Java 語言的細節，請你從容跳過本章，這並不會影
響你的程式撰寫和語言學習。不過，相信我，最終你還是需要回過頭來填
補必要的知識，藉以了解物件的重要，以及「透過物件進行設計」的方
式。





132 Thinking in Java www.BruceEckel.com
133
3: 控制程式流程
Controlling Program Flow
和有情眾生一樣，程式也必須處理它自身的世界，並且在
執行過程中有所抉擇。
在Java 裡頭，物件和資料的處理是透過運算子(operators)來達成，而選
擇與判斷則倚靠所謂的控制述句(control statements)。Java 繼承自
C++，因此其大多數述句和運算子對C 和C++程式員來說都不陌生。Java
並且在某些地方做了改進和簡化。
如果你發現自己在本章內容的理解上感到費力，請確認自己的確看過本書
所附的多媒體光碟《Thinking in C: Foundation for Java and C++》中的
課程內容。光碟內含有聲課程、投影片、習題、解答。這些材料乃是特別
量身打造，能教導你儘早學會在Java 學習過程中必備的C 語法。
使用Java 運算子(operators)
運算子接受一個或多個引數(arguments)，並產生新值。引數的形式不同
於一般函式，但二者所產生的效應一致。有了過去的編程經驗，你應該很
容易接受一般的運算子觀念。加法(+)、減法和負號(-)、乘法
(*)、除法(/)、以及賦值(=)，其運作方式和其他程式語言幾乎沒
有什麼兩樣。
所有運算子都會依據運算元(operands)之值來產生新值。此外，運算子
也可以改變運算元之值，此乃所謂「副作用(side effect)」。這些會更改
運算元內容的運算子，最廣泛的用途便是用來產生副作用。不過你應該牢
記於心：使用此類運算子所產生的值，和使用其他類運算子所產生的值，
方式上並沒有什麼不同。
134 Thinking in Java www.BruceEckel.com
絕大多數運算子都只能作用於基本型別上。'='、'=='、'!= ' 是例外，它們
可作用於任何物件身上，但這種應用頗易令人迷惑(譯註：就我的觀點，
我並不認為這令人迷惑，反而是一種優點)。除此之外，String 類別也支
援'+' 和'+=' 運算子。
優先序(Precedence)
所謂運算子優先序，定義出單一運算式(expression)內同時出現多個運算
子時，該運算式的核定(評估、evaluate)方式。Java 對於核定動作的進
行順序遵循特定規則，「先乘除，後加減」是最容易記住的一條規則。其
他規則很容易被遺忘，所以你應該使用小括號明確指定核定順序。例如：
A = X + Y - 2/2 + Z;
便和以小括號加以區分的同一述句(如下)，有著不同的意義：
A = X + (Y - 2)/(2 + Z);
賦值、指派(Assignment)
賦值動作是以'=' 運算子為之。賦值(指派)的意義是取得運算子右邊的
值(通常稱為右值rvalue)，將該值複製到運算子左邊(通常稱為左值
lvalue)。右值可以是任何常數、變數、或有能力產生數值的算式，左值則
必須是個明確的、具名的變數(也就是說，必須有實際儲存空間以儲存某
值)。例如你可以將某個常數指派給某個變數(A = 4;)，但你無法將任
何形式的值指派給常數，因為常數不能做為左值(你不能寫4 = A;)。
基本型別的賦值動作相當直覺。因為基本型別儲存的是實際數值，而非
object reference。當你進行基本型別的賦值動作時，會將某值複製到另一
個值身上。例如，對基本型別寫下A = B，B 的內容便會被複製到A。如
果你接著修改A 值，B 當然不會被波及。身為程式員的你，在大多數情況
下都會很自然地這麼預期。但是當你操作某個物件時，你所操作的其實是
它的reference。所以當你「將某個物件指派給另一個物件」，實際上是將
Chapter 3: Controlling Program Flow 135
其reference 從某處複製到另一處。這意謂，如果對是將寫下C = D 這樣
的式子，會造成C 和D 都指向原先D 所指的物件。以下例子用來說明這
個現象。
//: c03:Assignment.java
// Assignment with objects is a bit tricky.
class Number {
int i;
}
public class Assignment {
public static void main(String[] args) {
Number n1 = new Number();
Number n2 = new Number();
n1.i = 9;
n2.i = 47;
System.out.println("1: n1.i: " + n1.i +
", n2.i: " + n2.i);
n1 = n2;
System.out.println("2: n1.i: " + n1.i +
", n2.i: " + n2.i);
n1.i = 27;
System.out.println("3: n1.i: " + n1.i +
", n2.i: " + n2.i);
}
} ///:~
Number class 十分單純。它的兩個實體(n1 和n2)在main() 中產生
出來。每個Number 實體內的i 都被賦予不同之值，然後n2 被指派給
n1，然後n1 的內容被改變。在許多程式語言中，你會預期n1 和n2 始終
都是獨立而互不干擾，但因為這裡所指派的乃是reference，所以你看到的
輸出結果是：
1: n1.i: 9, n2.i: 47
2: n1.i: 47, n2.i: 47
3: n1.i: 27, n2.i: 27
136 Thinking in Java www.BruceEckel.com
更動n1 內容，同時也更動了n2 內容！這是因為n1 和n2 內含同一個
object reference。原先n1 所儲存的reference，乃是指向數值為9 的物
件，而那個reference 在賦值過程中被覆寫了，實際上也就是遺失掉了；垃
圾回收器(garbage collector)會在適當時機清理該reference 原本所指的
那個物件。
上述現象通常被稱為aliasing(別名)，這是Java 對於物件的基本處理模
式。如果這個例子中你不希望發生別名現象，可以改用這種寫法：
n1.i = n2.i;
這樣的寫法能讓兩個物件依舊保持相互獨立，無需將n1 和n2 繫結至同一
物件並因而捨棄另一個。不過，你很快便會了解，直接操作物件內的欄位
會導致混亂，同時也和良好的物件導向設計法則背道而馳。這並不是淺顯
的課題，所以我把它留給附錄A，那兒專門討論別名(aliasing)問題。請
千萬不要忘記，物件的指派(賦值)動作會帶來令人意想不到的結果。
呼叫函式時的別名(aliasing)問題
當你將物件傳入函式，也會引發別名現象：
//: c03:PassObject.java
// Passing objects to methods may not be what
// you're used to.
class Letter {
char c;
}
public class PassObject {
static void f(Letter y) {
y.c = 'z';
}
public static void main(String[] args) {
Letter x = new Letter();
x.c = 'a';
System.out.println("1: x.c: " + x.c);
f(x);
System.out.println("2: x.c: " + x.c);
}
Chapter 3: Controlling Program Flow 137
} ///:~
在許多程式語言中，f() 會在函式範圍之內為其引數Letter y 製作一份複
本。但因為現在傳入的其實是個reference，所以這一行：
y.c = 'z';
實際上會更動到f() 範圍外的那個原本物件。程式結果說明了這一點：
1: x.c: a
2: x.c: z
別名(aliasing)所引起的問題及其解決方法，是個很複雜的議題。雖然你
必須閱讀附錄A 的內容才能得到所有解答，但此時你應該知道有這麼一個
問題，才能夠處處小心而不至於落入陷阱。
數學運算子(Mathematical operators)
Java 的基本數學運算子和大多數程式語言一樣：加法(+)、減法(-)、
除法(/)、乘法(*)、模數(%，用來取得整數相除後的餘數)。整數
除法會將所得結果的小數部份截去，不會自動四捨五入。
Java 也使用簡略標記形式，讓某種運算動作和賦值動作同時進行。這種簡
略標記法是在運算子之後緊接著等號，適用於Java 語言中的所有運算子
(如果對該運算子而言，這種寫法有意義的話)。例如想要將變數x 加4
並將結果指派給x，就可以這麼寫：x += 4。
下面這個範例說明了數學運算子的使用：
//: c03:MathOps.java
// Demonstrates the mathematical operators.
import java.util.*;
public class MathOps {
// Create a shorthand to save typing:
static void prt(String s) {
System.out.println(s);
}
// shorthand to print a string and an int:
138 Thinking in Java www.BruceEckel.com
static void pInt(String s, int i) {
prt(s + " = " + i);
}
// shorthand to print a string and a float:
static void pFlt(String s, float f) {
prt(s + " = " + f);
}
public static void main(String[] args) {
// Create a random number generator,
// seeds with current time by default:
Random rand = new Random();
int i, j, k;
// '%' limits maximum value to 99:
j = rand.nextInt() % 100;
k = rand.nextInt() % 100;
pInt("j",j); pInt("k",k);
i = j + k; pInt("j + k", i);
i = j - k; pInt("j - k", i);
i = k / j; pInt("k / j", i);
i = k * j; pInt("k * j", i);
i = k % j; pInt("k % j", i);
j %= k; pInt("j %= k", j);
// Floating-point number tests:
float u,v,w; // applies to doubles, too
v = rand.nextFloat();
w = rand.nextFloat();
pFlt("v", v); pFlt("w", w);
u = v + w; pFlt("v + w", u);
u = v - w; pFlt("v - w", u);
u = v * w; pFlt("v * w", u);
u = v / w; pFlt("v / w", u);
// the following also works for
// char, byte, short, int, long,
// and double:
u += v; pFlt("u += v", u);
u -= v; pFlt("u -= v", u);
u *= v; pFlt("u *= v", u);
u /= v; pFlt("u /= v", u);
}
} ///:~
Chapter 3: Controlling Program Flow 139
首先映入眼簾的是一些用於列印的簡單函式： prt() 用來列印某個
String，pInt() 會在列印某個String 之後緊接著印出一個int，pFlt()
會在列印String 之後緊接著印出一個float。當然，這些函式最終都會用
到System.out.println()。
為了產生許多數字，此程式首先產生一個Random 物件。產生這個物件
時我們並未傳入任何引數，所以Java 使用執行當時的時間作為亂數種子。
此程式會透過Random 物件呼叫不同的函式：nextInt()、nextLong()、
nextFloat()、nextDouble()，產生多個不同型別的亂數。
將模數(modulus)運算子% 作用於亂數產生器所產生的亂數身上，目的
是為了讓隨機亂數的最大值侷限在我們所指定的運算元數值減1(本例為
99)範圍內。
一元(Unary)運算子：負號(minus)和正號(plus)
負號(-)和正號(+)都是一元運算子，其符號和二元運算子中的加法和
減法相同。編譯器會依據算式的寫法，判斷你想使用的究竟是哪一種。例
如以下述句的意義就很明顯：
x = -a;
編譯器也可以理解以下述句：
x = a * -b;
但是程式閱讀者可能感到困惑，所以這樣子寫更為明確些：
x = a * (-b);
負號運算子會取得其運算元的負值。正號運算子的功能和負號運算子相反
- 其實它沒有產生任何影響。
遞增(increment)和遞減(decrement)
Java 和C 一樣，充滿著許多能夠帶來便捷的手法，它們能使程式碼更容易
完成，有可能使程式碼更易於閱讀，但也有可能造成反效果。
140 Thinking in Java www.BruceEckel.com
在許多便捷手法中，遞增和遞減運算子是兩個好東西(通常稱為自動遞增
和自動遞減運算子)。遞減運算子的符號是--，意指「減去一個單位」。
遞增運算子的符號是++，意指「加上一個單位」。如果a 是個int，那麼
++a 便和a=a+1 等價。因此，遞增和遞減運算子會為運算元產生新值。
遞增和遞減運算子各有兩個版本，通常稱為前序(prefix)版本和後序
(postfix)版本。前序遞增是指++ 運算子出現於變數或算式之前，後序
遞增則是指++ 運算子出現於變數或算式之後。同樣道理，前序遞減是指
-- 運算子出現在變數或算式之前，後序遞減是指-- 運算子出現在變數
或算式之後。對前序遞增和前序遞減(也就是++a 和--a)而言，會先進
行運算然後才指派其值。而後序遞增和後序遞減(也就是a++ 和a--)而
言，會先指派其值然後才進行運算。下面是個實例：
//: c03:AutoInc.java
// Demonstrates the ++ and -- operators.
public class AutoInc {
public static void main(String[] args) {
int i = 1;
prt("i : " + i);
prt("++i : " + ++i); // Pre-increment
prt("i++ : " + i++); // Post-increment
prt("i : " + i);
prt("--i : " + --i); // Pre-decrement
prt("i-- : " + i--); // Post-decrement
prt("i : " + i);
}
static void prt(String s) {
System.out.println(s);
}
} ///:~
輸出結果是：
i : 1
++i : 2
i++ : 2
i : 3
--i : 2
Chapter 3: Controlling Program Flow 141
i-- : 2
i : 1
你看到了，以前序(prefix)形式為之，會在運算執行完畢後才擷取其值
(變數或算式的值)，如果以後序(postfix)形式為之，會在運算執行之
前便先擷取其值以為它用。所有運算子中，會引起副作用的，除了那些帶
有賦值動作的運算子外，就是這些遞增、遞減運算子了。也就是說，這些
運算子會改變(而不單單只是使用)運算元的值。
遞增運算子是C++的名稱源由之一，意思是「超越C 更進一步」。Bill Joy
(Java 的創造者之一)曾經在一場Java 演講中說過：Java=C++--(C 加
加再減減)。這句話的意思是：Java 是「移去累贅、困難部份之後的
C++」，因此是個更為單純的程式語言。當你逐步閱讀本書，你會發現，
Java 的確在許多地方更為單純，但Java 卻不比C++簡單太多。
關係運算子(Relational operators)
關係運算子所產生的結果是boolean。此類運算子會評估兩個運算元之間
的關係。如果其關係為真，運算結果便為true。如果其關係為偽，運算結
果便為false。關係運算子有小於(<)、大於(>)、小於等於(<=)、
大於等於(>=)、等於(==)、不等於(!=)等共六種。== 和!= 可作
用於所有內建型別身上，其他運算子無法作用於boolean 型別。
物件相等性(object equivalence)的測試
關係運算子== 和!= 也可作用於任何物件身上，但這兩個運算子的意義
常常會對初次接觸Java 的程式員帶來困惑。以下便是個例子：
//: c03:Equivalence.java
public class Equivalence {
public static void main(String[] args) {
Integer n1 = new Integer(47);
Integer n2 = new Integer(47);
System.out.println(n1 == n2);
System.out.println(n1 != n2);
}
} ///:~
142 Thinking in Java www.BruceEckel.com
System.out.println(n1 == n2) 這行算式會印出括號中的比較結果
(boolean 值)。想當然爾，本例輸出結果當然先是true 而後false，因
為兩個Integer 物件的值是相同的。不過雖然兩個物件的內容相同，其
references 卻不同。由於== 和!= 運算子所比較的是object references，
所以實際輸出結果是false 而後true。這樣的結果當然會令初次接觸Java
的人們大感驚訝。
如果我們想知道物件的內容是否相等，又該如何？你得使用equals()。任
何一個物件(不含那些能夠正常運用== 和!= 的基本型別)都擁有這個
函式。以下便是其運用方式：
//: c03:EqualsMethod.java
public class EqualsMethod {
public static void main(String[] args) {
Integer n1 = new Integer(47);
Integer n2 = new Integer(47);
System.out.println(n1.equals(n2));
}
} ///:~
結果如你所預期，印出true。呃，不過事情並非如此簡單。如果你建立自
有的class，好比這樣：
//: c03:EqualsMethod2.java
class Value {
int i;
}
public class EqualsMethod2 {
public static void main(String[] args) {
Value v1 = new Value();
Value v2 = new Value();
v1.i = v2.i = 100;
System.out.println(v1.equals(v2));
}
} ///:~
Chapter 3: Controlling Program Flow 143
情況再度回到原點：輸出結果是false。這是因為equals() 的預設行為是
拿references 來比較。所以除非你在你的classes 中覆寫(override)
equals()，否則便得不到你想得到的行為。不幸的是直到第七章你才會學
到所謂的覆寫技術。儘管如此，了解equals() 的運作方式，還是可以讓
你免於犯下某些錯誤。
Java 標準程式庫中的大多數classes 都覆寫了equals()，所以它們都會比
較物件(而非其references)的內容是否相等。
邏輯運算子(Logical operators)
邏輯運算子AND(&&)、OR(||)、NOT(!)都會得到boolean 值。
此值究竟是true 或false，取決於引數間的邏輯關係。下面這個例子使用
關係運算子和邏輯運算子：
//: c03:Bool.java
// Relational and logical operators.
import java.util.*;
public class Bool {
public static void main(String[] args) {
Random rand = new Random();
int i = rand.nextInt() % 100;
int j = rand.nextInt() % 100;
prt("i = " + i);
prt("j = " + j);
prt("i > j is " + (i > j));
prt("i < j is " + (i < j));
prt("i >= j is " + (i >= j));
prt("i <= j is " + (i <= j));
prt("i == j is " + (i == j));
prt("i != j is " + (i != j));
// Treating an int as a boolean is
// not legal Java
//! prt("i && j is " + (i && j));
//! prt("i || j is " + (i || j));
//! prt("!i is " + !i);
144 Thinking in Java www.BruceEckel.com
prt("(i < 10) && (j < 10) is "
+ ((i < 10) && (j < 10)) );
prt("(i < 10) || (j < 10) is "
+ ((i < 10) || (j < 10)) );
}
static void prt(String s) {
System.out.println(s);
}
} ///:~
你只能將AND、OR、NOT 施用於boolean 值身上。邏輯算式中的
boolean 值無法以non-boolean 值替代，這在C/C++中卻是可以的。你
可以看到上例某個部分由於這個原因而導致失敗，該部分已用//! 標示起
來成為註解。緊接於其後的算式則使用邏輯運算子(logical operators)來
產生boolean 值，然後才將邏輯運算施加於所產生的boolean 值身上。
輸出結果可能是這樣(譯註：由於採用亂數，每次結果可能不盡相同)：
i = 85
j = 4
i > j is true
i < j is false
i >= j is true
i <= j is false
i == j is false
i != j is true
(i < 10) && (j < 10) is false
(i < 10) || (j < 10) is true
請注意，如果boolean 值被用於某個預期會出現String 的地方，其值會
被自動轉換為適當的文字形式。
你可以在上述程式中以任何non-boolean 基本型別來替換int。不過請務
必明白，浮點數的比較是很嚴格的。兩個相差極微的浮點數仍然是不相等
的。是的，一個只比零大一點點的數字，依然不能說是零。
遽死式(短路式，Short-circuiting)核定
處理邏輯運算子時，有所謂「short circuiting(遽死、短路)」的現象發
生。意思是說，當整個算式的值可以被確切判斷出真偽時，算式的評估
Chapter 3: Controlling Program Flow 145
(核定)動作便會結束。如此一來，邏輯算式中的某些部份就可能不會被
評估到。以下是個例子：
//: c03:ShortCircuit.java
// Demonstrates short-circuiting behavior.
// with logical operators.
public class ShortCircuit {
static boolean test1(int val) {
System.out.println("test1(" + val + ")");
System.out.println("result: " + (val < 1));
return val < 1;
}
static boolean test2(int val) {
System.out.println("test2(" + val + ")");
System.out.println("result: " + (val < 2));
return val < 2;
}
static boolean test3(int val) {
System.out.println("test3(" + val + ")");
System.out.println("result: " + (val < 3));
return val < 3;
}
public static void main(String[] args) {
if(test1(0) && test2(2) && test3(2))
System.out.println("expression is true");
else
System.out.println("expression is false");
}
} ///:~
每個測試動作都對傳入的引數進行了比較，並回傳true 或false。同時也列
印訊息，表示該函式正被呼叫。這些測試動作被使用於以下算式中：
if(test1(0) && test2(2) && test3(2))
你可能很自然地認為所有測試動作都會被執行，但輸出結果卻說明事實並
非如此：
test1(0)
146 Thinking in Java www.BruceEckel.com
result: true
test2(2)
result: false
expression is false
第一個測試結果為true，所以算式評估動作繼續進行。第二個測試結果為
false，這意謂整個算式結果必為false，那麼還有什麼理由得繼續算式剩
餘部份的評估呢？繼續執行無意義的評估，代價可能很昂貴。shortcircuiting
的存在正是基於這個原因。如果可以不必評估算式中的所有部
份，將因此帶來效率的提升。
位元運算子(Bitwise operators)
位元運算子讓你可以操作基本整數型別中的個別位元。位元運算子會在兩
個引數的相應位元上執行boolean 代數運算以求結果。
位元運算子承襲C 語言的低階定位：你時而需要直接處理硬體，並設定硬
體暫存器中的位元。由於Java 一開始是針對內嵌於電視的set-top boxes
(譯註：或譯為機上盒，通常與電視相連，提供許多和電視整合的服務)
而設計，因此這個低階定位對Java 來說仍具意義。不過或許你不會太常用
到位元運算子。
位元運算子AND(&)會在兩個輸入位元皆為1 時，產生一個輸出位元1；
否則為0。位元運算子OR(|)會在兩個輸入位元中有任何一個為1 時，
產生一個輸出位元1；當兩個輸入位元皆為0，結果為0。位元運算子
EXCLUSIVE OR，或稱XOR(^)，會在兩個輸入位元恰有一個為1(但
不可同時為1)時，產生結果值1。位元運算子NOT(~)，也稱為「一的
補數(one’s complement)」運算子，是個一元運算子(其他位元運算子
都是二元運算子)，僅接受一個引數，它會產生輸入位元的反相：如果輸
入位元為0，結果就是1，如果輸入位元為1，結果就是0。
位元運算子和邏輯運算子使用同一套運算符號。為了加以區分，如果有個
助憶法來協助我們，將會大有助益。是的，由於位元很「小」，所以位元
運算子僅使用一個字元符號，邏輯運算子使用兩個字元符號。
Chapter 3: Controlling Program Flow 147
位元運算子也可以和= 併用，使運算動作和賦值動作畢其功於一役：&=、
|=、^= 都是合法的。至於~，由於是一元運算子，無法與= 合併使用。
Boolean 值被視為單一位元，所以情況有點不同。你可以在其身上執行
AND、OR、XOR 位元運算，但不能執行NOT 運算(大概是為了避免與邏
輯運算NOT 混淆)。對boolean 而言，位元運算子除了不做short
circuit(遽死式、短路式評估)外，和邏輯運算子是相同的。此外，可作
用於boolean 身上的位元運算，還包括不含於邏輯運算子中的XOR 運
算。最後一點，boolean 值無法用於位移運算(稍後即將說明)。
位移運算子(Shift operators)
位移運算子也用來操作位元，但僅用於基本整數型別身上。左移運算子
(<<)會將左運算元向左搬移，搬移的位元個數由右運算元指定(左移
後，較低位元會被自動補0)。帶正負號(signed)的右移運算子(>>)
則將左運算元向右搬移，搬移的位元個數由右運算元指定。面對帶正負號
的數值，右移動作會採用符號擴展(sign extension)措施：如果原值是正
數，較高位元便補上0；如果原值是負數，較高位元便補上1。此外Java
還增加了無正負號的右移運算子>>> ， 採用所謂的零擴展( zero
extension)：不論原值是正或負，一律在較高位元處補0。「無正負號右
移運算子」在C 和C++中並不存在。
如果你所操作的位移對象是char、byte、short，位移動作發生之前，其
值會先被晉升成int，運算結果會是int。運算子右端所指定的位移個數，
僅有較低的5 個位元有用。這樣可以避免你移動超過int 所具備的位元數
(譯註：2 的5 次方是32，而Java 的int 正是32 位元)。如果你所操作
的對象是long，運算結果也會是long，而你所指定的位移個數僅有較低
的6 個位元有用(譯註：因為long 是64 位元)，這能夠避免你移動的位
元數超過long 所具備的位元數。
位移運算也能和等號合併使用(<<= 或>>= 或>>>=)。新的左值會是原
左值位移了「右值所指定的位元數」後的結果。不過，當「無正負號右移
動作」配合「賦值動作」使用時，會有問題：在byte 或short 身上無法
148 Thinking in Java www.BruceEckel.com
得到正確結果。是的，它們會被先晉升為int，然後進行右移；但是當它們
被賦值回去時，其值又會被截去(譯註：超過容量大小的較高位元會被截
去)。這種情況下會得到-1。下例即說明這個問題：
//: c03:URShift.java
// Test of unsigned right shift.
public class URShift {
public static void main(String[] args) {
int i = -1;
i >>>= 10;
System.out.println(i);
long l = -1;
l >>>= 10;
System.out.println(l);
short s = -1;
s >>>= 10;
System.out.println(s);
byte b = -1;
b >>>= 10;
System.out.println(b);
b = -1;
System.out.println(b>>>10);
}
} ///:~
最末一行的結果並未被指派回b，而被直接印出，所以產生正確的行為。
下面這個範例展示所有和位元運算有關的運算子：
//: c03:BitManipulation.java
// Using the bitwise operators.
import java.util.*;
public class BitManipulation {
public static void main(String[] args) {
Random rand = new Random();
int i = rand.nextInt();
int j = rand.nextInt();
pBinInt("-1", -1);
pBinInt("+1", +1);
Chapter 3: Controlling Program Flow 149
int maxpos = 2147483647;
pBinInt("maxpos", maxpos);
int maxneg = -2147483648;
pBinInt("maxneg", maxneg);
pBinInt("i", i);
pBinInt("~i", ~i);
pBinInt("-i", -i);
pBinInt("j", j);
pBinInt("i & j", i & j);
pBinInt("i | j", i | j);
pBinInt("i ^ j", i ^ j);
pBinInt("i << 5", i << 5);
pBinInt("i >> 5", i >> 5);
pBinInt("(~i) >> 5", (~i) >> 5);
pBinInt("i >>> 5", i >>> 5);
pBinInt("(~i) >>> 5", (~i) >>> 5);
long l = rand.nextLong();
long m = rand.nextLong();
pBinLong("-1L", -1L);
pBinLong("+1L", +1L);
long ll = 9223372036854775807L;
pBinLong("maxpos", ll);
long lln = -9223372036854775808L;
pBinLong("maxneg", lln);
pBinLong("l", l);
pBinLong("~l", ~l);
pBinLong("-l", -l);
pBinLong("m", m);
pBinLong("l & m", l & m);
pBinLong("l | m", l | m);
pBinLong("l ^ m", l ^ m);
pBinLong("l << 5", l << 5);
pBinLong("l >> 5", l >> 5);
pBinLong("(~l) >> 5", (~l) >> 5);
pBinLong("l >>> 5", l >>> 5);
pBinLong("(~l) >>> 5", (~l) >>> 5);
}
static void pBinInt(String s, int i) {
System.out.println(
s + ", int: " + i + ", binary: ");
150 Thinking in Java www.BruceEckel.com
System.out.print(" ");
for(int j = 31; j >=0; j--)
if(((1 << j) & i) != 0)
System.out.print("1");
else
System.out.print("0");
System.out.println();
}
static void pBinLong(String s, long l) {
System.out.println(
s + ", long: " + l + ", binary: ");
System.out.print(" ");
for(int i = 63; i >=0; i--)
if(((1L << i) & l) != 0)
System.out.print("1");
else
System.out.print("0");
System.out.println();
}
} ///:~
最末尾的兩個函式pBinInt() 和pBinLong()分別接受單一int 或long
做為引數，並以二進位格式搭配說明字串印出。此刻你可以先忽略其實作
細節。
請注意，這裡使用System.out.print() 替代System.out.println()。
print() 並不自動換行，所以我們可以分次輸出單行中的內容。
除了說明位元運算子在int 和long 身上的效果，本例也顯示出int 和
long 的最大值、最小值、+1 實值、-1 實值，讓你清楚看到它們的長相。
請注意，最高位元代表正負號：0 代表正值(譯註：包括零)，1 代表負
值。例中關於int 的部份，輸出結果像這樣：
-1, int: -1, binary:
11111111111111111111111111111111
+1, int: 1, binary:
00000000000000000000000000000001
maxpos, int: 2147483647, binary:
01111111111111111111111111111111
maxneg, int: -2147483648, binary:
Chapter 3: Controlling Program Flow 151
10000000000000000000000000000000
i, int: 59081716, binary:
00000011100001011000001111110100
~i, int: -59081717, binary:
11111100011110100111110000001011
-i, int: -59081716, binary:
11111100011110100111110000001100
j, int: 198850956, binary:
00001011110110100011100110001100
i & j, int: 58720644, binary:
00000011100000000000000110000100
i | j, int: 199212028, binary:
00001011110111111011101111111100
i ^ j, int: 140491384, binary:
00001000010111111011101001111000
i << 5, int: 1890614912, binary:
01110000101100000111111010000000
i >> 5, int: 1846303, binary:
00000000000111000010110000011111
(~i) >> 5, int: -1846304, binary:
11111111111000111101001111100000
i >>> 5, int: 1846303, binary:
00000000000111000010110000011111
(~i) >>> 5, int: 132371424, binary:
00000111111000111101001111100000
數字的二進位表現法是以「帶正負號的二補數( signed two’s
complement)」為之。
if-else 三元運算子(Ternary if-else operator)
這個運算子比較不尋常，因為它有三個運算元。由於它會導出一個值，所
以它是個如假包換的運算子，和一般的if-else 述句(下一節介紹)不一
樣。其算式格式如下：
boolean-exp ? value0 : value1
如果上述的boolean-exp 評估為true，接下來便評估value0 的值，而其
評估結果便成為這個運算子的結果。如果boolean-exp 評估為false，接下
152 Thinking in Java www.BruceEckel.com
來便評估value1 的值，而其評估結果便成為這個運算子的結果。
當然，你也可以使用一般的if-else 述句(稍後提及)，但三元運算子更顯
精練。雖然C(三元運算子的濫觴)向來以作為一個精練的語言自豪，而
三元運算子也在某種程度上因效率而被採用，但是你仍然應該在使用時有
所警惕- 是的，它很容易形成不易閱讀的程式碼。
這種所謂條件運算子(conditional operator)的使用目的，也許是為了其
副作用，也許是為了其運算結果值。一般而言你要的是它的運算結果值，
這也正是這個運算子異於if-else 之處。以下便是一例：
static int ternary(int i) {
return i < 10 ? i * 100 : i * 10;
}
看得出來，上述程式碼如果不使用三元運算子，不會如此簡潔：
static int alternative(int i) {
if (i < 10)
return i * 100;
else
return i * 10;
}
第二種寫法比較容易理解，也不用輸入太多內容。所以，請確定自己在選
擇三元運算子時，事先經過周詳考慮。
逗號運算子(comma operator)
C 和C++語言中的逗號，不僅做為函式引數列的分隔字元，也做為「循序
評估動作」中的運算子。在Java 語言中，唯一可以放置逗號運算子的地
方，就是for 迴圈(稍後介紹)。
Chapter 3: Controlling Program Flow 153
應用於String 身上的operator+
在Java 中，有個運算子提供了很特別的用法：之前你見過的+ 運算子能
夠用於字串連接。雖然這種用法不符合傳統，看起來卻頗為自然。在C++
中，這樣的功能似乎是個不錯的想法，所以「運算子多載化(operator
overloading)」功能被加至C++中，允許C++程式員為幾乎任何運算子
賦予新的意義。不幸的是，運算子多載功能(以及C++的其他規定)，對
程式員而言成了一項繁重的負擔。雖然在Java 中實作「運算子多載化」比
起C++ 來說應該能夠更簡單，但這個功能依舊被認為過度複雜，所以Java
不允許程式員實作他們自有的多載化運算子。
String + 的運用有一些很有趣的行為。如果某個算式以String 為首，那
麼接續的所有運算元也都必須是Strings(別忘了，編譯器會將雙引號括
住的字元序列自動轉化為String)：
int x = 0, y = 1, z = 2;
String sString = "x, y, z ";
System.out.println(sString + x + y + z);
在這裡，Java 編譯器會將x、y、z 轉化為它們各自的String 表示式，而
不是先將它們加在一起。如果你這麼寫：
System.out.println(x + sString);
Java 會將x 轉換為String。
使用運算子時的常犯錯誤
使用運算子時，一個常犯的錯誤便是，雖然你對運算式的評估方式有點不
確定，卻不願意使用小括號來幫助自己。這句話在Java 之中仍然成立。
在C 和C++中一個極常見的錯誤如下：
while(x = y) {
// ....
}
154 Thinking in Java www.BruceEckel.com
程式員想做的其實是相等測試(==)而非賦值動作，卻打錯了字。在C 和
C++ 中，如果y 值非零，那麼此一賦值動作的結果肯定為true，你因此陷
入一個無窮迴圈。在Java 中，此一算式的結果並不是boolean，但編譯
器預期此處應該是個boolean，並且不希望由int 轉換過來。因此編譯器
會給你適當的錯誤訊息，在你嘗試執行程式之前捕捉到這個問題。所以這
樣的陷阱不會出現在Java 中。如果x 和y 都是boolean，你不會獲得編
譯錯誤訊息，因為x = y 是合法算式，但這卻不是你所想像的情況。
C 和C++ 還有一個類似問題：容易將位元運算子AND 和OR 誤為對應的
邏輯運算子。位元運算子AND 和OR 採用的符號是單一字元(& 或|)，
邏輯運算子AND 和OR 則採用雙字元符號(&& 或||)。這種情況很像
= 和==，很容易因為疏忽而只鍵入一個符號。Java 編譯器也會杜絕此一問
題，它不讓你的漫不經心破壞編程大計。
轉型運算子(Casting operators)
cast 這個字源於"casting into a mold"(鑄入一個模子內)。Java 能夠在適
當時機自動將資料從某個型別改變為另一個型別。舉例來說，如果你將整
數值指派給浮點變數，編譯器便會自動將int 轉換為float。不過，轉型
(casting)讓你可以更明確地進行這類型別轉換，或者讓你在原本不會自
然發生的場合，強迫它發生。
欲執行轉型動作，請將標的型別(包括所有飾詞)置於任意數值的左方括
號內。以下便是一例：
void casts() {
int i = 200;
long l = (long)i;
long l2 = (long)200;
}
如你所見，將數值轉型，就和將變數轉型一樣，是可能的。上述例子同時
展現出兩種轉型方式。這樣的轉型其實是多餘的，因為編譯器會在必要時
候自動將int 晉升(promote)為long。不過，為了表明某種觀點，或是
Chapter 3: Controlling Program Flow 155
為了讓程式碼更明瞭易讀，這類非必要的轉型是允許的。至於其他情況，
有可能必須先完成轉型動作才可以順利通過編譯。
在C 和C++ 中，轉型可能引發其他麻煩事兒。Java 中的轉型是安全的，
只有當執行所謂窄化轉換(narrowing conversion)(也就是說當你將某
個存有較多資訊的資料型別轉換為無法儲存那麼多資訊的另一個型別時)
才有風險- 彼時你得冒著資訊遺失的風險。這種情形下編譯器會強迫你進
行轉型。實際上它會說：『這麼做可能是危險的。如果你希望我放手一
搏，你得明確給我指示』。進行寬化轉換(widening conversion)時就無
需明確指示，因為新型別能夠容納來自舊型別的資訊，不會遺失任何資
訊。
Java 允許你將任意基本型別轉型為另一個任意基本型別。然而boolean
例外，它完全不接受任何轉型動作。class 型別不允許轉型。想要將某個
class 型別轉換為另一個class 型別，得有特殊方法才辦得到。String 是個
特例。本書稍後你還會看到，同一classes 族系的物件之間可以轉型。是
的，Oak(橡樹)可被轉為Tree(樹木)，反之亦然。但我們無法將它轉
為族系以外的型別，例如Rock(石頭)。
字面常數(Literals)
一般而言，當你將某個常數值置於程式中，編譯器很清楚知道要將它製成
什麼型別。但有時候難免模稜兩可。一旦發生這種情形，你得提供某些額
外資訊：透過「為常數值搭配某些字元」的形式，引導編譯器做出正確的
判斷。以下程式碼展示這種情況下的搭配字元：
//: c03:Literals.java
class Literals {
char c = 0xffff; // max char hex value
byte b = 0x7f; // max byte hex value
short s = 0x7fff; // max short hex value
int i1 = 0x2f; // Hexadecimal (lowercase)
int i2 = 0X2F; // Hexadecimal (uppercase)
int i3 = 0177; // Octal (leading zero)
// Hex and Oct also work with long.
156 Thinking in Java www.BruceEckel.com
long n1 = 200L; // long suffix
long n2 = 200l; // long suffix
long n3 = 200;
//! long l6(200); // not allowed
float f1 = 1;
float f2 = 1F; // float suffix
float f3 = 1f; // float suffix
float f4 = 1e-45f; // 10 to the power
float f5 = 1e+9f; // float suffix
double d1 = 1d; // double suffix
double d2 = 1D; // double suffix
double d3 = 47e47d; // 10 to the power
} ///:~
十六進制(以16 為基底)能夠應用於所有整數資料型別，其表示法係以
0x 或0X 為首，後接0-9 或a-f(大小寫皆可)。如果你嘗試將某變數的
初值設成比該變數所能儲存的最大值還大的話(不論是以八進制、十進制
或十六進制)，編譯器會給你錯誤訊息。請注意上述程式碼中char、
byte、short 的最大可能十六進制值。如果超過這些值，編譯器會自動將
該值視為int ， 並告訴你此一賦值動作需要窄化轉換( narrowing
conversion)。這時候你就知道自己越界了。
八進制(以8 為基底)係以0 為首，每一位數皆落在0-7 中。C、C++、
Java 都沒有提供二進制的數字常數表示法。
常數值之後添增的字元係用來表明數值的型別。大寫或小寫的L 意指
long，大寫或小寫的F 意指float，大寫或小寫的D 意指double。
指數(exponents)採用的是一種向來讓我感到驚恐的表示法：1.39e-
47f。在科學和工程領域中，’e’ 所代表的是自然對數的基底，近似於2.718
(Java 裡頭有個更精確的double 值是Math.E)，它被用於像1.39 x
e–47 這樣的指數表示式，意指1.39 x 2.718–47。但是FORTRAN 發明之際，
那些人決定讓e 代表「10 的次方」。這是個相當怪異的決定，因為
FORTRAN 乃是被設計用於科學和工程領域，而任何人都可能認為，
Chapter 3: Controlling Program Flow 157
FORTRAN 的設計者在引入這樣的歧義1 時，必然經過審慎的思考。無論如
何，這個慣例被C、C++、Java 採用了。所以如果你習慣將e 思考為自然
對數基底，那麼當你在Java 中看到諸如1.39e-47f 這樣的表示式時，你得
在心中默默提醒自己：它指的其實是1.39 x 10 –47。
請注意，如果編譯器能夠找出適當的型別，你就不需要在數值之後附加字
元，那將是一種非必要的補充。以下寫法並不會造成含糊不清的狀況：
long n3 = 200;
所以200 之後的L 便顯多餘。但如果寫成這樣：
float f4 = 1e-47f; // 10 to the power
編譯器會順理成章地將指數視為doubles。所以，由於少了附加字元f，
編譯器會給你錯誤訊息，讓你知道，你得透過轉型動作，將double 轉換
為float。
晉升(Promotion)
你會發現，當你在比int 更小的基本型別(亦即char、byte、short)上
進行任何數學運算或位元運算時，運算之前其值會先被晉升為int，最後所
得結果也會是int 型別。因此如果你想要將結果指派給較小型別，就得進
行轉型動作。而且由於指派的目的地是較小型別，有可能遺失資訊。一般
來說，算式內出現的最大資料型別，是決定該算式運算結果的容量大小的
1 John Kirkham 是這麼寫的：『我於1962 年首次在IBM 1620 電腦上以FORTRAN II 進行
計算。1760-1970 年代，FORTAN 是個全面使用大寫字母的語言。這或許是因為早期許多
輸入設備都是使用5 bit Baudot code 的舊式電報裝置，此類裝置沒有小寫功能。指數表示
式中的’E’ 也絕對是大寫，從未和必為小寫的自然對數基底’e’ 混淆過。’E’ 僅僅只是代表指
數(exponential)，代表所使用的數值系統的基底- 通常是10。當時八進位亦被程式員廣
泛使用，雖然我未曾見過，但如果當時我曾經見過指數表示式中以八進位數字來表達的話，
我會考慮讓它以8 為基底。我首次看到使用小寫’e’ 的指數表示式，是在1970 年代末期，
我也認為這會產生混淆。問題發生在「小寫字母逐漸進入FORTRAN」之際，而非發生在
FORTRAN 一開始發展之時。如果你真想以自然對數做為基底，我們另外提供了函式，不
過它們也全都是大寫名稱。』
158 Thinking in Java www.BruceEckel.com
依據之一；如果你讓float 和double 相乘，結果便是double；如果你讓
int 和long 相加，結果便是long。
Java 沒有“sizeof” 運算子
C 和C++ 的sizeof() 運算子滿足了一個特定需求：它讓你知道，編譯器究
竟為某一筆資料配置了多少個bytes。sizeof() 在C 和C++ 中的存在必要
性，最令人信服的理由便是為了可攜性。不同的資料型別在不同的機器上
可能會有著不同的大小，所以執行「和容量大小有高度相關」的運算時，
程式員必須知道這些型別的容量究竟有多大。例如某部電腦可能以32 bits
來儲存整數值，另一部電腦卻可能以16 bits 來儲存整數值；程式在第一部
機器上能夠以整數儲存較大的值。就如你所能想像的，可攜性對C 和C++
程式員來說，是個棘手的問題。
Java 不需要為了這個原因而提供sizeof() 運算子。因為在所有機器上，每
一種資料型別都有著相同的容量大小。在這個層次上，你完全不需要思考
可攜性的問題- 它已被設計於語言之中。
再探優先序(precedence)
在我的某個研討班上，當我抱怨運算子優先序過於複雜而難以記憶之後，
有位學生向我推薦一種助憶法，這個口訣像是一句評語：Ulcer Addicts
Really Like C A lot(胃潰瘍患者是C 程式員的寫照)。
助憶口訣運算子類型運算子
Ulcer Unary + - ++--
Addicts Arithmetic (以及shift) * / % + - << >>
Really Relational > < >= <= == !=
Like Logical (以及bitwise) && || & | ^
C Conditional (三元) A > B ? X : Y
A Lot Assignment = (以及複合指派動作如*=)
當然，讓「位移運算子」和「位元運算子」散落於表格四處，並不是一種
完美的助憶法，但對於非位元運算來說，沒有問題。
Chapter 3: Controlling Program Flow 159
運算子綜合說明
以下範例說明哪些基本型別能被施行哪些特定運算子。基本上這是一個一
再重覆的程式，只不過每次運用不同的基本型別。此程式能夠順利通過編
譯，沒有任何錯誤訊息，因為，可能導致錯誤的每一行程式都被我以//!
化為註解了。
//: c03:AllOps.java
// Tests all the operators on all the
// primitive data types to show which
// ones are accepted by the Java compiler.
class AllOps {
// To accept the results of a boolean test:
void f(boolean b) {}
void boolTest(boolean x, boolean y) {
// Arithmetic operators:
//! x = x * y;
//! x = x / y;
//! x = x % y;
//! x = x + y;
//! x = x - y;
//! x++;
//! x--;
//! x = +y;
//! x = -y;
// Relational and logical:
//! f(x > y);
//! f(x >= y);
//! f(x < y);
//! f(x <= y);
f(x == y);
f(x != y);
f(!y);
x = x && y;
x = x || y;
// Bitwise operators:
//! x = ~y;
x = x & y;
x = x | y;
160 Thinking in Java www.BruceEckel.com
x = x ^ y;
//! x = x << 1;
//! x = x >> 1;
//! x = x >>> 1;
// Compound assignment:
//! x += y;
//! x -= y;
//! x *= y;
//! x /= y;
//! x %= y;
//! x <<= 1;
//! x >>= 1;
//! x >>>= 1;
x &= y;
x ^= y;
x |= y;
// Casting:
//! char c = (char)x;
//! byte B = (byte)x;
//! short s = (short)x;
//! int i = (int)x;
//! long l = (long)x;
//! float f = (float)x;
//! double d = (double)x;
}
void charTest(char x, char y) {
// Arithmetic operators:
x = (char)(x * y);
x = (char)(x / y);
x = (char)(x % y);
x = (char)(x + y);
x = (char)(x - y);
x++;
x--;
x = (char)+y;
x = (char)-y;
// Relational and logical:
f(x > y);
f(x >= y);
f(x < y);
f(x <= y);
Chapter 3: Controlling Program Flow 161
f(x == y);
f(x != y);
//! f(!x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
x= (char)~y;
x = (char)(x & y);
x = (char)(x | y);
x = (char)(x ^ y);
x = (char)(x << 1);
x = (char)(x >> 1);
x = (char)(x >>> 1);
// Compound assignment:
x += y;
x -= y;
x *= y;
x /= y;
x %= y;
x <<= 1;
x >>= 1;
x >>>= 1;
x &= y;
x ^= y;
x |= y;
// Casting:
//! boolean b = (boolean)x;
byte B = (byte)x;
short s = (short)x;
int i = (int)x;
long l = (long)x;
float f = (float)x;
double d = (double)x;
}
void byteTest(byte x, byte y) {
// Arithmetic operators:
x = (byte)(x* y);
x = (byte)(x / y);
x = (byte)(x % y);
x = (byte)(x + y);
x = (byte)(x - y);
162 Thinking in Java www.BruceEckel.com
x++;
x--;
x = (byte)+ y;
x = (byte)- y;
// Relational and logical:
f(x > y);
f(x >= y);
f(x < y);
f(x <= y);
f(x == y);
f(x != y);
//! f(!x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
x = (byte)~y;
x = (byte)(x & y);
x = (byte)(x | y);
x = (byte)(x ^ y);
x = (byte)(x << 1);
x = (byte)(x >> 1);
x = (byte)(x >>> 1);
// Compound assignment:
x += y;
x -= y;
x *= y;
x /= y;
x %= y;
x <<= 1;
x >>= 1;
x >>>= 1;
x &= y;
x ^= y;
x |= y;
// Casting:
//! boolean b = (boolean)x;
char c = (char)x;
short s = (short)x;
int i = (int)x;
long l = (long)x;
float f = (float)x;
Chapter 3: Controlling Program Flow 163
double d = (double)x;
}
void shortTest(short x, short y) {
// Arithmetic operators:
x = (short)(x * y);
x = (short)(x / y);
x = (short)(x % y);
x = (short)(x + y);
x = (short)(x - y);
x++;
x--;
x = (short)+y;
x = (short)-y;
// Relational and logical:
f(x > y);
f(x >= y);
f(x < y);
f(x <= y);
f(x == y);
f(x != y);
//! f(!x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
x = (short)~y;
x = (short)(x & y);
x = (short)(x | y);
x = (short)(x ^ y);
x = (short)(x << 1);
x = (short)(x >> 1);
x = (short)(x >>> 1);
// Compound assignment:
x += y;
x -= y;
x *= y;
x /= y;
x %= y;
x <<= 1;
x >>= 1;
x >>>= 1;
x &= y;
164 Thinking in Java www.BruceEckel.com
x ^= y;
x |= y;
// Casting:
//! boolean b = (boolean)x;
char c = (char)x;
byte B = (byte)x;
int i = (int)x;
long l = (long)x;
float f = (float)x;
double d = (double)x;
}
void intTest(int x, int y) {
// Arithmetic operators:
x = x * y;
x = x / y;
x = x % y;
x = x + y;
x = x - y;
x++;
x--;
x = +y;
x = -y;
// Relational and logical:
f(x > y);
f(x >= y);
f(x < y);
f(x <= y);
f(x == y);
f(x != y);
//! f(!x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
x = ~y;
x = x & y;
x = x | y;
x = x ^ y;
x = x << 1;
x = x >> 1;
x = x >>> 1;
// Compound assignment:
Chapter 3: Controlling Program Flow 165
x += y;
x -= y;
x *= y;
x /= y;
x %= y;
x <<= 1;
x >>= 1;
x >>>= 1;
x &= y;
x ^= y;
x |= y;
// Casting:
//! boolean b = (boolean)x;
char c = (char)x;
byte B = (byte)x;
short s = (short)x;
long l = (long)x;
float f = (float)x;
double d = (double)x;
}
void longTest(long x, long y) {
// Arithmetic operators:
x = x * y;
x = x / y;
x = x % y;
x = x + y;
x = x - y;
x++;
x--;
x = +y;
x = -y;
// Relational and logical:
f(x > y);
f(x >= y);
f(x < y);
f(x <= y);
f(x == y);
f(x != y);
//! f(!x);
//! f(x && y);
//! f(x || y);
166 Thinking in Java www.BruceEckel.com
// Bitwise operators:
x = ~y;
x = x & y;
x = x | y;
x = x ^ y;
x = x << 1;
x = x >> 1;
x = x >>> 1;
// Compound assignment:
x += y;
x -= y;
x *= y;
x /= y;
x %= y;
x <<= 1;
x >>= 1;
x >>>= 1;
x &= y;
x ^= y;
x |= y;
// Casting:
//! boolean b = (boolean)x;
char c = (char)x;
byte B = (byte)x;
short s = (short)x;
int i = (int)x;
float f = (float)x;
double d = (double)x;
}
void floatTest(float x, float y) {
// Arithmetic operators:
x = x * y;
x = x / y;
x = x % y;
x = x + y;
x = x - y;
x++;
x--;
x = +y;
x = -y;
// Relational and logical:
Chapter 3: Controlling Program Flow 167
f(x > y);
f(x >= y);
f(x < y);
f(x <= y);
f(x == y);
f(x != y);
//! f(!x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
//! x = ~y;
//! x = x & y;
//! x = x | y;
//! x = x ^ y;
//! x = x << 1;
//! x = x >> 1;
//! x = x >>> 1;
// Compound assignment:
x += y;
x -= y;
x *= y;
x /= y;
x %= y;
//! x <<= 1;
//! x >>= 1;
//! x >>>= 1;
//! x &= y;
//! x ^= y;
//! x |= y;
// Casting:
//! boolean b = (boolean)x;
char c = (char)x;
byte B = (byte)x;
short s = (short)x;
int i = (int)x;
long l = (long)x;
double d = (double)x;
}
void doubleTest(double x, double y) {
// Arithmetic operators:
x = x * y;
168 Thinking in Java www.BruceEckel.com
x = x / y;
x = x % y;
x = x + y;
x = x - y;
x++;
x--;
x = +y;
x = -y;
// Relational and logical:
f(x > y);
f(x >= y);
f(x < y);
f(x <= y);
f(x == y);
f(x != y);
//! f(!x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
//! x = ~y;
//! x = x & y;
//! x = x | y;
//! x = x ^ y;
//! x = x << 1;
//! x = x >> 1;
//! x = x >>> 1;
// Compound assignment:
x += y;
x -= y;
x *= y;
x /= y;
x %= y;
//! x <<= 1;
//! x >>= 1;
//! x >>>= 1;
//! x &= y;
//! x ^= y;
//! x |= y;
// Casting:
//! boolean b = (boolean)x;
char c = (char)x;
Chapter 3: Controlling Program Flow 169
byte B = (byte)x;
short s = (short)x;
int i = (int)x;
long l = (long)x;
float f = (float)x;
}
} ///:~
請注意，能夠在boolean 身上進行的動作極為有限。你可以賦予其值為
true 或false，也可以檢驗其值是否為真，但你無法將兩個booleans 相
加，或在它們身上執行其他形式的運算。
在char、byte、short 身上，你可以看到施行算術運算子時所發生的晉
升(promotion)效應。施行於這些型別身上的任何算術運算，皆回傳
int，因而必須明確將它轉回原先型別。操作int 時，弗需動用轉型，因為
每個運算元都已經是int。但千萬別因此鬆懈，進而以為每件事情都安全牢
靠。如果你將兩個夠大的ints 相乘，結果便會溢位(overflow)。以下程
式碼展現了這一點：
//: c03:Overflow.java
// Surprise! Java lets you overflow.
public class Overflow {
public static void main(String[] args) {
int big = 0x7fffffff; // max int value
prt("big = " + big);
int bigger = big * 4;
prt("bigger = " + bigger);
}
static void prt(String s) {
System.out.println(s);
}
} ///:~
輸出結果是：
big = 2147483647
bigger = -4
170 Thinking in Java www.BruceEckel.com
而且你不會在編譯期得到任何錯誤訊息或警告訊息，也不會在執行期得到
任何異常(exception)。Java 是很好沒錯，但沒那麼好。
char、byte、short 的複合賦值運算(compound assignments)不需要
轉型，雖然，它們都進行了晉升動作並與直接(非複合)運算有相同的結
果。從另一個角度看，少了轉型動作，可以簡化程式碼。
你也看到了，除了boolean 之外，所有基本型別都可以被轉型為其它任意
基本型別。此外，你必須清楚轉型至較小型別時所發生的窄化效應，否則
資訊也許會在轉型過程中被你不知不覺地遺失掉。
流程控制
Java 採納C 語言的所有流程控制述句。所以如果你曾經有過C 或C++ 編
程經驗，此刻你所見到的幾乎都是你已經熟悉的語法。許多程序式
(procedural)語言都具備某些類型的控制述句，它們在許多語言之間常
有重疊。Java 的相應關鍵字包括了if-else、while、do-while、for、
switch-case。Java 並未提供goto - 一個被過度中傷的東西(在解決某
些類型的問題上，它仍然是最權宜的方式)。你還是可以在Java 程式中進
行類似goto 的跳躍行為，但比起典型的goto 來說，受限很多。
true 和false
所有條件述句都使用某個條件算式的運算結果(真偽值)來決定程式的執
行路徑。條件算式就像A == B 這樣。這個例子利用條件運算子== 來檢驗
A 值是否等於B 值，並回傳true 或false。本章稍早出現的所有關係運算
子，都可被用來產生條件述句。請注意，雖然C 和C++ 允許使用數字做為
boolean(它們視非零值為真，零值為偽)，Java 卻不允許這麼做。如果
你想在boolean 測試中使用non-boolean 值，例如if(a)，你得先以條
件算式將它轉換為boolean 值，例如if(a != 0)。
Chapter 3: Controlling Program Flow 171
if-else
if-else 述句或許是控制程式流程的眾多方法中最基本的一個。else 子句可
有可無，所以你可以採取兩種形式來使用if：
if(Boolean-expression)
statement
或是：
if(Boolean-expression)
statement
else
statement
其中的條件句必須得出boolean 結果。statement 意指單述句(以分號做
結尾)或複合述句(以成對大括號括住的一組單述句)。任何時候當我使
用statement 這個字，我的意思便是指單述句或複合述句。
以下的test() 用來示範if-else 的運用。它能夠告訴你你所猜的數字究竟
大於、小於、或等於謎底：
//: c03:IfElse.java
public class IfElse {
static int test(int testval, int target) {
int result = 0;
if(testval > target)
result = +1;
else if(testval < target)
result = -1;
else
result = 0; // Match
return result;
}
public static void main(String[] args) {
System.out.println(test(10, 5));
System.out.println(test(5, 10));
System.out.println(test(5, 5));
}
} ///:~
172 Thinking in Java www.BruceEckel.com
習慣上我們會將流程控制式中的statement 加以縮排，這麼一來讀者更能
夠輕易判斷其啟始處和終止處。
return
關鍵字return 有兩個用途：指明某個函式即將傳回之值(如果回傳型別
不為void 的話)，並令該值立即被傳回。我們可將上例中的test() 重新
改寫以發揮此一優點：
//: c03:IfElse2.java
public class IfElse2 {
static int test(int testval, int target) {
int result = 0;
if(testval > target)
return +1;
else if(testval < target)
return -1;
else
return 0; // Match
}
public static void main(String[] args) {
System.out.println(test(10, 5));
System.out.println(test(5, 10));
System.out.println(test(5, 5));
}
} ///:~
現在我們不需要變數result 了，因為test() 在執行return 之後不再繼續執行。
迭代(iteration)
while、do-while、for 三組關鍵字用來控制迴圈(loop)，它們有時被
歸類為迭代述句(iteration statements)。statement 會反覆執行，直到控
制用的Boolean-expression 被評估為false 才停止。while 迴圈形式是：
while(Boolean-expression)
statement
Boolean-expression 在迴圈開始時會被評估一次，並且在每次執行完
statement 後，再評估一次。
Chapter 3: Controlling Program Flow 173
以下是個簡單範例，持續產生亂數，直到特定條件滿足為止：
//: c03:WhileTest.java
// Demonstrates the while loop.
public class WhileTest {
public static void main(String[] args) {
double r = 0;
while(r < 0.99d) {
r = Math.random();
System.out.println(r);
}
}
} ///:~
這個例子使用Math 程式庫中的static random()，產生介於0 與1 之間
的double 值(包含0 但不包含1)。while 的條件算式所陳述的是「持
續執行迴圈，直到此數字為0.99 或更大」。每當你執行此一程式，你都會
得到一連串個數不盡相同的數字。
do-while
do-while 的形式是：
do
statement
while(Boolean-expression);
while 和do-while 之間的唯一差別在於：do-while 中的述句至少執行
一次，即使算式一開始就被評估為false。但是在while 中，如果條件句
一開始就是false，迴圈內的述句完全不會被執行。實務應用上do-while
遠比while 罕見。
for
for 迴圈在首次迭代前，會先進行初始化動作。然後進行條件測試，並在
每執行完一次迭代，就執行某種形式的「步進(stepping)」動作。for 迴
圈形式如下：
174 Thinking in Java www.BruceEckel.com
for(initialization; Boolean-expression; step)
statement
其中的initialization、Boolean-expression 或step 算式皆可為空。每次迭
代前會檢驗算式值，並在該算式評估為false 後立刻執行緊接於for 述句
之後的下一行程式。每次迭代結束，step 便會被執行。
for 迴圈通常被用於「計數」工作：
//: c03:ListCharacters.java
// Demonstrates "for" loop by listing
// all the ASCII characters.
public class ListCharacters {
public static void main(String[] args) {
for( char c = 0; c < 128; c++)
if (c != 26 ) // ANSI Clear screen
System.out.println(
"value: " + (int)c +
" character: " + c);
}
} ///:~
請注意，變數c 定義於它被使用之處，也就是在for 迴圈的控制算式內，
而不在成對大括號所標記的區段起始處。c 的可見範圍落在由for 所控制
的算式中。
諸如C 之類的傳統程序式(procedural)語言，要求所有變數都必須被定
義於區段起始處。這麼一來編譯器建立區段時，才能夠為這些變數配置空
間。但是在Java 和C++ 中，你可以將變數的宣告式置於整個區段的任意
位置，並在需要用到它們時才加以定義。如此一來編程風格更趨自然，程
式碼更易閱讀。
你可以在for 述句中定義多個變數，但它們的型別必須一致：
for(int i = 0, j = 1;
i < 10 && j != 11;
i++, j++)
/* body of for loop */;
Chapter 3: Controlling Program Flow 175
for 述句中的int 定義式，同時涵蓋了i 和j。只有for 迴圈才擁有「在控
制算式中定義變數」的能力。你無法將這種寫法套用於其它類型的選擇述
句或迭代述句身上。
逗號運算子(comma operator)
本章稍早，我曾提過逗號運算子(不是作為分隔多個變數定義或多個函式
引數的那個所謂逗號分隔器)。這個運算子在Java 中僅有一種用法：用於
for 迴圈的控制算式。是的，在for 迴圈的initialization 和step 兩部份
中，都可以存在多個由逗號分隔的述句，而且這些述句會被依序評估。上
一小段程式碼便使用了這項能力。以下是另一個例子：
//: c03:CommaOperator.java
public class CommaOperator {
public static void main(String[] args) {
for(int i = 1, j = i + 10; i < 5;
i++, j = i * 2) {
System.out.println("i= " + i + " j= " + j);
}
}
} ///:~
輸出結果如下：
i= 1 j= 11
i= 2 j= 4
i= 3 j= 6
i= 4 j= 8
你可以看到，在initialization 和step 兩部份中的述句被依序評估。而且，
initialization 所含的「相同型別」的變數定義，個數不限。
break 和continue
在迭代述句的主體內，你隨時可以使用break 和continue 來控制迴圈流
程。break 會跳出迴圈，不再執行剩餘部份。continue 會停止當次迭
代，回到迴圈起始處，開始下一個迭代過程。
176 Thinking in Java www.BruceEckel.com
下面這個程式示範在for 和while 迴圈中使用break 和continue 的方
式：
//: c03:BreakAndContinue.java
// Demonstrates break and continue keywords.
public class BreakAndContinue {
public static void main(String[] args) {
for(int i = 0; i < 100; i++) {
if(i == 74) break; // Out of for loop
if(i % 9 != 0) continue; // Next iteration
System.out.println(i);
}
int i = 0;
// An "infinite loop":
while(true) {
i++;
int j = i * 27;
if(j == 1269) break; // Out of loop
if(i % 10 != 0) continue; // Top of loop
System.out.println(i);
}
}
} ///:~
在for 迴圈中，i 的值永遠不會是100，因為break 述句會在i 值為74 時
中斷迴圈的進行。通常，只有在你不知道終止條件究竟何時發生時，才應
該使用break。每當i 不能被10 整除，continue 述句便會將執行點移至
迴圈最前端(因而將i 累加1)；如果整除，該值便會被印出。
第二部份示範了理論上持續不止的「無窮迴圈(infinite loop)」。不過，
迴圈中有個break 述句，可以中斷迴圈。此外你也會看到continue 將迴
圈的執行點移回頂端，不再完成剩餘部份(因此在第二個迴圈中，只有當i
值被10 整除時，列印動作才會發生)。輸出結果如下：
Chapter 3: Controlling Program Flow 177
0 9
18
27
36
45
54
63
72
10
20
30
40
其中之所以會印出0 值，乃是因為0 % 9 獲得0。
無窮迴圈的第二種形式是for(;;)。編譯器將while(true) 和for(;;) 視為
相同。所以，究竟選用哪一個，是編程品味的問題。
惡名昭彰的“goto”
自從第一個程式語言以來，關鍵字goto 便已存在。的確，組合語言中的
goto 是程式流程控制的濫觴：「如果條件A 成立，就跳到這兒來，否則就
跳到那兒」。如果你讀過隨便哪個編譯器最終產生出來的組合語言碼，你
會發現，在程式流程控制之處，含有許多跳躍動作(jumps)。不過我們
現在所談的goto，卻是原始碼層次上的跳躍，而這正是其惡名昭彰的源
頭。如果程式總是從某一點跳躍至另一點，有什麼方法可以整頓程式碼，
使流程控制不會變得如此變化多端？由於Edsger Dijkstra 發表了一篇著名
論文《Goto considered harmful》，goto 從此陷入萬劫不復的境地。而由
於對goto 的攻訐成為一種普世運動，眾人於是倡言將此關鍵字徹底逐出
語言門牆。
一般來說，在這種情況下，中庸之道永遠是最好的一條路。問題不在於
goto 的使用，而在於goto 的過度使用- 極少數情況下，goto 其實是流
程控制的最佳方法。
178 Thinking in Java www.BruceEckel.com
雖然goto 是Java 保留字，但這個語言並沒有使用它；是的，Java 裡頭沒
有用到goto。不過Java 卻有一些看起來有點像跳躍動作(jump)的功
能，這個功能和關鍵字break 以及關鍵字continue 結合在一起。它們其
實並不是跳躍，而是一種中斷迭代述句的方式。它們之所以被拿來和goto
相提並論，因為它們使用了相同的機制：label(標記)。
所謂label，是個後面緊接冒號的識別字，就像這樣：
label1:
在Java 中，唯一一個「置放label，而能夠產生效益」的地點，就是恰恰
放在迭代述句之前。在label 與迭代內容之間安插任何述句，不會帶來什麼
好處。將label 置於迭代述句之前，完全是為了對付那種「巢狀進入另一個
迭代或switch」的情況。因為，關鍵字break 和continue 一般而言只會
中斷當次迴圈，如果搭配label 使用，它們會中斷所有進行中的巢狀迴圈，
直達label 所在處：
label1:
outer-iteration {
inner-iteration {
//…
break; // 1
//…
continue; // 2
//…
continue label1; // 3
//…
break label1; // 4
}
}
請看上例狀況1，break 會中斷內層迭代，回到外層迭代。狀況2 的
continue 會將執行點移至內層迭代的起始處。狀況3 的continue
label1 會同時中斷內層和外層迭代，直接回到label1，此時迭代動作繼續
進行，但卻從外層迭代(而非內層迭代)重新開始。狀況4 的break
lable1 也是跳脫一切約束，移至label1，但是不會再度進入迭代- 它同
時中斷了內外層迭代。
Chapter 3: Controlling Program Flow 179
以下是label 搭配for 迴圈的使用實例：
//: c03:LabeledFor.java
// Java’s "labeled for" loop.
public class LabeledFor {
public static void main(String[] args) {
int i = 0;
outer: // Can't have statements here
for(; true ;) { // infinite loop
inner: // Can't have statements here
for(; i < 10; i++) {
prt("i = " + i);
if(i == 2) {
prt("continue");
continue;
}
if(i == 3) {
prt("break");
i++; // Otherwise i never
// gets incremented.
break;
}
if(i == 7) {
prt("continue outer");
i++; // Otherwise i never
// gets incremented.
continue outer;
}
if(i == 8) {
prt("break outer");
break outer;
}
for(int k = 0; k < 5; k++) {
if(k == 3) {
prt("continue inner");
continue inner;
}
}
}
}
180 Thinking in Java www.BruceEckel.com
// Can't break or continue
// to labels here
}
static void prt(String s) {
System.out.println(s);
}
} ///:~
這個例子用到了定義於其他例子中的prt()。
請注意，本例之中，break 會跳出for 迴圈；由於沒有經歷一次完整的迭
代，所以迴圈的累進算式(increment expression)不會發生。正因為
break 會略過累進算式，為了彌補，我們在i == 3 的情況下直接將i 加
1。當i == 7 時，continue outer 述句也會跳回迴圈頂端，而且也會略去
累進動作，所以我們也直接在該情況下將i 累加1，以利程式進行。
本例輸出如下：
i = 0
continue inner
i = 1
continue inner
i = 2
continue
i = 3
break
i = 4
continue inner
i = 5
continue inner
i = 6
continue inner
i = 7
continue outer
i = 8
break outer
如果缺少break outer 述句，我們就沒有任何辦法在內層迴圈中直接跳離
外層迴圈，因為break 僅能中斷最內層迴圈(continue 亦然)。
Chapter 3: Controlling Program Flow 181
當然，如果你想在中斷迴圈時一併離開函式，只要使用return 即可。
下面這個例子，示範如何在while 迴圈中將break 述句和continue 述
句搭配label 來使用：
//: c03:LabeledWhile.java
// Java's "labeled while" loop.
public class LabeledWhile {
public static void main(String[] args) {
int i = 0;
outer:
while(true) {
prt("Outer while loop");
while(true) {
i++;
prt("i = " + i);
if(i == 1) {
prt("continue");
continue;
}
if(i == 3) {
prt("continue outer");
continue outer;
}
if(i == 5) {
prt("break");
break;
}
if(i == 7) {
prt("break outer");
break outer;
}
}
}
}
static void prt(String s) {
System.out.println(s);
}
} ///:~
182 Thinking in Java www.BruceEckel.com
對while 而言，規則依舊成立：
1. 一般的continue 會回到最內層迴圈頂端，繼續執行。
2. labeld continue 會跳躍至label 所在處，然後恰在label 之後重新
進入迴圈。
3. 一般的break 會跳離迴圈。
4. labeld break 會跳離label 所描述的迴圈。
上個例子的輸出結果更能清楚說明以上所言：
Outer while loop
i = 1
continue
i = 2
i = 3
continue outer
Outer while loop
i = 4
i = 5
break
Outer while loop
i = 6
i = 7
break outer
請務必記住，在Java 裡頭使用labels，唯一的理由是：在巢狀迴圈中想要
令break 或continue 越過一個以上的巢狀層級(nested level)。
Dijkstra 的論文《goto considered harmful》，反對的其實是labels 而非
goto。他觀察到，程式臭蟲的數目似乎隨著程式中的labels 個數而成長。
labels 和goto 使程式難以被靜態分析，因為它們會將循環(cycles)引入
程式執行圖(execution graph)中。請記住，Java 的labels 不會帶來這種
問題，因為它們能夠擺放的位置有限，此外它們也不能隨意被用來改變執
行流程。這是「藉由侷限某個述句的威力，讓語言的某種性質更為有用」
的一個有趣例子。
Chapter 3: Controlling Program Flow 183
switch
switch 有時候亦被歸類為「選擇述句(selection statement)」。switch
述句會根據某個整數算式的值，在眾多程式碼片段中挑出一段來執行。形
式如下：
switch(integral-selector) {
case integral-value1 : statement; break;
case integral-value2 : statement; break;
case integral-value3 : statement; break;
case integral-value4 : statement; break;
case integral-value5 : statement; break;
// ...
default: statement;
}
其中integral-selector 是個能得出整數值的算式。switch 會拿integralselector
和每個integral-value 逐一比較，如果找到吻合者，就執行相應的
statement(不論是單述句或複合述句)。如果找不到吻合者，就執行
default statement。
你應該注意到了，上述定義中，每個case 皆以break 做為結束，這會使
程式執行點跳至switch 本體的最末端。此為建構switch 述句最常見的形
式，然而break 的存在並非絕對必要。如果少了break，便會執行其後接
續的case 述句，直到遇上break 為止。雖然你通常不會希望這種行為發
生，但對有經驗的程式員來說，這種性質相當有用。請注意，default 之
後的最後一個述句並未加上break，因為即使沒有放上break，程式也是
恰好執行到應該去的地點，所以沒有差別。如果你考慮編程風格的問題，
可以將break 置於default 述句之末，那也無妨。
在多向選擇(multi-way selection，也就是從多個不同的執行路徑中挑選一
個)的實作手法上，switch 述句很是乾淨俐落，但是你得有個「能核定出
整數值(例如int 或char)」的選擇器(selector)才行。如果你想以字
串或浮點數做為選擇器，在switch 述句中是行不通的。面對非整數型
別，你非得使用一連串if 述句不可。
184 Thinking in Java www.BruceEckel.com
下面這個例子會隨機產生字母，並判斷該字母是母音或子音：
//: c03:VowelsAndConsonants.java
// Demonstrates the switch statement.
public class VowelsAndConsonants {
public static void main(String[] args) {
for(int i = 0; i < 100; i++) {
char c = (char)(Math.random() * 26 + 'a');
System.out.print(c + ": ");
switch(c) {
case 'a':
case 'e':
case 'i':
case 'o':
case 'u':
System.out.println("vowel");
break;
case 'y':
case 'w':
System.out.println(
"Sometimes a vowel");
break;
default:
System.out.println("consonant");
}
}
}
} ///:~
由於Math.random() 會產生介於0 和1 之間的值，所以你只要將「所產
生的隨機值」乘以「欲得的範圍上限」(對字母系統而言為26)，再加上
一個偏移量，即可獲得隨機字母。
雖然此例是在字元身上進行選擇，但switch 述句所用的其實是該字元的
整數值。case 述句中以單引號括起來的字元，亦以其整數值進行比較。
Chapter 3: Controlling Program Flow 185
請注意，多個cases 能夠一個個堆疊起來，造成「只要吻合其中任何一個
條件，便都執行相同的程式碼」的效果。運用此技巧時你應該知道，將
break 述句置於特定case 之後是有必要的，否則程式流程便會繼續往下
執行，處理下一個case。
計算細節
以下述句值得細細端詳：
char c = (char)(Math.random() * 26 + 'a');
Main.random() 會得出一個double 值，所以26 會被轉換成double
以利乘法運算，而乘積亦是個double。這同時也意謂為了完成加法，’a’
必須被轉換為double。最後所獲得的double 再被轉為char。
將double 轉為char 的過程中會進行哪些動作呢？如果將29.7 轉型至
char，得到的是30 或是29？此一問題的答案可由下例瞧出端倪：
//: c03:CastingNumbers.java
// What happens when you cast a float
// or double to an integral value?
public class CastingNumbers {
public static void main(String[] args) {
double
above = 0.7,
below = 0.4;
System.out.println("above: " + above);
System.out.println("below: " + below);
System.out.println(
"(int)above: " + (int)above);
System.out.println(
"(int)below: " + (int)below);
System.out.println(
"(char)('a' + above): " +
(char)('a' + above));
System.out.println(
"(char)('a' + below): " +
186 Thinking in Java www.BruceEckel.com
(char)('a' + below));
}
} ///:~
輸出結果是：
above: 0.7
below: 0.4
(int)above: 0
(int)below: 0
(char)('a' + above): a
(char)('a' + below): a
所以，先前的答案是：從float 或double 轉為整數值，總是以完全捨棄
小數(而非四捨五入)的方式進行。
第二個問題和Math.random() 有關。它所產生的介於0 與1 之間的值，
究竟包不包括’1’？以數學行話來說，它究竟是(0,1)、[0,1]、(0,1]、或是
[0,1)？(中括號意指「包含」，小括號意指「不包含」。)寫個測試程式
就知道了：
//: c03:RandomBounds.java
// Does Math.random() produce 0.0 and 1.0?
public class RandomBounds {
static void usage() {
System.out.println("Usage: \n\t" +
"RandomBounds lower\n\t" +
"RandomBounds upper");
System.exit(1);
}
public static void main(String[] args) {
if(args.length != 1) usage();
if(args[0].equals("lower")) {
while(Math.random() != 0.0)
; // Keep trying
System.out.println("Produced 0.0!");
}
else if(args[0].equals("upper")) {
while(Math.random() != 1.0)
; // Keep trying
Chapter 3: Controlling Program Flow 187
System.out.println("Produced 1.0!");
}
else
usage();
}
} ///:~
欲執行此程式，只須在命令列(command line)鍵入以下二者之一即可：
java RandomBounds lower
或
java RandomBounds upper
無論哪一種情況你都得手動中斷程式，這樣看起來，Math.random() 絕
對不會產生0.0 或1.0 兩個值。但這正是這種實驗可能作弊的地方。如果
你能夠想像0 和1 之間共有2 62 種不一樣的double 值2，以上述實驗方式
得到某值，所耗費的時間可能會超過一部電腦甚至一個實驗者的壽命。事
實的真象是，Math.random() 的輸出包括0.0，以數學術語來說，其輸
出範圍是[0,1)。
摘要
本章歸納整理了大多數程式語言皆有的基礎功能：計算、運算子優先序、
型別轉換、流程選擇和迭代。現在，你已經準備好往前踏出一步，使你自
2 Chuck Allison 是這麼說的：在一個浮點數系統中，可表達之數字的個數是：
2(M-m+1)b^(p-1) + 1，其中b 是基底(通常為2)，p 是精確度(假數(mantissa)中
的位數)，M 是指數的最大值，m是指數的最小值。IEEE 754 的規範是：M = 1023, m
= -1022, p = 53, b = 2，所以能夠表現的數字總共有這麼多個：
2(1023+1022+1)2^52
= 2((2^10-1) + (2^10-1))2^52
= (2^10-1)2^54
= 2^64 - 2^54
其中半數(指數值落在[-1022,0]範圍內)的值(包括正數和負數)小於1。所以上述表示式
的1/4，也就是2^62 - 2^52 + 1(接近2^62)落在[0,1)範圍中。請參考我置於
http://www.freshsources.com/1995006a.htm上的論文。
188 Thinking in Java www.BruceEckel.com
己更靠近物件導向程式設計的世界。下一章將涵蓋物件(objects)的初始
化和清理。下下一章則討論實作隱藏(implementation hiding)的核心觀
念。
練習
某些經過挑選的題目，其解答置於《The Thinking in Java Annotated Solution Guide》電子文件中。
僅需小額費用便可自www.BruceEckel.com.網站取得。
1. 本章稍早題為「優先序(precedence)」的那一節中，曾經提到兩
行算式。請將它們放進程式中，證明它們所產生的結果並不相同。
2. 請將ternary() 和alternative() 這兩個函式放進程式中。
3. 請將標題為“if-else” 和“return” 兩小節中的test() 和test2() 函式放
進程式。
4. 撰寫一個程式，令它印出數值1~100。
5. 修改上題，利用關鍵字break，讓程式在印出數值47 時終止。試著
改用return 辦到這一點。
6. 撰寫一個函式，使它接收兩個String 引數，並運用各種Boolean 比
較動作來比較這兩個String，印出比較結果。進行== 和!= 比較
動作的同時，也請執行equals() 測試。請在main() 之中使用不同
的String 物件來呼叫你所撰寫的函式。
7. 撰寫程式，產生25 個int 隨機數。針對每個數值，使用if-thenelse
述句來區分該值究竟大於、小於、等於下一個隨機數。
8. 修改上題，以「while 無限迴圈」包住你所撰寫的程式碼。程式持
續執行，直到你以鍵盤動作(通常是按下Control-C)中斷其執
行。
9. 撰寫一個程式，以兩個巢狀的(nested)for 迴圈，和模數運算子
(%)來偵測質數並列印出來。所謂質數(prime numbers)就是
「除了自身和1 之外，找不到任何數可以整除該數」的整數。
Chapter 3: Controlling Program Flow 189
10. 設計switch 述句，在每個case 中皆列印訊息，並將此switch 置於
迴圈中，藉以測試每個case。先在每個case 之後擺上break，然後
移去breaks，看看兩者有什麼差別。
190 Thinking in Java www.BruceEckel.com
191
4: 初始化和清理
Initialization & Cleanup
隨著電腦逐漸演化，「不安全」的編程手法逐漸成為編程
代價日益高漲的主因。
初始化(initialization)和清理(cleanup)正是眾多安全議題中的兩個。
許多C 程式的錯誤肇因於程式員疏於將變數初始化。尤其當他們使用程式
庫時，如果不知道如何初始化一個程式庫組件(或其他必須被初始化的事
物)，更是如此。「清理」是個比較特殊的問題，因為當某個元素被使用
完畢，你很容易便忘了它的存在，畢竟它再也不會影響你。於是該元素依
舊佔用寶貴的資源，而你可能很快便耗盡所有資源(尤其是記憶體)。
C++ 引入所謂「建構式(constructor)」觀念。建構式是一種特殊的函
式，當物件被產生時，此式會被自動喚起。Java 也採納了建構式的觀念，
並額外提供所謂的垃圾回收器(garbage collector)：當物件不再被使用，
垃圾回收器能自動釋放該物件所佔用的記憶體資源。本章審視了物件初始
化、清理的相關議題，並討論Java 對此二者所提供的支援。
以建構式(constructor)確保
初始化的進行
你可以這麼想：為你所撰寫的每個class 都發展一個initialize()。名稱本
身即有示意效果，表示它應該在物件被使用之前先被喚起。遺憾的是，這
意謂使用者必須自己記得呼叫這個函式。在Java 裡頭，class 的設計者可
以透過「提供某個建構式(constructor)」的行為，確保每個物件的初始
化動作一定會被執行。如果某個class 具備建構式，Java 便會在物件生成
192 Thinking in Java www.BruceEckel.com
之際，使用者有能力加以操作之前，自動呼叫其建構式，於是便能夠確保
初始化動作一定被執行。
接下來令人頭痛的便是建構式的命名問題。這裡存在兩個問題，第一，你
所使用的任何名稱都可能和class 內的成員名稱衝突。第二，建構式由編譯
器負責喚起，所以編譯器必須知道它將呼叫哪一個函式。C++ 的解法似乎
是最簡單也最符合邏輯的，所以也被Java 採用：建構式名稱和class 名稱
相同。對於這種「會在初始化動作進行時被呼叫」的函式而言，這種作法
極為合理。
以下便是一個帶有建構式的簡單class：
//: c04:SimpleConstructor.java
// Demonstration of a simple constructor.
class Rock {
Rock() { // This is the constructor
System.out.println("Creating Rock");
}
}
public class SimpleConstructor {
public static void main(String[] args) {
for(int i = 0; i < 10; i++)
new Rock();
}
} ///:~
現在，當物件生成之際：
new Rock();
編譯器會配置必要的儲存空間，並呼叫其建構式。你可以放心，在你得以
操作此一物件之前，它絕對會被適當地初始化。
請注意，「每個函式的第一個字母以小寫表示」這種編程風格不適用於建
構式身上，因為建構式的名稱必須完全吻合class 名稱。
Chapter 4: Initialization & Cleanup 193
和其它函式一樣，你也可以為建構式提供引數，藉以指定物件的生成方
式。上例可以輕易做點修改，使其建構式接受一個引數：
//: c04:SimpleConstructor2.java
// Constructors can have arguments.
class Rock2 {
Rock2(int i) {
System.out.println(
"Creating Rock number " + i);
}
}
public class SimpleConstructor2 {
public static void main(String[] args) {
for(int i = 0; i < 10; i++)
new Rock2(i);
}
} ///:~
有了建構式引數，你得以為物件的初始化動作提供引數。假設class Tree
擁有一個「接收單一整數」的建構式，此引數被用來表示樹的高度，那麼
你便可以用這種方式來產生Tree 物件：
Tree t = new Tree(12); // 12-foot tree
如果Tree(int) 是唯一建構式，編譯器便不允許你以任何其他方式來產生
Tree 物件。
建構式能夠消除極多問題，並使程式碼更易於閱讀。以前述程式碼片段為
例，你不會看到任何程式碼直接呼叫某個「和class 保持概念獨立」的
initialize()。在Java 之中「定義」和「初始化」是一體的，兩者不可能
彼此脫離而獨立存在。
建構式是一種很獨特的函式，因為它沒有回傳值。這和「回傳值為void」
有極大的差別。回傳void 時，一般函式並不回傳任何東西，但是一般的函
式能夠選擇是否要回傳些什麼東西。建構式則絕對不回傳任何東西，而且
你也沒有任何選擇。如果它有一個回傳值，而且你有權力選擇你自己的回
194 Thinking in Java www.BruceEckel.com
傳型別(return type)，編譯器勢必得透過某種方式來知道如何處理那個
回傳值。
函式多載化(Method overloading)
任何程式語言中最重要的性質之一便是名稱的運用。當你產生某個物件，
便是給予「對應的儲存空間」一個名稱。函式則是「行為」的名稱。藉由
名稱的運用來描述系統，你便可以發展出容易為人理解(並修改)的程
式。這和散文的書寫很相像- 目標都是為了和讀者溝通。
透過名稱，你可以取用任何物件和任何函式。精心挑選的名稱能夠幫助你
自己和其他人更易了解程式碼的意涵。
不過，當我們將人類語言轉換為程式語言時，問題隨之而生。通常同一個
字可能會有不同的意義- 它被多載化(overloaded)了。當這些不同意義
之間的差別十分細微時，特別有用。你可以說「清洗(wash)這件襯
衫」、「清洗(wash)這部車子」、以及「清洗(wash)這隻狗」。如果
被迫說成「以清洗襯衫(shirtWash)的方式來清洗這件襯衫」、「以清洗
車子(carWash)的方式來清洗這部車子」、「以清洗狗狗(dogWash)
的方式來清洗這隻狗」，才能夠讓聆聽者得以不必區分所欲執行的動作之
間的絲毫差異， 那就顯得太過愚蠢了。大多數自然語言都有贅餘
(redundant)特性，即使你漏掉少數幾個字，仍舊可以判斷出意思。我們
不需要為每個意義都提供個別名稱- 我們可以從上下文(context)推論
出實際意義。
大多數程式語言(尤其是C)規定你必須為每個函式提供獨一無二的識別
字。所以你沒有辦法讓某個名為print() 的函式印出整數值，同時又讓另
一個同樣名為print() 的函式印出浮點數值- 每個函式都得有個獨一無二
的名稱。
在Java(和C++)中，建構式是「函式名稱必須多載化」的另一個原因。
由於建構式名稱是依據class 名稱自動決定的，所以建構式名稱只能有一
個。那麼如果你想以多種方式來產生物件，該當如何？假設你所開發的
class 能夠以標準方式將自己初始化，也可以從檔案中讀取資訊來初始化自
己。於是你得有兩個建構式才行，其中一個不接收任何引數(此即所謂
Chapter 4: Initialization & Cleanup 195
default 建構式，或稱為無引數(no-arg)建構式)，另一個接收String
引數，用以代表檔案名稱(檔案中儲存著物件的資料)。二者皆為建構
式，其名稱肯定相同- 就是class 的名稱。因此，為了讓同名、具有不同
引數型別的函式共同存在，多載化(overloading)便成了不可或缺的重要
關鍵。多載化對於建構式來說是必然產物，而當它運用於一般函式時，一
樣能帶來便利。
以下例子同時示範了「建構式」和「一般函式」的多載化：
//: c04:Overloading.java
// Demonstration of both constructor
// and ordinary method overloading.
import java.util.*;
class Tree {
int height;
Tree() {
prt("Planting a seedling");
height = 0;
}
Tree(int i) {
prt("Creating new Tree that is "
+ i + " feet tall");
height = i;
}
void info() {
prt("Tree is " + height
+ " feet tall");
}
void info(String s) {
prt(s + ": Tree is "
+ height + " feet tall");
}
static void prt(String s) {
System.out.println(s);
}
}
public class Overloading {
public static void main(String[] args) {
196 Thinking in Java www.BruceEckel.com
for(int i = 0; i < 5; i++) {
Tree t = new Tree(i);
t.info();
t.info("overloaded method");
}
// Overloaded constructor:
new Tree();
}
} ///:~
本例中的Tree 物件有兩種生成形式：一種以幼苗形式來生成，不帶任何
引數；一種以苗圃中的植物形式來生成，已有某個高度。為了提供這種支
援能力，我們供應兩個建構式：一個不接收任何引數(此稱為default 建
構式1)，另一個接收某個高度做為引數。
你也許會想要以多種不同方式來呼叫info()，例如帶有一個String 引
數，讓你印出額外訊息；或是不帶任何引數，讓你不印出任何額外訊息。
對於這種概念明顯相同的事物，如果得賦予兩個不同的名稱，實在是很奇
怪。幸運的是，method overloading(函式多載化)允許我們賦予這兩個
函式相同的名稱。
區分多載化函式
如果多個函式具有相同名稱，Java 如何知道你要取用的究竟是哪一個呢？
規則很簡單：每個多載化的函式都需具備獨一無二的引數列(argument
list)。
稍加思考，你便會知道這極富意義。是的，除了引數列所帶來的差異，程
式員還有什麼辦法可以區分兩個同名的函式？
即便是引數順序不同，都足以區分兩個函式(正常情況下你不會採用這種
方式，因為這麼做會讓程式難以維護)：
1 Sun 所發表的某些Java 文獻中，採用另一種笨拙但更具描述力的名稱：無引數(no-arg)
建構式。但由於default 建構式這個詞彙已行之多年，所以我延用之。
Chapter 4: Initialization & Cleanup 197
//: c04:OverloadingOrder.java
// Overloading based on the order of
// the arguments.
public class OverloadingOrder {
static void print(String s, int i) {
System.out.println(
"String: " + s +
", int: " + i);
}
static void print(int i, String s) {
System.out.println(
"int: " + i +
", String: " + s);
}
public static void main(String[] args) {
print("String first", 11);
print(99, "Int first");
}
} ///:~
上例兩個print() 都有相同的引數，但擺設順序不同，這使它們得以有所
區別。
搭配基本型別(primitives)進行多載化
基本型別可以自動由較小型別晉升至較大型別。當它和多載機制搭配使用
時，會產生某種輕微的混淆現象。以下程式說明當基本型別被置於多載化
函式時，究竟會引發什麼現象：
//: c04:PrimitiveOverloading.java
// Promotion of primitives and overloading.
public class PrimitiveOverloading {
// boolean can't be automatically converted
static void prt(String s)
System.out.println(s);
}
void f1(char x) { prt("f1(char)"); }
198 Thinking in Java www.BruceEckel.com
void f1(byte x) { prt("f1(byte)"); }
void f1(short x) { prt("f1(short)"); }
void f1(int x) { prt("f1(int)"); }
void f1(long x) { prt("f1(long)"); }
void f1(float x) { prt("f1(float)"); }
void f1(double x) { prt("f1(double)"); }
void f2(byte x) { prt("f2(byte)"); }
void f2(short x) { prt("f2(short)"); }
void f2(int x) { prt("f2(int)"); }
void f2(long x) { prt("f2(long)"); }
void f2(float x) { prt("f2(float)"); }
void f2(double x) { prt("f2(double)"); }
void f3(short x) { prt("f3(short)"); }
void f3(int x) { prt("f3(int)"); }
void f3(long x) { prt("f3(long)"); }
void f3(float x) { prt("f3(float)"); }
void f3(double x) { prt("f3(double)"); }
void f4(int x) { prt("f4(int)"); }
void f4(long x) { prt("f4(long)"); }
void f4(float x) { prt("f4(float)"); }
void f4(double x) { prt("f4(double)"); }
void f5(long x) { prt("f5(long)"); }
void f5(float x) { prt("f5(float)"); }
void f5(double x) { prt("f5(double)"); }
void f6(float x) { prt("f6(float)"); }
void f6(double x) { prt("f6(double)"); }
void f7(double x) { prt("f7(double)"); }
void testConstVal() {
prt("Testing with 5");
f1(5);f2(5);f3(5);f4(5);f5(5);f6(5);f7(5);
}
void testChar() {
char x = 'x';
prt("char argument:");
Chapter 4: Initialization & Cleanup 199
f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
}
void testByte() {
byte x = 0;
prt("byte argument:");
f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
}
void testShort() {
short x = 0;
prt("short argument:");
f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
}
void testInt() {
int x = 0;
prt("int argument:");
f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
}
void testLong() {
long x = 0;
prt("long argument:");
f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
}
void testFloat() {
float x = 0;
prt("float argument:");
f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
}
void testDouble() {
double x = 0;
prt("double argument:");
f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
}
public static void main(String[] args) {
PrimitiveOverloading p =
new PrimitiveOverloading();
p.testConstVal();
p.testChar();
p.testByte();
p.testShort();
p.testInt();
p.testLong();
200 Thinking in Java www.BruceEckel.com
p.testFloat();
p.testDouble();
}
} ///:~
檢視本程式的輸出結果，你會發現常數值5 被視為int，所以如果某個多載
化函式接受int 做為引數，該函式便會被喚起。至於其他情況，如果你所
提供的資料，其型別「小於」函式的引數，該資料的型別便會獲得晉升。
char 便是如此，如果無法找到恰好吻合的char 參數，它便會被晉升至
int。
如果你所提供的引數「大於」某個多載化函式所預期的引數時，又會引發
什麼現象呢？修改上述程式，便能提供解答：
//: c04:Demotion.java
// Demotion of primitives and overloading.
public class Demotion {
static void prt(String s)
System.out.println(s);
}
void f1(char x) { prt("f1(char)"); }
void f1(byte x) { prt("f1(byte)"); }
void f1(short x) { prt("f1(short)"); }
void f1(int x) { prt("f1(int)"); }
void f1(long x) { prt("f1(long)"); }
void f1(float x) { prt("f1(float)"); }
void f1(double x) { prt("f1(double)"); }
void f2(char x) { prt("f2(char)"); }
void f2(byte x) { prt("f2(byte)"); }
void f2(short x) { prt("f2(short)"); }
void f2(int x) { prt("f2(int)"); }
void f2(long x) { prt("f2(long)"); }
void f2(float x) { prt("f2(float)"); }
void f3(char x) { prt("f3(char)"); }
void f3(byte x) { prt("f3(byte)"); }
void f3(short x) { prt("f3(short)"); }
Chapter 4: Initialization & Cleanup 201
void f3(int x) { prt("f3(int)"); }
void f3(long x) { prt("f3(long)"); }
void f4(char x) { prt("f4(char)"); }
void f4(byte x) { prt("f4(byte)"); }
void f4(short x) { prt("f4(short)"); }
void f4(int x) { prt("f4(int)"); }
void f5(char x) { prt("f5(char)"); }
void f5(byte x) { prt("f5(byte)"); }
void f5(short x) { prt("f5(short)"); }
void f6(char x) { prt("f6(char)"); }
void f6(byte x) { prt("f6(byte)"); }
void f7(char x) { prt("f7(char)"); }
void testDouble() {
double x = 0;
prt("double argument:");
f1(x);f2((float)x);f3((long)x);f4((int)x);
f5((short)x);f6((byte)x);f7((char)x);
}
public static void main(String[] args) {
Demotion p = new Demotion();
p.testDouble();
}
} ///:~
此例之中，這些函式會接受較小的基本型別數值。如果你所提供的引數較
大，你就得在小括號中指定型別名稱，做必要的轉型。如果少了這個動
作，編譯器會送出錯誤訊息。
你應該明白，這是所謂的窄化轉型(narrowing conversion)，表示在轉
型過程中會遺失資訊。這也就是為什麼編譯器強迫你一定要明白標示出來
的原因，它要你自行負責後果。
202 Thinking in Java www.BruceEckel.com
以回傳值(return value)作為多載化的基準
如果你有以下懷疑，很正常：「為什麼只能夠以class 名稱和函式引數列做
為多載化的區分呢？為什麼不依據函式的回傳值加以區分呢？」舉個例
子，下面兩個函式有相同的名稱和相同的引數，但很容易區別：
void f() {}
int f() {}
是的，當編譯器可以很明確地從程式的前後狀態判斷出意義時，這麼做毫
無問題，例如int x = f()。但由於呼叫函式時可以不在乎其回傳值(這麼
做通常是為了只想獲得其「副作用」)，所以如果你用這種方式來呼叫函
式：
f();
Java 如何才能判斷應該喚起哪一個f() 呢？程式碼的閱讀者又要如何才能
明白這一點呢？基於此點，你無法以回傳型別做為多載化函式的區分基
準。
Default 建構式
一如先前所述，default 建構式(或「無引數建構式」)是一種不帶任何引
數的建構式，被用於所謂「無特色物件」的生成。如果你所開發的class 不
具任何建構式，編譯器會自動為你合成一個default 建構式。例如：
//: c04:DefaultConstructor.java
class Bird {
int i;
}
public class DefaultConstructor {
public static void main(String[] args) {
Bird nc = new Bird(); // default!
}
} ///:~
Chapter 4: Initialization & Cleanup 203
其中的：
new Bird();
會產生一個新的物件，並呼叫default 建構式- 即使你沒有自行定義任何
default 建構式。如果沒有default 建構式，上例就沒有任何函式可供呼
叫，也就無法建構出我們想要的物件了。請注意，如果你自行定義任何一
個建構式(不論有無引數)，編譯器就不會為你合成default 建構式：
class Bush {
Bush(int i) {}
Bush(double d) {}
}
現在，如果你這麼寫：
new Bush();
編譯器會發出抱怨，因為它無法找到吻合的建構式。當你沒有提供任何建
構式，編譯器說：『你需要建構式，讓我為你產生一個吧』。但如果你已
經撰寫了某個建構式，編譯器會說：『你已經撰寫了建構式，顯然你知道
你正在做什麼；如果你沒有撰寫default 建構式，你必然是刻意的』。
關鍵字this
假設你有兩個同型的物件，分別名為a 和b。你可能想知道，究竟該以何
種方式，才能分別透過這兩個物件呼叫f()：
class Banana { void f(int i) { /* ... */ } }
Banana a = new Banana(), b = new Banana();
a.f(1);
b.f(2);
如果只有一個f() ，那麼它又如何得知自己是被物件a 或b 呼叫呢？
為了讓你能夠以十分便利的物件導向語法(也就是「送訊息給物件」這樣
的意涵)來撰寫程式碼，編譯器暗自動了些手腳。事實的真象是，有個隱
晦的第一引數被傳入f() ， 此一引數便是「正被操作中的物件的
reference」。所以上述兩個函式的叫用形式其實變成這個樣子：
204 Thinking in Java www.BruceEckel.com
Banana.f(a,1);
Banana.f(b,2);
這種轉換只存於語言內部，你無法撰寫上面那樣的算式並順利通過編譯。
不過，這麼寫可以讓你對實際發生的事情有些概念。
想像你現在正位於某個函式之內，你想取得當前的object reference。由於
該reference 是編譯器偷偷傳入，所以並不存在其識別名稱。為了這個原
因，關鍵字this 因應而生。這個關鍵字僅用於函式之內，能取得「喚起此
一函式」的那個object reference。你可以採取你面對任何object reference
一樣的處理方式來處理這個this。注意，如果你只是在某個class 的某個
函式內呼叫同一個class 的另一個函式，沒有必要動用this，直接呼叫即
可，因為編譯器會自動套用當前的this reference。因此，你可以這麼寫：
class Apricot {
void pick() { /* ... */ }
void pit() { pick(); /* ... */ }
}
在pit() 中，你可以將pick() 寫成this.pick()，但沒有必要如此。編譯
器會自動為你完成此事。當你必須明確指出當前的object reference 究竟為
何時，才有需要動用關鍵字this。例如，當你想要回傳目前的物件時，就
需要在return 述句中這麼寫：
//: c04:Leaf.java
// Simple use of the "this" keyword.
public class Leaf {
int i = 0;
Leaf increment() {
i++;
return this;
}
void print() {
System.out.println("i = " + i);
}
public static void main(String[] args) {
Leaf x = new Leaf();
x.increment().increment().increment().print();
Chapter 4: Initialization & Cleanup 205
}
} ///:~
由於increment() 透過關鍵字this 回傳了當前的物件，所以我們可以輕
易在同一個物件身上執行多次操作。
在建構式中呼叫建構式
當你為某個class 撰寫多個建構式時，有時候你會想要在某個建構式中呼叫
另一個建構式，以免撰寫重覆的程式碼。使用this 關鍵字便可以做到這一
點。
正常情況下當你寫下this，指的是「此一物件」或「目前的物件」，並自
動產生「目前的物件」的reference。但是在建構式中，當你賦予this 一
個引數列，它有了不同的意義：它會呼叫符合該引數列的某個建構式。如
此一來我們便能夠直接呼叫其他建構式(譯註：C++不允許如此)：
//: c04:Flower.java
// Calling constructors with "this."
public class Flower {
int petalCount = 0;
String s = new String("null");
Flower(int petals) {
petalCount = petals;
System.out.println(
"Constructor w/ int arg only, petalCount= "
+ petalCount);
}
Flower(String ss) {
System.out.println(
"Constructor w/ String arg only, s=" + ss);
s = ss;
}
Flower(String s, int petals) {
this(petals);
//! this(s); // Can't call two!
206 Thinking in Java www.BruceEckel.com
this.s = s; // Another use of "this"
System.out.println("String & int args");
}
Flower() {
this("hi", 47);
System.out.println(
"default constructor (no args)");
}
void print() {
//! this(11); // Not inside non-constructor!
System.out.println(
"petalCount = " + petalCount + " s = "+ s);
}
public static void main(String[] args) {
Flower x = new Flower();
x.print();
}
} ///:~
建構式Flower(String s, int petals) 說明了一點;：雖然你能夠藉由
this 呼叫一個建構式，卻不能以相同手法呼叫兩個。此外，對另一建構式
的呼叫動作必須置於最起始處，否則編譯器會發出錯誤訊息。
這個例子同時也展示了this 的另一用途。由於引數s 和資料成員s 的名稱
相同，會出現模稜兩可的情況。你可以寫下this.s，明確表示你所取用的
是資料成員s。Java 程式碼中常能見到此種形式，本書亦常採用這種形
式。
在print() 中你看到了，編譯器不允許你在建構式以外的任何函式內呼叫
建構式。
static 的意義
了解this 之後，你應該比較能夠了解何謂static 函式。它的意思是，對於
這個函式，沒有所謂的this。你無法在static 函式中呼叫non-static 函
Chapter 4: Initialization & Cleanup 207
式2(反向可行)。不過倒是可以經由class 本身來呼叫其static 函式，無
需透過任何物件。事實上這也正是static 函式存在的主要原因。它很像是
C 的全域函式。Java 沒有全域函式；將static 函式置於class 之中，可以
提供「對其它static 函式和static 資料成員」的存取。
有些人認為static 函式不符合物件導向的精神，因為它們具備了全域函式
的語意；他們認為，使用static 函式時，並非以「送出訊息給物件」的方
式來達成，因為其間並不存在this。此論頗為公允，因此如果你發現自己
動用大量static 函式，你應該重新思考自己的策略。不過，static 是務實
的產物，而且的確存在應用時機，所以它們是否歸屬於「物件導向編程的
嚴格定義」內，應該留給理論家去辯論。即使Smalltalk 也具備所謂class
函式(等同於static 函式)這樣的東西呢。
清理(Cleanup)：終結(finalization)與
垃圾回收(garbage collection)
程式員能夠體會初始化的重要性，但常常遺忘清理的重要性。畢竟，有誰
需要清理一個int 呢？但是，使用程式庫時，在用完物件之後，如果只是
將它棄而不顧，有時候會帶來危險。當然啦，Java 提供了垃圾回收器來回
收那些不再被使用的物件的記憶體空間，但是請你想想某些不尋常的情
況。假設你的物件並非經由new 獲得某種「特殊」記憶體。垃圾回收器只
知道釋放那些經由new 配置得來的記憶體，因此它不知道如何釋放你這個
物件所佔用的「特殊」記憶體。為了因應這種情況，Java 提供一個
finalize() 函式，你可以為自己的class 定義此一函式。以下說明它被期望
的運作方式。當垃圾回收器打算開始釋放你的物件所佔用的儲存空間時，
會先呼叫其finalize()，並且在下一次垃圾回收動作發生時才回收該物件
2除非你將某個object reference 傳入static method，然後透過該reference(效用等同
this)，你便可以呼叫non-static methods 並存取non-static fields 了。不過，如果你想
從事諸如此類的動作，通常你只需製作普通的non-static method 即可 。
208 Thinking in Java www.BruceEckel.com
所佔用的記憶體。所以，如果你使用finalize()，它便讓你得以在「垃圾
回收時刻」執行某些重要的(你自己的)清理動作。
這中間有個潛伏的編程陷阱。某些程式員(尤其是C++ 程式員)可能會先
入為主地認為finalize() 是C++的解構式(destructor)，也就是當物件
被摧毀時會被自動喚起的函式。從這一點區分C++ 和Java 是很重要的，
因為C++物件絕對會被摧毀(如果你的程式沒有臭蟲)，而Java 物件並不
絕對會被垃圾回收器回收。換一個說法：
垃圾回收(garbage collection)不等於解構(destruction)
牢記這一點，你便可以遠離困擾。這句話的真義是，在你「永遠不再需要
某個物件」之前，如果某些動作必得執行，你得自己動手執行它們。Java
並沒有解構式(destructor)或類似概念，所以你必須撰寫一個函式來執行
清理動作。舉個例子，假設物件在產生過程中將自己繪製於螢幕上，如果
你沒有自行動手將它從螢幕拭去，它便可能永遠不會被清理掉。如果你將
某些擦拭影像的功能置於finalize()，那麼當這個物件被垃圾回收器回收
之前，其影像會先在螢幕上被拭去。如果物件沒有被回收，影像就持續存
在。所以請牢記第二點：
你的物件可能不會被回收
你可能發現，某個物件所佔用的空間永遠沒有被釋放掉，因為你的程式可
能永遠不會逼近記憶體用完的那一刻。如果你的程式執行完畢，而垃圾回
收器完全沒有被啟動以釋放你的物件所佔據的記憶體，那些空間便會在程
式終止時才一次歸還給作業系統。這是好事，因為垃圾回收器會帶來額外
負擔，如果永遠不啟動它，就永遠不需要付出額外代價。
finalize() 存在是為了什麼？
此刻，你也許會相信你不應該使用finalize() 做一般用途的清理工作。那
麼，它究竟為何存在呢？
Chapter 4: Initialization & Cleanup 209
第三句金玉良言就是：
垃圾回收動作(garbage collection)只回收記憶體
也就是說，垃圾回收器存在的唯一理由，就是要回收那些在你程式中再也
用不著的記憶體空間。所以任何和垃圾回收動作綑綁在一起的行為，也都
只能和記憶體或記憶體的釋放相關。
這是否意味如果你的物件內含其他物件，在finalize() 中應該明確釋放那
些物件？嗯，答案是no，垃圾回收器所留意的是「物件記憶體」的釋放，
不論物件被生成的方式究竟為何。如此一來，對finalize() 的需求便侷限
於特定情況之下。這個情況就是：當你的物件以「物件生成」之外的方式
配置了某種儲存空間。不過，你可能會觀察到，Java 的一切事物都是物
件，那麼究竟怎樣才會碰到上述情況？
似乎只有在你透過Java 的非正常管道來配置記憶體，打算做一些類似C 會
做的事情時，才是使用finalize() 的適當時機。這種情況主要發生在採用
原生函式(native methods)時，那是一種在Java 程式中呼叫non-Java
程式碼的方法(附錄B 對此有所討論)。目前原生函式僅支援C 和C++ 兩
個語言，不過由於這兩個語言可以再呼叫其他語言，所以實際上你可以呼
叫所有語言。在non-Java 程式碼中，C 的malloc() 函式族系可能會被呼
叫，用以配置儲存空間，而且除非你呼叫free()，否則其佔用空間永遠不
會被釋放，進而產生記憶體漏洞(memory leak)。當然啦，free() 是
C/C++ 函式，所以你得在finalize() 中以原生函式加以呼叫。
閱讀至此，你或許明白，你不應該過度使用finalize()。你是對的，它並
不是擺放正常清理動作的合適地點。那麼，哪裡才是正常清理動作的執行
場所呢？
你必須執行清理(cleanup)動作
為了清理某個物件，使用者必須在「打算進行清理動作」時呼叫「用於清
理任務」的函式。聽起來很簡單， 但這麼做和C++ 的解構式
(destructor)觀念稍有抵觸。在C++ 中，所有物件都會被摧毀，或說所
210 Thinking in Java www.BruceEckel.com
有物件都「應該」被摧毀。如果某個C++ 物件以local 形式生成(也就是
佔用stack 空間，這在Java 不可能發生)，那麼其解構動作會於該物件產
生地點所在的大括號範圍結束前自動發生。如果該物件是以new 產生(就
像Java 一樣)，那麼其解構式會在程式員呼叫C++ delete 運算子(Java
沒有這個運算子)時被喚起。如果C++ 程式員忘了呼叫delete，其解構
式便永遠不會被喚起，並因此產生記憶體漏洞，而物件的其他部份也不會
被清理。這類程式臭蟲很難追蹤。
相對之下，Java 不允許你產生local 物件，你一定得使用new 才行。不過
Java 並沒有delete 運算子可供呼叫以釋放物件，因為垃圾回收器會為你
釋放空間。所以，從簡化觀點來看，你可以說，因為有了垃圾回收機制，
所以Java 不需要解構式。但當你隨著本書的內容前進，你會發現，垃圾回
收器的存在無法消除對解構式的需求，也無法取代它的功用(而且由於你
絕不應該直接呼叫finalize()，所以finalize() 不是解決此一問題的適當
手段)。除了空間的釋放，如果你希望執行其他清理動作，你仍得自行呼
叫恰當的函式，這個函式和C++ 解構式等效，只不過少了點便利性。
finalize() 有個可以發揮實際效用的地方，就是用來觀察垃圾回收過程。
以下範例為你說明整個過程的進行，並摘要整理先前對垃圾回收動作的種
種敘述：
//: c04:Garbage.java
// Demonstration of the garbage
// collector and finalization
class Chair {
static boolean gcrun = false;
static boolean f = false;
static int created = 0;
static int finalized = 0;
int i;
Chair() {
i = ++created;
if(created == 47)
System.out.println("Created 47");
}
Chapter 4: Initialization & Cleanup 211
public void finalize() {
if(!gcrun) {
// The first time finalize() is called:
gcrun = true;
System.out.println(
"Beginning to finalize after " +
created + " Chairs have been created");
}
if(i == 47) {
System.out.println(
"Finalizing Chair #47, " +
"Setting flag to stop Chair creation");
f = true;
}
finalized++;
if(finalized >= created)
System.out.println(
"All " + finalized + " finalized");
}
}
public class Garbage {
public static void main(String[] args) {
// As long as the flag hasn't been set,
// make Chairs and Strings:
while(!Chair.f) {
new Chair();
new String("To take up space");
}
System.out.println(
"After all Chairs have been created:\n" +
"total created = " + Chair.created +
", total finalized = " + Chair.finalized);
// Optional arguments force garbage
// collection & finalization:
if(args.length > 0) {
if(args[0].equals("gc") ||
args[0].equals("all")) {
System.out.println("gc():");
System.gc();
}
212 Thinking in Java www.BruceEckel.com
if(args[0].equals("finalize") ||
args[0].equals("all")) {
System.out.println("runFinalization():");
System.runFinalization();
}
}
System.out.println("bye!");
}
} ///:~
上述程式產生許多Chair 物件，並且在垃圾回收器啟動時間點上，停止產
生Chairs。由於垃圾回收器可能在任何時間啟動，你無法精確知道它究竟
何時開始執行，因此程式中以名為gcrun 的旗標來標示垃圾回收器是否已
經開始執行。另一個旗標f 用來讓Chair 通知main() 中的迴圈，是否應
該停止產生物件。這兩個旗標都應該在finalize() 中加以設定。垃圾回收
動作一旦發生，便會呼叫finalize()。
另有兩個static 變數：created 和finalized，用來記錄Chair 物件的數
目以及被垃圾回收器終結的數目。每個Chair 都有其自身的(nonstatic)
int i，用以記錄自己的誕生序號。當Chair 物件序號47 被終結，
旗標f 會被設為true，停止Chair 的生產。
所有事情都發生在main() 的迴圈內：
while(!Chair.f) {
new Chair();
new String("To take up space");
}
你可能想知道，此一迴圈究竟如何結束，因為迴圈中並沒有任何事物會更
動Chair.f 之值。喔，finalize() 會更動之，因為它終究會回收至序號47
的物件。
每次迭代所產生的String 物件，只是為了當做額外的配置空間，藉以激發
垃圾回收器的啟動。因為垃圾回收器會在它判斷「可用記憶體數量不足」
時才開始執行。
Chapter 4: Initialization & Cleanup 213
欲執行此程式，你得經由命令列提供必要的引數：”gc” 或”finalize”
或”all”。如果指定”gc”，會令程式呼叫System.gc()(強迫執行垃圾回收
器)。如果指定”finalize”，會呼叫System.runFinalization()，理論上
會讓每個未被終結(finalized)的物件都被終結。如果指定”all”，會使得
上述兩個函式都被呼叫。
這個程式所顯露出來的行為，及其前一版(出現於本書第一版)的行為，
說明垃圾回收和終結的議題又有了新的發展。許多發展是關起門來秘密進
行的。事實上在你閱讀本書之際，這個程式的行為可能又再次有了變化。
如果System.gc() 被喚起，終結動作便會發生於所有物件身上。這對早先
的JDK 而言，並非絕對必然- 儘管文件上不是這麼說。此外，你也會觀
察到，不論System.runFinalization() 是否被喚起，似乎都沒有任何差
別。
然而你會發現，只有當System.gc() 被喚起於「所有物件被產生並被棄
置」之後， 所有的finalizers 才會被呼叫。如果你沒有呼叫
System.gc() ， 那麼只有某些物件會被終結。在Java 1.1 中，
System.runFinalizersOnExit() 用來讓程式結束時得以執行所有的
finalizers。不過，此一設計最後被認為有問題，所以這個函式便被宣告為
不再適用。這條線索曝露出Java 設計者仍在反覆研究並企圖解決垃圾回收
和終結的議題。我們希望Java 2 中一切事情能夠獲得好的結果。
先前的程式說明了，「finalizers 絕對會被執行」這項保證是千真萬確的。
但是只有在你強迫它發生的時候才會如此。如果你沒有讓System.gc() 被
喚起，你會得到如下輸出結果：
Created 47
Beginning to finalize after 3486 Chairs have been
created
Finalizing Chair #47, Setting flag to stop Chair
creation
After all Chairs have been created:
total created = 3881, total finalized = 2684
bye!
214 Thinking in Java www.BruceEckel.com
因此並非所有的finalizers 在程式執行完畢時都被喚起。如果System.gc()
曾經被呼叫，它就會終結、摧毀當時不再被使用的所有物件。
請記住，無論是垃圾回收動作或終結動作，都不保證一定會發生。如果
Java 虛擬機器(JVM)並未面臨記憶體耗盡的情境，它不會浪費時間於垃
圾回收上，這很聰明。
死亡條件(The death condition)
一般情況下，你的程式不能倚靠「finalize() 被呼叫」才正常運作。你得
發展個別的「清理」函式，並自行呼叫之。所以，看起來，finalize() 只
能在大多數程式員都不會用到的「無名記憶體」清理動作上發揮作用。不
過，只要你的程式不倚靠finalize() 的被呼叫，那麼它還有一個很有意思
的用途，那就是物件的「死亡條件(death condition)3」的檢查。
當你對某個物件不再感興趣- 也就是它可以被清理時－ 這個物件應該處
於某種狀態，使它所佔用的記憶體空間得以被安全釋放。舉例來說，如果
這個物件代表某個已開啟的檔案，那麼該檔案在此一物件被回收前，應該
先被關閉。只要這個物件的任何部份未被適當清理，你的程式便存在難以
被找出的臭蟲。finalize() 的價值便在於它可以用來找出這種情況- 雖然
它並不一定會被喚起。如果由於某個終結(finalized)動作的發展，使得
這個程式臭蟲曝光，你便可以找出問題所在。這正是我們最關注的事情。
以下是個簡單例子，示範可能的使用方式，：
//: c04:DeathCondition.java
// Using finalize() to detect an object that
// hasn't been properly cleaned up.
class Book {
3 這是我和Bill Venners(www.artima.com)共同開授的研討班中，由他所創的一個詞彙。
Chapter 4: Initialization & Cleanup 215
boolean checkedOut = false;
Book(boolean checkOut) {
checkedOut = checkOut;
}
void checkIn() {
checkedOut = false;
}
public void finalize() {
if(checkedOut)
System.out.println("Error: checked out");
}
}
public class DeathCondition {
public static void main(String[] args) {
Book novel = new Book(true);
// Proper cleanup:
novel.checkIn();
// Drop the reference, forget to clean up:
new Book(true);
// Force garbage collection & finalization:
System.gc();
}
} ///:~
在這個例子中，死亡條件是「所有Book 物件都被預期在它們被回收之前
先被登錄(checked in)」。但在main() 中，由於程式員的錯誤，有一本
書未被登錄。如果沒有finalize() 來檢查死亡條件，這會是一隻棘手的臭
蟲。
請記住，System.gc() 被用來強迫終結動作的發生(你應該在程式開發過
程中進行此事，以便協助偵錯)。不過，即使沒有使用到它，在反覆執行
此程式的情況下(假設程式會配置夠多的儲存空間，使得垃圾回收器啟
動)，最終還是有可能找出遺失的Book。
垃圾回收器(garbage collector)的運作方式
如果你以往所用的程式語言，從heap 空間配置物件的代價十分高昂，那麼
你可能直覺地假設，Java 這種從heap 空間配置所有物件(基本型別除
216 Thinking in Java www.BruceEckel.com
外)的體制，也得付出高昂成本。然而垃圾回收器對於物件的生成速度，
卻可能帶來顯著的加速效果。乍聽之下令人覺得奇怪- 儲存空間的釋放竟
然會影響儲存空間的配置- 但這的確是某些JVMs(Java 虛擬機器)的運
作方式，這同時也意味，Java 從heap 空間配置物件的速度，能夠逼近其
他語言自stack 挖掘空間的速度。
舉個例子，你可以將C++ heap 想像是一塊場地，在其中，每個物件不斷
監視屬於自己的地盤。它們可能在稍後某個時刻不再繼續佔用目前所佔用
的空間，這些空間因此必須被重新運用。在某些JVMs 裡頭，Java heap 和
上述觀念有著顯著的不同；比較像是輸送帶，每當你配置新的物件，這條
履帶便往前移動。這意味物件空間的配置速度非常快。「heap 指標」只是
很單純地往前移動至未經配置的區域，因此其效率和C++ stack 配置動作
不相上下。當然，相關的記錄動作還是得付出額外代價，不過不需要進行
諸如「搜尋可用空間」之類的大動作。
現在，你也許會注意到，heap 實際上不是個輸送帶，如果你只用這種方式
來處理heap，最後勢必遭遇極為頻繁的記憶體分頁置換動作(paging)，
因而大幅影響系統效能，並在不久之後耗盡資源。成功的關鍵在於垃圾回
收器的介入。回收垃圾的同時，它會重新安排heap 內的所有物件，使它們
緊密排列。這樣一來便將「heap 指標」移至更靠近輸送帶的前端，避免分
頁失誤(page fault)的發生。垃圾回收器會進行事物重新排列，使得高
速、無限自由heap 空間的模式有機會於空間配置時實現。
你得多多了解各種垃圾回收器(GC)的架構，才能更加明白上述方式如何
運作。參用計數(reference counting)是一種很單純、速度很慢的GC 技
術：每個物件皆內含所謂的參用計數器，每當某個reference 連接至某個物
件，其計數器便累加1。每當reference 離開其生存範圍，或被設為null，
其計數器便減1。因此，reference counts 的管理動作很簡單，但程式執行
過程中必須持續付出額外負擔，因為垃圾回收器必須逐一走訪一長串的物
件，並且在發現某個物件的參用計數器為零時，釋放其所佔用的空間。這
麼做的缺點之一是，如果物件彼此之間形成循環性的交互參考，那麼即便
整群物件都已成為垃圾，它們仍舊可能有著非零的reference counts。找出
這種自我參考的整群物件，對垃圾回收器來說是件極度龐大的工程。
Reference counting 常常被拿來說明某種類型的垃圾回收機制，但似乎從
來沒有被真正用於任何JVM身上。
Chapter 4: Initialization & Cleanup 217
為求更快的速度，垃圾回收動作並非以reference counting 方式為之。它所
依據的基本理念是，能夠根據「存活於stack(堆疊)或static storage(靜
態儲存空間)上」的reference 而追蹤到的物件，才算是生命尚存的物件。
整個追蹤鏈可能會涵括好幾層物件。因此如果你從stack 或static storage
出發，走訪所有references 之後，便能找到所有存活的物件。針對每個你
所找到的reference，你都必須再鑽進它所代表(指向)的物件，然後循著
該物件內含的所有references，再鑽入它們所指的物件。如此反覆進行，
直到訪遍「根源於stack 或static storage 上」的reference 所形成的整個網
絡為止。你所走訪的每個物件都必定是存活的。請記住，這種作法並不存
在「自我引用群」(self-referential groups)的問題- 那些物件不會被找
到，自然而然變成了垃圾。
在這種方式下，JVM 使用所謂的「自省式(adaptive)」垃圾回收機制。
至於它如何處理它所找到的存活物件，視JVM 採用哪種變形而定。眾多變
形之中有一種作法名為stop-and-copy(停止而後複製)。就像字面所顯
示的意義一樣，它先將執行中的程式暫停下來(所以它並非一種於背景執
行的垃圾回收機制)，然後將所有找到的物件從原本的heap 複製到另一個
heap，並將所有垃圾捨棄不顧。當物件被複製到新heap，係以頭尾相連的
方式排列，於是新的heap 排列緊湊，並因此在配置新儲存空間時得以簡單
地從最末端騰出空間來，一如先前所描述。
當然，當物件從某處被移至另一處，所有指向它的那些references 都必須
獲得修正。「來自heap 或static storage」的references 可被立即修正，但
可能還有其他「指向此一物件」的references，得透過後繼走訪過程才能
找到。找到它們之後才能調整其值(你可以想像有個表格，將舊位址映射
至新位址)。
對於這種所謂的「複製式回收器(copy collectors)」而言，兩個問題會造
成效率低落。首先，你得有兩個heaps，然後你得在兩個獨立的heaps 之
間將記憶體內容來回搬動。這麼做得維護實際所需記憶體數量的兩倍。某
些JVMs 對此問題的處理方式是，從heap 配置出所需的chunks(譯註：
大塊大塊記憶體)，然後將資料從chunk 複製到另一個chunk。
218 Thinking in Java www.BruceEckel.com
第二個問題在於複製。你的程式進入穩定狀態之後，可能只會產生少量垃
圾，甚至不產生垃圾。儘管如此，複製式回收器仍然會將所有記憶體自某
處複製到另一處，這麼做極度浪費氣力。為了避免這種情形發生，有些
JVMs 會偵測是否沒有新垃圾產生，並因此轉換到另一種機制(此即所謂
「自省式(adaptive)」的字面意義)。有一種名為mark and sweep(標
示而後清理)的機制為早期的Sun JVM採用。對一般用途而言，這種方式
其實速度頗慢，但是當你知道你只產生少量垃圾甚至沒有產生垃圾時，它
的速度就很快了。
mark and sweep 依循的運作規則，同樣是從stack 和static storage 出發，
追蹤走訪所有references，進而找出所有存活的物件。每當它找到一個存
活物件，便設定該物件內的旗標，加以標示。此時物件尚未被回收。當整
個標示程序都完成了，清理動作才會開始。清理過程中，不復存活的物件
會被釋放(譯註：因為這些物件所佔用的空間被釋放掉了，所以heap 中的
被使用空間呈現不連續狀態)。沒有任何複製動作發生。所以如果收集器
決定將「使用狀態呈現不連續」的heap 加以密集(compact)，它得重新
整理它所找到的物件。
stop-and-copy 這個名稱，意味這種垃圾回收動作並非執行於背景；相反
的，GC 啟動同時，執行中的程式會被暫停。你可以在Sun 文獻中發現，
許多參考文獻將垃圾回收視為低優先權的背景程序，但事實上GC 並非以
此種方式實作，至少早期的Sun JVM 並非如此。當記憶體可用數量趨低
時，Sun 垃圾回收器才會啟動，而mark and sweep 方式也必須在程式停
止的情況下才能運作。
如前文所述，此處所描述的JVM，記憶體配置單位是一大區塊(blocks，
譯註：而非只是如物件般大小的小塊記憶體)。如果你配置了大型物件，
它會擁有專屬區塊。周密的stop-and-copy 作法，必須在你釋放舊有物件
之前，先將所有存活物件從舊heap 複製到新heap，這個過程需要搬動大
量記憶體。如果以區塊(blocks)方式為之，GC 可以在回收過程中使用廢
棄區塊(dead blocks)來複製物件。每個區塊都有世代計數(generation
count)，記錄它是否還存活。正常情況下只有上次GC 運作之後所產生的
區塊才會被密集(compact)起來；如果某個區塊尚被某處引用，其世代
計數會有所記錄。這種方式可以處理數量極大而生命短暫的暫時物件。完
整的清理動作會定期出現- 大型物件仍然不會被複製(只是其世代計數會
Chapter 4: Initialization & Cleanup 219
受到影響)。內含小型物件的那些區塊則被複製並密集。JVM 會監督GC
效率，如果發現GC 因為「所有物件皆長期存活」而變得效率不彰，它會
轉換至mark and sweep 模式。同樣道理，JVM 會追蹤mark and sweep
模式的績效，如果heap 斷裂情況太嚴重，它會轉回stop-and-copy 模式。
此即「自省式(adaptive)」的由來。我們可以這麼說：stop-and-copy 和
mark and sweep 兩者是自省的、互生的。
JVM 可以加上許多額外的技巧以提昇速度。載入器(loader)和即時
(Just-In-Time，JIT)編譯器是其中格外重要者。一旦某個class 必須被
載入(通常是在你為它產生第一個物件時)，編譯器會先找到其.class 檔
案位置，然後將class byte codes 載入記憶體。這時候有一種手法，就是對
所有程式碼進行JIT 動作，但這麼做有兩個缺點：它會花費更多時間，這
些時間散落在程式執行過程的許多地點；這麼做也會增加執行碼佔用空間
(byte codes 佔用的空間比JIT 展開後的程式碼小得多)，因而可能導致
分頁置換(paging)動作發生，這絕對會拖累程式的執行速度。另一種方
法則是所謂的「緩式評估(lazy evaluation)」，意思是程式碼只有在需
要用到時才透過JIT 編譯。因此如果某段程式碼永遠不被執行，也就永遠
不會被加以JIT 編譯。
成員初始化(Member initialization)
Java 保證，變數絕對會在它們被使用之前被適當初始化。當變數被定義於
函式之內，Java 會運用編譯期錯誤訊息來貫徹它的保證。所以如果你這麼
寫：
void f() {
int i;
i++;
}
你會得到錯誤訊息，告訴你i 可能沒有被初始化。當然，編譯器可以給i 一
個預設值，但這畢竟很有可能是程式員的疏失，那麼即便提供預設值也沒
有實質效果。強迫程式員提供初值，更有可能找到程式臭蟲。
220 Thinking in Java www.BruceEckel.com
如果某個class 的資料成員隸屬基本型別，情況就稍有不同。因為所有函式
都可以初始化或使用該資料值，所以強迫使用者一定得在使用之前給定適
當初值是不切實際的。不過，放任它持有毫無意義的初值也很危險，所以
每個「隸屬基本型別」的class 資料成員都保證一定有初值。下面例子顯示
這些初值：
//: c04:InitialValues.java
// Shows default initial values.
class Measurement {
boolean t;
char c;
byte b;
short s;
int i;
long l;
float f;
double d;
void print() {
System.out.println(
"Data type Initial value\n" +
"boolean " + t + "\n" +
"char [" + c + "] "+ (int)c +"\n"+
"byte " + b + "\n" +
"short " + s + "\n" +
"int " + i + "\n" +
"long " + l + "\n" +
"float " + f + "\n" +
"double " + d);
}
}
public class InitialValues {
public static void main(String[] args) {
Measurement d = new Measurement();
d.print();
/* In this case you could also say:
Chapter 4: Initialization & Cleanup 221
new Measurement().print();
*/
}
} ///:~
程式輸出如下：
Data type Initial value
boolean false
char [ ] 0
byte 0
short 0
int 0
long 0
float 0.0
double 0.0
char 之值為零，所以印出空白。
稍後你會看到，當你在class 之內定義了一個object reference 而卻沒有為
它設定初值(指向某個物件)，該reference 會獲得一個特殊值null(這
是Java 關鍵字)。
從輸出結果可以觀察到，即使沒有指定任何初值，它們都會被自動初始
化。所以至少我們不必冒著「拿無初值變數來使用」的風險。
指定初值
如果你想為某個變數設定初值，應該怎麼進行？最直接的方式便是直接在
class 的變數定義處指定其值。請注意，C++ 不允許你這麼做- 雖然C++
初學者總是這麼嘗試 。下面的例子改變了class Measurement 中的欄
位定義，藉以提供初值：
class Measurement {
boolean b = true;
char c = 'x';
byte B = 47;
short s = 0xff;
int i = 999;
long l = 1;
222 Thinking in Java www.BruceEckel.com
float f = 3.14f;
double d = 3.14159;
//. . .
你也可以使用同樣的手法來為基本型別以外的物件設初值。如果Depth 是
個class，你可以在加入Depth 變數的同時給予初值，像這樣：
class Measurement {
Depth o = new Depth();
boolean b = true;
// . . .
如果你在尚未為o 提供初值前便嘗試使用它，會得到所謂的異常
(exception，第10 章討論)，這是一種執行期錯誤。
你甚至可以呼叫某個函式來提供初值：
class CInit {
int i = f();
//...
}
當然，函式可以擁有引數，但這些引數不可以是尚未初始化的其他class 成
員。因此，你可以這麼寫：
class CInit {
int i = f();
int j = g(i);
//...
}
卻無法這麼寫：
class CInit {
int j = g(i);
int i = f();
//...
}
編譯器會在進行前置參考(forward referencing)時適當指出問題所在，
因為上述程式的正確性顯然相依於初始化順序，無法通過編譯。
Chapter 4: Initialization & Cleanup 223
此種初始化方式極簡單又直覺，不過有個限制：每個Measurement 物件
都有相同的初值。有時候這是你要的，有時候你需要更彈性的作法。
以建構式(Constructor)進行初始化動作
建構式可用來執行初始化動作，因而賦予你更多編程上的彈性。這是因為
你可以在執行期呼叫函式並執行某些動作以決定初值。不過，使用這種作
法時，有件事必須牢記在心：你無法杜絕發生於建構式執行之前的自動初
始化動作。所以，如果你這麼寫：
class Counter {
int i;
Counter() { i = 7; }
// . . .
i 值會先被初始化為0，然後才變成7。任何基本型別和object references
皆如此，就連那些定義時便給定初值的變數也不例外。基於這個理由，編
譯器不會強迫你一定要在建構式內的某個特定地點將元素初始化，或是在
你使用它們之前先初始化，因為初始化動作已經是一種保證4。
初始化次序
class 中的初始化次序取決於變數在class 中的定義次序。變數定義也許會
散落各處，而且有可能介於各個函式定義之間。但所有變數一定會在任何
一個函式(甚至是建構式)被呼叫之前完成初始化。舉個例子：
//: c04:OrderOfInitialization.java
// Demonstrates initialization order.
4 與此相較，C++ 具有所謂的「建構式初值列(constructor initializer list)」，能夠讓初
始化動作發生於建構式主體之前，並適用於所有物件身上。請參考《Thinking in C++》第
二版(內含於本書所附光碟，亦可於www.BruceEckel.com 獲得)。
224 Thinking in Java www.BruceEckel.com
// When the constructor is called to create a
// Tag object, you'll see a message:
class Tag {
Tag(int marker) {
System.out.println("Tag(" + marker + ")");
}
}
class Card {
Tag t1 = new Tag(1); // Before constructor
Card() {
// Indicate we're in the constructor:
System.out.println("Card()");
t3 = new Tag(33); // Reinitialize t3
}
Tag t2 = new Tag(2); // After constructor
void f() {
System.out.println("f()");
}
Tag t3 = new Tag(3); // At end
}
public class OrderOfInitialization {
public static void main(String[] args) {
Card t = new Card();
t.f(); // Shows that construction is done
}
} ///:~
我在Card 之中刻意將數個Tag 物件的定義散落四處，藉以證明它們的初
始化動作的確會在進入建構式或任何其他函式之前發生。此外t3 會在建構
式內被重新設值。輸出結果如下：
Tag(1)
Tag(2)
Tag(3)
Card()
Tag(33)
f()
Chapter 4: Initialization & Cleanup 225
因此，t3 這個reference 會被初始化兩遍，一次在呼叫建構式之前，一次
在呼叫建構式之後。第一次所產生的物件會被丟棄，可能稍後會被當成垃
圾回收掉。乍見之下這似乎不太有效率，但這麼做可以保證得到妥當的初
始化。是的，如果我們定義了某個多載化建構式，其中並未為t3 設初值，
而t3 定義處又沒有提供預設初值，會發生什麼不妙的事呢？
靜態資料(static data)的初始化
當資料是static 型式，情況沒有什麼不同：如果資料隸屬基本型別而你又
沒有加以初始化，它便會被設為基本型別的標準初值；如果它是某個
object reference，初值便是null - 除非你產生新物件並將這個reference
指向它。
如果想要在定義處設定初值，作法和面對non-statics 時沒有兩樣。注
意，不論產生多少物件，static 變數都只佔用一份儲存空間。因此當我們
打算將static 儲存空間加以初始化，便會發生問題。下面這個例子清楚突
顯出這一問題：
//: c04:StaticInitialization.java
// Specifying initial values in a
// class definition.
class Bowl {
Bowl(int marker) {
System.out.println("Bowl(" + marker + ")");
}
void f(int marker) {
System.out.println("f(" + marker + ")");
}
}
class Table {
static Bowl b1 = new Bowl(1);
Table() {
System.out.println("Table()");
b2.f(1);
}
void f2(int marker) {
System.out.println("f2(" + marker + ")");
226 Thinking in Java www.BruceEckel.com
}
static Bowl b2 = new Bowl(2);
}
class Cupboard {
Bowl b3 = new Bowl(3);
static Bowl b4 = new Bowl(4);
Cupboard() {
System.out.println("Cupboard()");
b4.f(2);
}
void f3(int marker) {
System.out.println("f3(" + marker + ")");
}
static Bowl b5 = new Bowl(5);
}
public class StaticInitialization {
public static void main(String[] args) {
System.out.println(
"Creating new Cupboard() in main");
new Cupboard();
System.out.println(
"Creating new Cupboard() in main");
new Cupboard();
t2.f2(1);
t3.f3(1);
}
static Table t2 = new Table();
static Cupboard t3 = new Cupboard();
} ///:~
Bowl 讓你得以觀看class 的誕生過程，Table 和Cupboard 會在它們自
身的class 定義式中產生Bowl static 成員。請記住，Cupboard 會在
static 定義之前先產生non-static Bowl b3。輸出結果說明了實際發生之
事：
Bowl(1)
Bowl(2)
Table()
Chapter 4: Initialization & Cleanup 227
f(1)
Bowl(4)
Bowl(5)
Bowl(3)
Cupboard()
f(2)
Creating new Cupboard() in main
Bowl(3)
Cupboard()
f(2)
Creating new Cupboard() in main
Bowl(3)
Cupboard()
f(2)
f2(1)
f3(1)
static 的初始化動作只在必要時刻才會發生。如果你沒有產生Table 物
件，也沒有取用Table.b1 或Table.b2，那麼static Bowl b1 和b2 就
永遠不會被產生。不過它們的初始化動作只會發生在第一個Table 物件被
產生之際，也就是在第一個static 的存取動作發生之際。自此之後，
static 物件便不會再被初始化。
如果statics 並未因為早先的物件生成過程而被初始化，那麼初始化次序會
以statics 為優先，然後才是non-static 物件。這一現象可從輸出結果觀
察得到。
為物件生成過程做一份摘要整理，應該很有用。讓我們考慮一個名為Dog
的class：
1. 當某個型別為Dog 的物件首次被產生出來，或是當class Dog 的
static 函式或static 資料成員首次被存取，Java 直譯器必須搜尋環
境變數classpath 所指定的位置，找出Dog.class。
2. 一旦Dog.class 被載入(稍後你會學到，這樣就是產生一個Class
物件)，它的所有static 初始動作會被執行起來。因此static 初始
化動作僅會發生一次，就是在Class 物件首次被載入時。
228 Thinking in Java www.BruceEckel.com
3. 當你new Dog()，建構過程會先為Dog 物件在heap 上配置足夠的
儲存空間。
4. 這塊儲存空間會先被清為零，並自動將Dog 物件內所有隸屬基本型
別的欄位設為預設值(對數字來說就是零，對boolean 和char 來
說亦同)，並將references 設為null。
5. 執行所有出現於欄位定義處的初始化動作。
6. 執行建構式。就如你將在第六章所見，這中間可能會牽扯極多動
作，尤其當繼承關係捲入時。
static 明確初始化
Explicit static initialization
Java 允許你將多個static 初始化動作組織起來，置於特殊的「static 建構
子句(有時也稱為static block)」中，看起來像這樣：
class Spoon {
static int i;
static {
i = 47;
}
// . . .
看起來像是個函式，但其實是在關鍵字static 之後緊接著函式本體。這樣
的程式碼就像其他形式的static 初始化動作一樣，只會被執行一次：在你
首次產生class 物件或首次存取該class 的static 成員(即使你從未產生過
該class 物件)時。例如：
//: c04:ExplicitStatic.java
// Explicit static initialization
// with the "static" clause.
class Cup {
Cup(int marker) {
System.out.println("Cup(" + marker + ")");
}
Chapter 4: Initialization & Cleanup 229
void f(int marker) {
System.out.println("f(" + marker + ")");
}
}
class Cups {
static Cup c1;
static Cup c2;
static {
c1 = new Cup(1);
c2 = new Cup(2);
}
Cups() {
System.out.println("Cups()");
}
}
public class ExplicitStatic {
public static void main(String[] args) {
System.out.println("Inside main()");
Cups.c1.f(99); // (1)
}
// static Cups x = new Cups(); // (2)
// static Cups y = new Cups(); // (2)
} ///:~
Cups 的「static 初始化動作」將於static 物件c1 被存取之際執行，也就
是發生在標示(1) 那行。如果標示(1) 的那一行被註解掉，而標示(2) 的那
些程式碼被解除註解，那麼「static 初始化動作」就會發生在標示(2) 的
程式行上。如果(1) 和(2) 皆被註解掉，Cups 的static 初始化動作便永遠
不會發生。標示(2) 的程式行中如果有一行或兩行未被註解掉，其實沒有
區別，因為static 初始化動作只會執行一次。
Non-static 實體(instance)初始化動作
Java 也為物件內的non-static 變數的初始化行為提供了類似語法。以下便
是一例：
//: c04:Mugs.java
// Java "Instance Initialization."
230 Thinking in Java www.BruceEckel.com
class Mug {
Mug(int marker) {
System.out.println("Mug(" + marker + ")");
}
void f(int marker) {
System.out.println("f(" + marker + ")");
}
}
public class Mugs {
Mug c1;
Mug c2;
{
c1 = new Mug(1);
c2 = new Mug(2);
System.out.println("c1 & c2 initialized");
}
Mugs() {
System.out.println("Mugs()");
}
public static void main(String[] args) {
System.out.println("Inside main()");
Mugs x = new Mugs();
}
} ///:~
其中你可以看到實體(instance)初始化子句：
{
c1 = new Mug(1);
c2 = new Mug(2);
System.out.println("c1 & c2 initialized");
}
看起來和static 初始化子句一模一樣，只不過少了關鍵字static。如果我
們想提供anonymous inner class(無名的內隱類別，詳見第八章)的初始
化動作，此語法不可或缺。
Chapter 4: Initialization & Cleanup 231
Array 的初始化
在C 裡頭為array 設立初值是一件容易出錯而且令人生厭的工作。C++使
用aggregate initialization(聚合初始化)讓這個動作更安全5。Java 沒有
像C++一般的所謂「aggregates(聚合物)」，因為Java 裡頭的每樣東西
都是物件。Java 也有array，也支援array 初始化功能。
array 其實不過是一連串物件或一連串基本資料，它們都必須同型，並以一
個識別字(名稱)封裝在一起。array 的定義與使用，係以中括號做為「索
引運算子(indexing operator)[ ]」。定義一個array 很簡單，只要在型
別名稱之後接著一組空白中括號即可：
int[] a1;
你也可以將中括號置於識別字之後，意義完全相同：
int a1[];
這種寫法符合C 和C++ 程式員的預期。不過前一種風格或許更合情理，因
為它表示其型別是個int array。本書將採用此種風格。
編譯器並不允許你告訴它究竟array 有多大。此一行為把我們帶回
reference 議題。此刻你所擁有的，只是一個reference，代表某個array，
但是並沒有對應空間。如果想為該array 產生必要的儲存空間，你得撰寫
初始化算式才行。對array 而言，初始化動作可以出現在程式的任何地
點，但你也可以使用一種特殊的初始化算式，它僅能出現於array 生成
處。此一特殊初始化形式是由成對大括號所括住的一組值來設定。這種情
況下，儲存空間的配置(等同於以new 來進行)由編譯器負責。例如：
int[] a1 = { 1, 2, 3, 4, 5 };
那麼，什麼情況使你只想定義array reference 而不定義array 本身呢：
5 關於C++ aggregate initialization，詳見《Thinking in C++》第二版。
232 Thinking in Java www.BruceEckel.com
int[] a2;
唔，Java 允許你將某個array 指派給另一個array，所以你可以這麼寫：
a2 = a1;
你所做的其實不過是reference 的複製罷了，以下是個明證：
//: c04:Arrays.java
// Arrays of primitives.
public class Arrays {
public static void main(String[] args) {
int[] a1 = { 1, 2, 3, 4, 5 };
int[] a2;
a2 = a1;
for(int i = 0; i < a2.length; i++)
a2[i]++;
for(int i = 0; i < a1.length; i++)
System.out.println(
"a1[" + i + "] = " + a1[i]);
}
} ///:~
你看到了，a1 被給定初值，a2 卻沒有；稍後我們將a1 指派給a2。
這裡顯示了一些新觀念：任何array(無論組成份子是物件或基本型別資
料)都有一個固有成員，你可以查詢其值(但無法加以改變)，藉以得知
這個array 所含的元素個數。此一成員即是length。由於Java array 和
C/C++ array 都一樣從0 開始對元素計數，所以你能使用的最大索引值便
是length-1。如果索引值超過界限，C 和C++會毫無異議地接受，因此你
得以存取所有記憶體內容。許多惡名昭彰的程式臭蟲正是源之於此。Java
不同， 它會對你的越界存取動作發出執行期錯誤( 亦即發出異常
exception，詳見第10 章)，使你免於遭受此類問題。當然，每次存取
array 時所做的邊界檢查，會耗費時間成本、帶來額外的程式碼，而且你無
法關閉此一功能。這意味在關鍵時機上，array 的存取可能會是程式效率不
彰的因素。但是在考量Internet 安全性和程式員生產力之後，Java 設計者
認為值得付出這個代價。(譯註：有一種被稱為buffer overflow 的攻擊方
式，便是利用「存取非法記憶體位址」的手法達到入侵系統的目的)
Chapter 4: Initialization & Cleanup 233
如果撰寫程式時你完全不知道你的array 需要多少元素，情形又該如何？
喔，只要以new 來產生元素即可。下面這個例子，使用new 沒有問題，
即使它所產生的乃是基本型別的array(注意，new 無法產生non-array
的基本型別資料)：
//: c04:ArrayNew.java
// Creating arrays with new.
import java.util.*;
public class ArrayNew {
static Random rand = new Random();
static int pRand(int mod) {
return Math.abs(rand.nextInt()) % mod + 1;
}
public static void main(String[] args) {
int[] a;
a = new int[pRand(20)];
System.out.println(
"length of a = " + a.length);
for(int i = 0; i < a.length; i++)
System.out.println(
"a[" + i + "] = " + a[i]);
}
} ///:~
由於array 的大小係透過pRand() 隨機選取而來，所以array 的生成毫無
疑問發生於執行期。此外你可以從本例輸出結果觀察到，基本型別的array
所含的元素會被自動初始化為「空」值：對數值和char 而言為0，對
boolean 而言為false。
當然，你也可以在同一述句中完成array 的定義和初始化：
int[] a = new int[pRand(20)];
如果你要處理的是基本型別以外的objects array，那麼你一定得使用new
來生成各個元素。下面這個例子中，reference 相關議題再度出現，因為你
所產生的其實只是由references 組成的array(而非內含實際物件)。以
Integer wrapper type(外覆型別)為例，它是個class 而非基本型別：
//: c04:ArrayClassObj.java
234 Thinking in Java www.BruceEckel.com
// Creating an array of nonprimitive objects.
import java.util.*;
public class ArrayClassObj {
static Random rand = new Random();
static int pRand(int mod) {
return Math.abs(rand.nextInt()) % mod + 1;
}
public static void main(String[] args) {
Integer[] a = new Integer[pRand(20)];
System.out.println(
"length of a = " + a.length);
for(int i = 0; i < a.length; i++) {
a[i] = new Integer(pRand(500));
System.out.println(
"a[" + i + "] = " + a[i]);
}
}
} ///:~
在這個例子中，即使以new 產出array 之後：
Integer[] a = new Integer[pRand(20)];
這還是個references array。只有在「生成新的Integer 物件以初始化
reference」之後，初始化動作才算完成：
a[i] = new Integer(pRand(500));
如果你忘記產生物件，當你企圖讀取空的array 位置時，會獲得一個異常
(exception)。
請留意print 述句中String 物件的形成。你看到了，指向Integer 物件
的那個reference 被自動轉型，變成物件內容的String 表示式。
我們也可以將一串初值置於成對大括號中，以此來對objects array 設初
值。這種作法有兩種形式：
//: c04:ArrayInit.java
// Array initialization.
public class ArrayInit {
Chapter 4: Initialization & Cleanup 235
public static void main(String[] args) {
Integer[] a = {
new Integer(1),
new Integer(2),
new Integer(3),
};
Integer[] b = new Integer[] {
new Integer(1),
new Integer(2),
new Integer(3),
};
}
} ///:~
有時候這種寫法很有用，但因為array 的容量得在編譯期決定，所以其用
途很受限制。初值列最後的逗號可有可無(這對冗長的初值列的維護頗有
幫助。)
array 的第二種初始化形式提供了十分便利的語法，可產生和「C 的可變引
數列」(variable argument lists，在C 中稱為”varargs”)相同的效應，
可以含括未定個數的引數和未定的型別。由於所有classes 都繼承自共同根
源class Object(循著本書腳步，慢慢你會對此了解更多)，所以你可以
撰寫某個函式，令它接受一個Object array，然後像下面這樣加以呼叫：
//: c04:VarArgs.java
// Using the array syntax to create
// variable argument lists.
class A { int i; }
public class VarArgs {
static void f(Object[] x) {
for(int i = 0; i < x.length; i++)
System.out.println(x[i]);
}
public static void main(String[] args) {
f(new Object[] {
new Integer(47), new VarArgs(),
new Float(3.14), new Double(11.11) });
236 Thinking in Java www.BruceEckel.com
f(new Object[] {"one", "two", "three" });
f(new Object[] {new A(), new A(), new A()});
}
} ///:~
此刻，你無法在這些未知的物件身上進行太多動作。這個程式使用String
自動轉換，使每個Object 得以從事一些有用的事情。第12 章會涵蓋所謂
的「動態時期型別鑑識(run-time type identification，RTTI)」機制，
你將學會如何發覺此類物件的確切型別，使你得以在其身上從事一些更有
趣的活動。
多維度(Multidimensional)arrays
Java 讓你得以輕鬆產生多維度的arrays:
//: c04:MultiDimArray.java
// Creating multidimensional arrays.
import java.util.*;
public class MultiDimArray {
static Random rand = new Random();
static int pRand(int mod) {
return Math.abs(rand.nextInt()) % mod + 1;
}
static void prt(String s) {
System.out.println(s);
}
public static void main(String[] args) {
int[][] a1 = {
{ 1, 2, 3, },
{ 4, 5, 6, },
};
for(int i = 0; i < a1.length; i++)
for(int j = 0; j < a1[i].length; j++)
prt("a1[" + i + "][" + j +
"] = " + a1[i][j]);
// 3-D array with fixed length:
int[][][] a2 = new int[2][2][4];
for(int i = 0; i < a2.length; i++)
for(int j = 0; j < a2[i].length; j++)
for(int k = 0; k < a2[i][j].length;
Chapter 4: Initialization & Cleanup 237
k++)
prt("a2[" + i + "][" +
j + "][" + k +
"] = " + a2[i][j][k]);
// 3-D array with varied-length vectors:
int[][][] a3 = new int[pRand(7)][][];
for(int i = 0; i < a3.length; i++) {
a3[i] = new int[pRand(5)][];
for(int j = 0; j < a3[i].length; j++)
a3[i][j] = new int[pRand(5)];
}
for(int i = 0; i < a3.length; i++)
for(int j = 0; j < a3[i].length; j++)
for(int k = 0; k < a3[i][j].length;
k++)
prt("a3[" + i + "][" +
j + "][" + k +
"] = " + a3[i][j][k]);
// Array of nonprimitive objects:
Integer[][] a4 = {
{ new Integer(1), new Integer(2)},
{ new Integer(3), new Integer(4)},
{ new Integer(5), new Integer(6)},
};
for(int i = 0; i < a4.length; i++)
for(int j = 0; j < a4[i].length; j++)
prt("a4[" + i + "][" + j +
"] = " + a4[i][j]);
Integer[][] a5;
a5 = new Integer[3][];
for(int i = 0; i < a5.length; i++) {
a5[i] = new Integer[3];
for(int j = 0; j < a5[i].length; j++)
a5[i][j] = new Integer(i*j);
}
for(int i = 0; i < a5.length; i++)
for(int j = 0; j < a5[i].length; j++)
prt("a5[" + i + "][" + j +
"] = " + a5[i][j]);
}
} ///:~
238 Thinking in Java www.BruceEckel.com
以上程式碼列印時用了length，所以程式碼不受限於特定array 大小。
第一個例子說明多維的primitives(基本型別的)array。你可以用成對大
括號來劃分array 中的諸向量：
int[][] a1 = {
{ 1, 2, 3, },
{ 4, 5, 6, },
};
每一組中括號都代表array 的不同層級。
第二個例子示範以new 配置一個三維array。在這裡，整個array 的配置
動作一次完成：
int[][][] a2 = new int[2][2][4];
第三個例子示範「array 之中形成整個矩陣的那些向量可以是任意長度」
(譯註：也就是說Java 的二維array 不見得是矩形，可以是三角形；三維
array 也不見得是長方體)
int[][][] a3 = new int[pRand(7)][][];
for(int i = 0; i < a3.length; i++) {
a3[i] = new int[pRand(5)][];
for(int j = 0; j < a3[i].length; j++)
a3[i][j] = new int[pRand(5)];
}
其中第一個new 生成一個array，其第一維元素長度由亂數決定，剩餘部
份未知。for 迴圈中的第二個new 會填滿第二維元素。直到執行第三個
new，第三個索引值才告確定。
你可以從輸出結果觀察到，如果沒有明確給定array 的元素值，它們會被
自動初始化為零。
你可以使用類似手法處理非基本型別的objects array。第四個例子便是用
來示範這一點。此例同時也說明了，透過成對大括號，將多個new 算式組
織在一起的能力：
Integer[][] a4 = {
Chapter 4: Initialization & Cleanup 239
{ new Integer(1), new Integer(2)},
{ new Integer(3), new Integer(4)},
{ new Integer(5), new Integer(6)},
};
第五個例子示範如何一步一步打造非基本型別的objects array：
Integer[][] a5;
a5 = new Integer[3][];
for(int i = 0; i < a5.length; i++) {
a5[i] = new Integer[3];
for(int j = 0; j < a5[i].length; j++)
a5[i][j] = new Integer(i*j);
}
其中的i*j 只是為了將某個有趣數值置於Integer 中。
摘要
諸如建構式(constructor)這樣精巧複雜的初始化機制，應該能夠讓你體
會到，程式的初始化行為有多麼重要。stroustrup 當初設計C++ 時，對
於生產力所做的第一項觀察便是： 有極大比例的編程問題來自於對變數
的不適當初始化。這類臭蟲很難找出來。相同問題也源自不適當的清理行
為。由於建構式讓你得以保證執行起適當的初始化動作和清理動作(編譯
器不允許你在未呼叫適當建構式之前產生物件)，所以你可以取得完全
的控制，也可以獲得安全保障。
在C++ 中，解構動作格外重要，因為經由new 所產生的物件必須被明確
加以摧毀。但由於Java 的垃圾回收器會自動釋放無用的物件所佔據的記憶
體空間，因此Java 裡頭大多數時候並不需要同等效果(作為清理之用)的
函式。在那些不需要解構式的場合，Java 垃圾回收器大幅簡化了編程手
續，而且在記憶體管理上增加了更為迫切的安全性。某些垃圾回收器甚至
可以清理其他如繪圖資源和file handles 之類的資源。不過，垃圾回收器也
增加了執行期成本。付出的代價很難清楚描述，因為本書撰寫之際，整個
Java 直譯器到處充斥著緩慢因子。如果這點能夠改變，我們便有能力判斷
240 Thinking in Java www.BruceEckel.com
垃圾回收器所帶來的額外負擔是否真的不利於「將Java 應用於一般類型的
程式身上」。(一個大問題便是：垃圾回收器具有不可預測的特性)
由於所有的物件都保證會被建構，所以和建構式有關的事物相當多，實際
上多過本章所提的說明。具體而言，當你運用複合技術(composition)或
繼承技術(inheritance)來產生新classes，前述的建構保證依舊成立，但
這時候得有某些額外語法加入，以便提供支援。你會在接下來的章節中學
到複合和繼承，以及它們對建構式產生的影響。
練習
某些經過挑選的題目，其解答置於《The Thinking in Java Annotated Solution Guide》電子文件中。
僅需小額費用便可自www.BruceEckel.com.網站取得。
1. 撰寫一個帶有default 建構式(亦即不接收任何引數)的class，並
在其中列印某些訊息。請為此class 產生一些物件。
2. 請為上題中的class 增加一個多載化建構式，令它接收一個String
引數，並印出你所提供的訊息。
3. 請為題2 的class 產生一個object references array，但不需實際產
生物件來附著於array。執行此程式時，請注意建構式中的初始化
訊息有沒有被列印出來。
4. 繼續題3 的內容，產生一些物件，將它們附著於references array。
5. 產生String objects array，並為每個元素指派一個字串。以for 迴
圈將所有內容印出來。
6. 產生一個名為Dog 的class，具有多載化的bark()。此一函式應根
據不同的基本資料型別進行多載化，並根據被呼叫的版本，印出不
同類型的狗吠(barking)、咆哮(howling)等訊息。撰寫main()
來呼叫所有不同版本。
Chapter 4: Initialization & Cleanup 241
7. 修改題6 程式，讓兩個多載化函式都有兩個引數(型別不同)，但
二者順序恰好相反。請檢驗其運作方式。
8. 撰寫不帶建構式的class，並在main() 中產生其物件，驗證所謂
default 建構式是否真的被編譯器自動合成出來。
9. 撰寫具有兩個函式的class，在第一個函式內呼叫第二個函式兩次：
第一次呼叫時不使用this，第二次呼叫時使用this。
10. 撰寫具有兩個(多載化)建構式的class，並在第一個建構式中透過
this 呼叫第二個建構式。
11. 撰寫具有finalize() 的class，並在其中列印訊息。請在main()
中針對該class 產生一個物件。試解釋這個程式的行為。
12. 修改題11 的程式，讓你的finalize() 絕對會被呼叫。
13. 撰寫名為Tank 的class，此class 的狀態可以是滿的(filled)或空
的(emptied)。其死亡條件(death condition)是：物件被清理
時必須處於空狀態。請撰寫finalize() 以檢驗死亡條件是否成立。
請在main() 中測試Tank 可能發生的幾種使用方式。
14. 撰寫一個class，內含未初始化的int 和char，印出其值以檢驗
Java 的預設初始化動作。
15. 撰寫一個class，內含未初始化的String reference。證明這個
reference 會被Java 初始為null。
16. 撰寫一個class，內含一個String 欄位，在定義處初始化，另一個
String 欄位由建構式初始化。這兩種方法有什麼分別？
17. 撰寫一個class，擁有兩個static String 欄位，其中一個在定義處
初始化，另一個在static block 中初始化。現在，加入一個static
函式用以印出兩個欄位值。請證明它們都會在被使用之前完成初始
化動作。
242 Thinking in Java www.BruceEckel.com
18. 撰寫一個class，內含String 欄位，並採用「instance(實體)初
始化」方式。試描述此一性質的用途(請提出一個和本書所言不同
的用途)。
19. 撰寫一個函式，能夠產生二維的double array 並加以初始化。
array 的容量由函式的引數決定，其初值必須落在函式引數所指定
的上下限之間。撰寫第二個函式，印出第一個函式所產生的
array。試著在main() 中透過這兩個函式產生不同容量的array，
並列印其內容。
20. 重複題19，但改為三維array。
21. 將本章中的ExplicitStatic.java 內部標示(1) 的程式行註解起
來，並驗證「靜態初始化子句」並未被喚起。然後再將標示為(2)
的其中一行程式碼解除註解，並驗證「靜態初始化子句」的確被呼
叫了。最後再將標示為(2) 的另一行程式碼解除註解，並驗證「靜
態初始化子句」只會執行一次。
22. 在Garbage.java 實驗中，以三個不同的引數"gc"、"finalize"、
"all" 分別執行該程式。重複多次，看看你是否能從輸出結果中看出
什麼固定模式。接下來請改變程式碼， 讓System.run-
Finalization() 在System.gc() 之前被呼叫，並觀察結果。
243
5: 隱藏實作細目
Hiding the Implementation
讓變動的事物與不變的事物彼此隔離，是物件導向設計
(OOD)的首要考量。
這對程式庫(library)來說尤其重要。程式庫必須搏得其使用者(即客戶
端程式員，client programmer)的信賴。程式員必須確認，即使程式庫釋
出了新版本，他們亦無需改寫程式碼。從另一方面說，程式庫開發者在不
影響客端程式員的程式碼的情況下，必須擁有修改與強化的自由。
只要透過約定，便可達成上述目的。例如，更動程式庫內的classes 時，程
式庫開發者必須遵守「不刪去任何既有函式」的約定，因為這麼做將使客
端程式碼無法正常運作。另一部份更為棘手：就資料成員而言，程式庫開
發者如何才能夠知道，究竟哪些資料成員已被客端程式員取用？對那些
「僅是class 實作細目中的一部份，因而不想讓客端程式員直接使用」的函
式來說，情形亦同。如果程式庫開發者想捨棄舊有的實作方式，採用全新
實作細目，情況又當如何？要知道，對那些成員的任何更動，都可能造成
客端程式碼無法正常運作。程式庫開發者將因此動彈不得，無法改變(強
化)任何東西。
為了解決上述問題，Java 提供了存取權限飾詞(access specifiers)，讓程
式庫開發者得以指明哪些成員可供客端程式員取用。存取權限控制等級，
從最寬鬆到最嚴格，依序為public、protected、friendly(不指定關鍵
字)以及private。依據前一段文字，你可能會認為，做為一個程式庫設
計者，你會希望儘可能讓每個成員都是private，而且僅對外公開你希望
客端程式員使用的成員。完全正確！當然啦，這對那些使用其他程式語言
(尤其是C)並且毫無限制取用每樣事物的人來說，十分違反直覺。但是
當本章結束，你應該不會對Java 提供的「存取權限控制」的價值再有任何
懷疑。
244 Thinking in Java www.BruceEckel.com
不過，組件程式庫(components library)的概念，以及「誰有資格取用其
中組件」等概念都尚未完備。組件究竟應該如何結合，以形成具有內聚力
的程式庫單元，至今尚有許多問題還待解決。Java 係透過關鍵字package
加以控制，而存取權限會受到「class 是否位於同一個package，或位於另
一個package」的影響。因此本章一開始，你會先學習如何將程式庫組件
置入packages 中，接下來便能夠學習「存取權限飾詞」的全面意義。
package:程式庫單元(library unit)
當你使用關鍵字import 匯入整個程式庫，例如：
import java.util.*;
你取用的便是所謂的package。這種寫法會將Java 標準公用程式庫
( utility library ， 也就是java.util ) 整個引入。舉個例子， class
ArrayList 位於java.util 內， 所以你可以選擇指定其全名
java.util.ArrayList(如此便無需動用上述的import 述句)，或是在寫
過import 述句之後，簡短寫成ArrayList。
如果你只想引入單一class，也可以在import 述句中指定該class 名稱：
import java.util.ArrayList;
那麼，不需要在ArrayList 之前另加飾詞便可直接使用(譯註：這裡所謂
飾詞是指java.util，用來指定package 名稱)。不過，這麼一來就無法直
接使用java.util 內的其他classes。
此類匯入(importing)動作的存在理由，是為了提供命名空間(name
spaces)的管理機制。所有class 成員名稱皆被相互隔絕。class A 的函式
f()，其名稱不會和class B 中具有相同標記式(signature)的f() 相衝
突。但是class 名稱衝突的問題又要如何解決呢？如果你所開發的stack
class，被安裝在某一台機器，而其上已裝有他人撰寫之stack class，不就
遇上名稱衝突的問題了嗎？由於Java 被用於網際網絡，在Java 程式執行
過程中，classes 會被自動下載，所以在使用者完全不知道的情況下這還是
有可能發生的。
Chapter 5: Hiding the Implementation 245
這一類可能發生的名稱衝突問題，正是Java 必須全面掌控命名空間的原
因，也正是Java 必須不受internet 特質限制而有能力產生獨一無二命名的
重要原因。
截至目前，本書大多數範例都存於單一檔案中，並設計用於本機(local)
端，因而尚未遭遇package 命名困擾。這種情況下，class 的名稱被置於
default package 中。這當然也是一種選擇，而且基於簡化原則，即便到了
本書末尾，仍有可能採用這種方式。不過當你希望你所開發的Java 程式能
和同一台機器上的其他Java 程式和平共處時，你便得思考如何杜絕class
的名稱衝突。
當你產生Java 原始檔，此檔案通常被稱為編譯單元(compilation unit)
或轉譯單元(translation unit)。每個編譯單元的名稱皆需以.java 作
結，其中只能有一個與檔案同名的public class(大小寫納入考慮，但不
含括副檔名.java)。每個編譯單元只能有一個public class，否則編譯器
不接受。package 之外的世界無法看見該編譯單元內的其餘classes(如果
有的話)，這些classes 主要用來為那個主要的public class 提供支援。
當你編譯.java 檔，你所得到的輸出檔案，名稱恰與.java 檔中的每一個
class 相同，只不過多了副檔名.class。因此，數量較少的.java 檔案編譯
後，能夠得到數量較多的.class 檔。如果你曾有編譯式語言的使用經驗，
也許已經習慣透過編譯器產生所謂中間形式檔(通常是.obj 檔)，再透過
連結器(linker)或程式庫產生器(librarian)，將同為中間形式的檔案結
合起來。但這並非Java 的運作方式。Java 的可執行程式乃是一組.class
檔。Java 的jar 壓縮工具能將眾多.class 檔結合起來並予以壓縮。
246 Thinking in Java www.BruceEckel.com
Java 直譯器(interpreter)負責這些檔案的搜尋、載入、解譯1。
所謂程式庫，其實就是一組class 檔。其中每個檔案都有一個public class
(非強迫，但通常如此)，所以每個檔案都是一個組件(components)。
如果你希望這些組件隸屬同一個群組，便可使用關鍵字package。
當你在檔案起始處這麼寫(注意，package 述句必須是檔案中註解以外的
第一行程式碼)：
package mypackage;
便會讓此編譯單元成為mypackage 程式庫中的一部份。或是說，這麼做
會讓此一編譯單元內的public class，被置於mypackage 這個名稱的保
護傘下。任何人如果想使用該class，必須指定全名，或者使用關鍵字
import 搭配mypackage。請注意，Java package 的命名習慣是全部採
用小寫字母，即使居中字詞也不例外。
假設上例的檔案名為MyClass.java。這意謂其中可以有(且僅能有)唯
一一個public class，且其名稱一定得是MyClass(注意大小寫)：
package mypackage;
public class MyClass {
// . . .
現在，如果有人想使用MyClass，或mypackage 內的其他public
classes，他們必須使用關鍵字import，方能運用mypackage 內的其他
名稱，否則便得指定完整名稱。
mypackage.MyClass m = new mypackage.MyClass();
1 Java 並不強迫你一定得用直譯器。有些Java 原生碼編譯器(native-code compiler)，能
產生單一可執行檔。(譯註：原生碼編譯器產生出來的可執行檔，將失去跨平台執行能力)
Chapter 5: Hiding the Implementation 247
關鍵字import 可以造成比較簡潔的效果：
import mypackage.*;
// . . .
MyClass m = new MyClass();
身為程式庫的設計者，你應該明白，關鍵字package 和import 所提供
的，乃是將單一全域命名空間加以切割，使得無論多少人使用internet，
無論多少人撰寫Java classes，都不會發生命名衝突問題。
獨一無二的package 命名
你可能已經觀察到，由於package 並非真的將.class 檔包裝成單一檔案，
而是可能由許多.class 檔組成，這麼一來便有可能造成混亂。為了杜絕混
亂，一個符合邏輯的作法是將package 中的所有.class 檔置於單一目錄
下。也就是透過作業系統階層性的檔案結構來解決。這是一種解決方式，
稍後介紹jar 工具時，你會見到另一種解決方式。
將package 涵括的所有檔案都置於同一磁碟目錄下，必須先解決另外兩個
問題：如何產生獨一無二的package 名稱，以及如何找出可能藏於目錄結
構某處的classes。正如第二章所說，將.class 檔案所在的路徑位置編寫成
package 名稱，便解決了上述問題。編譯器會強迫這樣做，不過習慣上我
們會以class 開發者的internet 域名(的相反順序)做為package 名稱的
第一部份。由於域名絕對獨一無二，所以如果你依循此一習慣，便保證你
所命名的package 絕對獨一無二，不會有名稱上的衝突(除非你將域名轉
讓給他人，而對方使用你過去所使用的相同路徑名稱來撰寫Java 程式
碼)。當然，如果你沒有自己的域名，就得自行產生一組不可能與他人重
複的package 名稱。如果你打算公開釋出自己的Java 程式碼，付出一點點
代價取得一個專屬域名，是相當值得的。
上述技巧的第二部份，便是將package 名稱分解為你的機器上的磁碟目錄
名稱。於是每當Java 程式執行並需要載入.class 檔時(一旦程式有必要
產生class 物件，或首次存取class static 成員時便會動態進行之)，便可
以找出.class 檔案所在的目錄位置。
248 Thinking in Java www.BruceEckel.com
Java 直譯器( interpreter ) 的處理方式如下。首先找出環境變數
CLASSPATH(此乃透過作業系統加以設定。Java 或Java 相關工具的安裝
程式也可能為你設定)。CLASSPATH 含有一個或多個目錄，每個目錄被
視為.class 檔的搜尋起點。Java 會從這個起點開始，並將package 名稱
中的每個句點替換為斜線( 於是package foo.bar.baz 變成
foo\bar\baz 或foo/bar/baz - 依作業系統而有不同)，以獲得在
CLASSPATH 起點下的路徑名稱。得出的路徑會接續於CLASSPATH 的各
個項目之下(譯註：不同的項目以分隔字元區分之，每個項目都代表一個
磁碟目錄。分隔字元隨作業系統而有不同)。這些路徑名稱便是直譯器搜
尋你所產生的.class 的地點。直譯器也會搜尋它自己所在位置下的某些標
準目錄。
以我的域名bruceeckel.com 為例，我來做一些更清楚的解說。將我的域
名反轉得到com.bruceeckel，這便成了我所開發的classes 的一個舉世
唯一的名稱。.com、edu、org 等名稱原本在Java package 中是大寫的。
不過Java 2 之後，package 的完全名稱已經改為全部小寫。假設我決定產
生一個名為simple 的程式庫，於是我更進一步細分此一名稱，獲得的
package 名稱是：
package com.bruceeckel.simple;
現在，這個package 名稱便可在下列兩個檔案中，做為命名空間保護傘：
//: com:bruceeckel:simple:Vector.java
// Creating a package.
package com.bruceeckel.simple;
public class Vector {
public Vector() {
System.out.println(
"com.bruceeckel.util.Vector");
}
} ///:~
Chapter 5: Hiding the Implementation 249
當你開發自有的packages 時你會發現，package 述句必須是檔案中註解
以外的第一行程式碼。第二個檔案看起來極為相似：
//: com:bruceeckel:simple:List.java
// Creating a package.
package com.bruceeckel.simple;
public class List {
public List() {
System.out.println(
"com.bruceeckel.util.List");
}
} ///:~
上述兩個檔案皆被我置於我的系統上的同一個子目錄下：
C:\DOC\JavaT\com\bruceeckel\simple
如果你沿著此一目錄位置往回看， 你會看到package 的名稱
com.bruceeckel.simple，可是路徑名稱前的那一部份呢？那一部份由
CLASSPATH 環境變數負責，在我的機器上其值為：
CLASSPATH=.;D:\JAVA\LIB;C:\DOC\JavaT
你看到了，CLASSPATH 之中可以含括多個不同的搜尋路徑。
當我們改用JAR 檔時，情形又有不同。你得將JAR 檔名(而不僅只是它所
在的位置)於CLASSPATH 環境變數中註明清楚。所以，對grape.jar 來
說，你的CLASSPATH 應該含括：
CLASSPATH=.;D:\JAVA\LIB;C:\flavors\grape.jar
妥善設定CLASSPATH 之後，以下程式檔可置於任何目錄之下而正常運
作：
//: c05:LibTest.java
// Uses the library.
import com.bruceeckel.simple.*;
public class LibTest {
250 Thinking in Java www.BruceEckel.com
public static void main(String[] args) {
Vector v = new Vector();
List l = new List();
}
} ///:~
當編譯器面對import 述句時，它會先搜尋CLASSPATH 所指定的目錄，
檢視子目錄com\bruceeckel\simple 下的內容，找出檔名吻合的已編譯檔
(對Vector 來說是Vector.class，對List 來說是List.class)。請注
意，Vector、List classes 以及其中欲被使用的函式，都必須是public。
CLASSPATH 的設定，對Java 初學者而言是一件棘手的事(至少當初對我
而言確是如此)。所以Sun 讓Java 2 的JDK 更聰明一些。你會發現，在
你安裝之後，即使完全沒有設定CLASSPATH，你仍然能夠編譯基本的
Java 程式，並且加以執行。不過，如果想編譯並執行本書所附的一套原始
碼(可從本書所附光碟或於www.BruceEckel.com 網站取得)，你仍須稍
加修改CLASSPATH(本套原始碼中亦有相關說明)。
衝突
如果兩個程式庫皆以* 形式匯入，而且具有相同名稱，會發生什麼事情？
例如，假設有個程式這麼寫：
import com.bruceeckel.simple.*;
import java.util.*;
由於java.util.* 也含有Vector class，所以這可能導致衝突。不過，只要
你沒有真的寫出實際引發衝突的程式碼，一切都會相安無事- 這是好事，
不然你可能會得鍵入許多字才能阻止所有衝突發生。
但如果你現在嘗試產生一個Vector，便會引發衝突：
Vector v = new Vector();
此行所取用的究竟是那個Vector class？編譯器無從得知，讀者亦無從得
知。所以編譯器會發出錯誤訊息，強迫你明確指出其名稱。如果我想使用
的是標準的Java Vector，我就得這麼寫：
Chapter 5: Hiding the Implementation 251
java.util.Vector v = new java.util.Vector();
這種寫法(配合CLASSPATH)能夠完全指出該Vector 的所在位置。除
非我還需要另外使用java.util 中的其他東西，否則無需寫出述句import
java.util.*。
自訂一個程式庫
有了以上認識，現在你可以開發自己專屬的工具程式庫來降低或消除重複
的程式碼。例如下面這個class 能夠產生System.out.println() 的一個別
名，減少打字負擔。這個class 可做為tools package 的一部份：
//: com:bruceeckel:tools:P.java
// The P.rint & P.rintln shorthand.
package com.bruceeckel.tools;
public class P {
public static void rint(String s) {
System.out.print(s);
}
public static void rintln(String s) {
System.out.println(s);
}
} ///:~
你可以使用這個便捷的工具來列印String，無論需要換行(P.rintln())
或是不需換行(P.rint())。
你大概可以猜出，此檔所在的目錄位置，必定以CLASSPATH 中的某個目
錄為首，然後接續com/bruceeckel/tools。編譯之後，P.class 便可透
過import 述句被任何一個程式使用：
//: c05:ToolTest.java
// Uses the tools library.
import com.bruceeckel.tools.*;
public class ToolTest {
public static void main(String[] args) {
P.rintln("Available from now on!");
P.rintln("" + 100); // Force it to be a String
252 Thinking in Java www.BruceEckel.com
P.rintln("" + 100L);
P.rintln("" + 3.14159);
}
} ///:~
請注意，只要置於String 算式之中，所有物件都可輕易被強迫轉成
String 形式；上例以空的String 為首的算式，正是這種手法。這引出了
另一個有趣的觀察：如果你呼叫System.out.println(100)，它並不會
將100 轉成String。由於某種額外的重載(overloading)行為，你可以
讓P class 有這樣的表現(這是本章末尾的習題之一)。
從現在開始，當你完成某個有用的工具程式，便可把它加至tools 目錄
中，或是你自己私人的util 或tools 目錄中。
利用imports 來改變行為
Java 並不具備C 的「條件編譯(conditional compilation)」功能。此功
能讓你得以切換開關，令程式產生不同行為，無需更動程式碼。Java 拿掉
這個功能的原因，可能是因為此功能在C 語言中多半被用來解決跨平台問
題，也就是根據不同的平台編譯程式碼中的不同部份。由於Java 本身的設
計可自動跨越不同平台，所以應該不需要此功能。
不過條件編譯仍具有其他實用價值。除錯便是常見的用途之一：在開發過
程中開啟除錯功能， 在出貨產品中關閉除錯功能。Allen Holub
(www.holub.com)提出了以packages 來模擬條件編譯的想法。根據這
一想法，他在Java 裡頭產生原本在C 語言中極為有用的assertion 機制。
憑藉此一機制，你可以宣告「這應該是true」或「這應該是false」。一旦
某個述句不符合你所宣告的真偽狀態，你便會發現它。這樣的工具在除錯
過程中相當實用。
下面便是你可以用來協助除錯的class：
//: com:bruceeckel:tools:debug:Assert.java
// Assertion tool for debugging.
package com.bruceeckel.tools.debug;
Chapter 5: Hiding the Implementation 253
public class Assert {
private static void perr(String msg) {
System.err.println(msg);
}
public final static void is_true(boolean exp) {
if(!exp) perr("Assertion failed");
}
public final static void is_false(boolean exp){
if(exp) perr("Assertion failed");
}
public final static void
is_true(boolean exp, String msg) {
if(!exp) perr("Assertion failed: " + msg);
}
public final static void
is_false(boolean exp, String msg) {
if(exp) perr("Assertion failed: " + msg);
}
} ///:~
這個class 只是封裝了Boolean 檢驗動件，並在檢驗失敗時列印錯誤訊息。
你會在第10 章學到更複雜的錯誤處理工具，該工具稱為「異常處理
(exception handling)」。此刻，perr() 便足夠我們用的了。
上述class 的輸出結果會因為「將訊息寫至System.err」而列印於主控台
(console)標準示誤串流(standard error)中。
如果你想使用這個class，可以在程式中加入此行：
import com.bruceeckel.tools.debug.*;
如果你想於出貨時取消這個assertions 功能，可以開發第二個Assert
class，並將它置於另一個不同的package 中：
//: com:bruceeckel:tools:Assert.java
// Turning off the assertion output
// so you can ship the program.
package com.bruceeckel.tools;
public class Assert {
public final static void is_true(boolean exp){}
254 Thinking in Java www.BruceEckel.com
public final static void is_false(boolean exp){}
public final static void
is_true(boolean exp, String msg) {}
public final static void
is_false(boolean exp, String msg) {}
} ///:~
現在，如果你將先前的import 述句改為：
import com.bruceeckel.tools.*;
程式就不再印出assertions 訊息了。以下即為一例：
//: c05:TestAssert.java
// Demonstrating the assertion tool.
// Comment the following, and uncomment the
// subsequent line to change assertion behavior:
import com.bruceeckel.tools.debug.*;
// import com.bruceeckel.tools.*;
public class TestAssert {
public static void main(String[] args) {
Assert.is_true((2 + 2) == 5);
Assert.is_false((1 + 1) == 2);
Assert.is_true((2 + 2) == 5, "2 + 2 == 5");
Assert.is_false((1 + 1) == 2, "1 +1 != 2");
}
} ///:~
改而匯入不同的package，你便可以將程式碼從除錯版改為出貨版。這個
技巧可用於任何類型的條件編譯程式碼上。
使用package 的一些忠告
當你產生package 時，在給定package 名稱後，即隱隱指定了某個目錄結
構。這個package 必須置於其名稱所指的目錄之中。從CLASSPATH 所含
括的目錄出發，必須能夠搜尋至此目錄。開始學習運用關鍵字package
時，結果可能令人有點沮喪。因為除非你遵守「package 名稱對應至目錄
路徑」的規則，否則會得到許多不可思議的執行期錯誤訊息，告訴你無法
尋得某些特定classes - 即使它們其實位於同一目錄中。如果你得到類似
Chapter 5: Hiding the Implementation 255
訊息，請試著將package 述句註解掉。如果這麼做便可執行的話，你就知
道問題出在哪裡了。
Java 存取權限飾詞(access specifiers)
Java 存取權限飾詞public、protected、private 應該置於class 內的每
個成員的定義式前，無論此成員究竟是資料成員或函式。每個飾詞僅控制
它所修飾的那一份定義的存取權限。這和C++的存取權限飾詞形成明顯對
比。在C++中，存取權限飾詞控制著緊接於其後的所有定義式，直到另一
個存取權限飾詞出現。
每一樣東西都需要被指定某種存取權限。接下來各節中，你會學到各類存
取權限。
“Friendly”(友善的)
本章之前的所有程式範例，都沒有給定任何存取權限飾詞，那麼會發生什
麼事呢？雖然預設的存取權限不需要任何關鍵字，但通常被稱為friendly。
意思是同一個package 內的其他所有classes 都可以存取friendly 成員，但
對package 以外的classes 則形同private。由於一個編譯單元(檔案)僅
能隸屬於一個package，所以同一編譯單元內的所有classes 都視彼此為
friend。也因此friendly 存取權限又稱為package 存取權限。
friendly 存取權限讓你得以將相關的classes 置於同一個package 中，使它
們之間得以輕易進行互動。當你將classes 置於某個package(授予相互存
取friendly 成員的權力，也就是使它們成為朋友)，你等於「擁有」該
package 內的程式碼。「只有你自己的程式碼，才可以友善地存取你所擁
有的其他程式碼」這種想法是合理的。可以說，在「將classes 置於同一個
package」這件事情上面，friendly 存取權限給了很好的目的或理由。許多
程式語言對於「如何將各檔案中的定義組織起來」的處理方式可能極為混
亂，但Java 強迫你以合理的方式加以組織。此外，你或許會想排除那些
256 Thinking in Java www.BruceEckel.com
「不應存取目前package 內的classes」的一些classes。
class 手握「讓誰誰誰具有存取我的成員的權限」的鑰匙。其他classes 不
能憑空得到存取權限。其他package 的程式碼不能一現身就說：「嗨，我
是Bob 的朋友！」然後就希望看到Bob 的protected、friendly、
private 成員。如果想要對外授予某個成員的存取權限，唯一的方法是：
1. 宣告該成員為public。那麼任何人在任何地方皆得以存取之。
2. 不加任何存取權限飾詞，使該成員成為friendly，並將其他classes
置於同一個package 內，於是其他classes 便可存取該成員。
3. 就如第6 章即將見到的，當我們引入繼承關係，繼承下來的class 能
夠存取protected 成員(但不含括private 成員)，就和存取
public 成員一樣。只有當兩個classes 位於同一個package 時，才
能存取對方的friendly 成員。不過此刻毋需擔憂此事。
4. 提供「存取式(accessor ) /變異式(mutator )」(也被稱為
"get/set" 函式)，藉以取值和設值。就OOP 來說，這是最進步的方
式，也是JavaBeans(第13 章介紹)的根基所在。
public: 介面存取(interface access)
當你使用關鍵字public，代表「緊接於public 之後的成員將可為每個人
所用」，特別是對於此一程式庫的使用者(客端程式員)。假設你定義了
名為dessert 的package，它含有以下編譯單元：
//: c05:dessert:Cookie.java
// Creates a library.
package c05.dessert;
public class Cookie {
public Cookie() {
System.out.println("Cookie constructor");
}
void bite() { System.out.println("bite"); }
} ///:~
Chapter 5: Hiding the Implementation 257
請務必記得，Cookie.java 必須置於c05(代表本書第5 章)目錄下的
dessert 子目錄中，而c05 亦必須位於CLASSPATH 所列的某一個目錄
下。千萬別誤以為Java 一定會將目前所在目錄做為搜尋起點之一。如果你
沒有將'.'(譯註：目前所在目錄)含括在你的CLASSPATH 中，Java 便不
會把目前所在目錄當做搜尋起點。
現在，如果你撰寫某個程式並在其中使用Cookie：
//: c05:Dinner.java
// Uses the library.
import c05.dessert.*;
public class Dinner {
public Dinner() {
System.out.println("Dinner constructor");
}
public static void main(String[] args) {
Cookie x = new Cookie();
//! x.bite(); // Can't access
}
} ///:~
你便可以產生Cookie 物件，因為Cookie 的建構式是public 而其本身
也是public(稍後我們將學到更多關於public class 的觀念)。不過
Dinner.java 之中無法取用bite()，因為bite() 的存取權限是friendly，
僅供package dessert 內部取用。
default(預設的)package
你可能會很驚訝地發現，下面的程式碼竟然可以順利編譯，即便有些地方
並不遵守規則：
//: c05:Cake.java
// Accesses a class in a
// separate compilation unit.
class Cake {
public static void main(String[] args) {
Pie x = new Pie();
x.f();
}
258 Thinking in Java www.BruceEckel.com
} ///:~
第二個檔案位於同一目錄中：
//: c05:Pie.java
// The other class.
class Pie {
void f() { System.out.println("Pie.f()"); }
} ///:~
一開始你可能會將上述兩個檔案視為完全無關的檔案，但Cake 卻能夠產
生Pie 物件並呼叫其f()！(請注意，如果想編譯這些檔案，你得將'.' 加
至你的CLASSPATH 環境變數中)。你會很自然地認為Pie 和f() 的存取
權限是friendly，因此不可被Cake 所用。是的，它們的確是friendly。
Cake.java 之所以可以存取它們，原因是它們位於同一個目錄中，而且沒
有為自己設定任何package 名稱。Java 會自動將這兩個檔案視為隸屬於該
目錄的所謂default package 中，因此對同目錄下的其他檔案來說，它們都
是friendly。
private: 不要碰我！
關鍵字private 表示「除了當事人(某個成員)所在的class，沒有任何人
可以存取這個成員」。即使是同一個package 內的其他classes，也無法存
取你的private 成員。這種宣告方式無異隔離自己。但是從另一個角度
說，多人協力開發同一個package 的情況並非不可能，因此，private 讓
你得以自由更動你的成員，無需擔心這麼做是否影響同一個package 下的
其他class。
預設的friendly 存取權限(或稱package 存取權限)通常已經足以提供堪
用的隱藏性質；請記住，package 的使用者無法取用friendly 成員。這是好
事，因為所謂預設的存取權限，應該是你在正常情況下使用的存取權限
(也是忘了加上任何飾詞時會生效的存取權限)。因此通常你會特別思考
的是「希望明確開放給客端程式員使用」的一些成員，並將它們宣告為
public。一開始你可能不認為你會時常用到private 關鍵字，因為少了它
Chapter 5: Hiding the Implementation 259
還是可以的(這和C++形成明顯對比)。不過事實證明，private 極為重
要，尤其在多緒環境下(multithreading，詳見第14 章)。
下面是private 的使用範例：
//: c05:IceCream.java
// Demonstrates "private" keyword.
class Sundae {
private Sundae() {}
static Sundae makeASundae()
return new Sundae();
}
}
public class IceCream {
public static void main(String[] args) {
//! Sundae x = new Sundae();
Sundae x = Sundae.makeASundae();
}
} ///:~
這個例子說明了private 終有其用：您可能會想控制物件的生成方式，並
且不允許其他人直接取用某個特定建構式(或所有建構式)。上例中你無
法透過Sundae 的建構式來產生物件，你得呼叫makeASundae()，讓
它來為你服務2。
只要你確信某些函式對class 而言只扮演「後勤支援」性質，你都可以將它
們宣告為private，以確保不會在同一個package 的其他地方誤用到它
們， 而自己又能保有更動、甚至刪除的權力。將某個函式宣告為
private，可保證你自己仍握有決定權。
對於class 內的private 資料成員而言，情形亦同。除非你想曝露底層實作
細目(這是一種很難想像的罕見情境)，否則您應該讓所有的資料成員都
2 此處還會產生其他效應。因為我們僅定義default 建構式，而它又是private，所以這麼
做同時也杜絕了以此class 為根源的繼承行為(詳見第6 章)。
260 Thinking in Java www.BruceEckel.com
成為private。不過，在class 中令某個物件的reference 為private，並
不代表其他物件無法擁有該物件的public reference。請參考附錄A 中關
於aliasing(別名)的種種討論。
protected: 幾分友善
想要了解protected 存取權限，我們得先做點跳躍動作。首先你應該知
道，本書開始介紹繼承機制(第6 章)時，你才需要了解本節內容。但基
於完整性考量，我還是在此處提供protected 的簡要說明和使用範例。
關鍵字protected 所處理的是所謂的「繼承(inheritance)」觀念。在此
觀念中，我們可以將新的成員加到被我們稱為base class(基礎類別)的既
有class 中，而無需碰觸base class。你也可以改變base class 既有成員的
行為。如果想繼承某個既有的class，你可以讓新class 延伸(extends)
既有的class，就像這樣：
class Foo extends Bar {
至於class 定義式中的其他部份看起來相同。
如果你產生新的package，並且繼承另一個package 中的class，那麼你就
只能存取原先package 中的public 成員(當然啦，如果你是在同一個
package 中施行繼承動作，你將仍舊擁有對所有friendly 成員的一般性
「package 存取權限」。有時候，base class 開發者會希望允許其derived
classes(衍生類別)存取某個特定成員，但不希望所有classes 都有此權
力。這正是protected 的用途。以先前出現的那個Cookie.java 為例，
以下class 將無法存取其friendly 成員：
//: c05:ChocolateChip.java
// Can't access friendly member
// in another class.
import c05.dessert.*;
public class ChocolateChip extends Cookie {
public ChocolateChip() {
System.out.println(
"ChocolateChip constructor");
Chapter 5: Hiding the Implementation 261
}
public static void main(String[] args) {
ChocolateChip x = new ChocolateChip();
//! x.bite(); // Can't access bite
}
} ///:~
關於繼承，最有趣的事情之一便是，如果class Cookie 擁有bite()，那麼
後者也會存在於繼承自Cookie 的所有classes 中。但由於bite() 是另一
個package 中的friendly 函式，所以無法被這些derived classes 取用。你
當然可以將它宣告為public，但這麼一來每個人都可以取用，這可能不是
你想要的。如果我們將class Cookie 改成這樣子：
public class Cookie {
public Cookie()
System.out.println("Cookie constructor");
}
protected void bite() {
System.out.println("bite");
}
}
那麼，在package dessert 中，bite() 仍舊具備friendly 權限，而任何繼
承自Cookie 的classes 亦可加以取用。這和public 並不相同。
Interface(介面)與implementation(實作)
存取權限的控制通常被視為是一種「實作細目的隱藏(implementation
hiding)」。將class 內的資料和處理資料的行為包裝起來，結合實作細目
之隱藏，即是所謂的封裝(encapsulation)3。其結果就是一個兼具特徵
(characteristics。譯註：此處意指資料)和行為的資料型別。
3 即是單單只是實作細目的隱藏，人們也常稱之為封裝。
262 Thinking in Java www.BruceEckel.com
基於兩個理由，我們需要控制存取權限，在資料型別中建立諸般界限。第
一，建立起一道界限，指明哪些是客端程式員可使用的，哪些是他們不可
使用的。於是你便可以將內部機制建於結構之中，無需擔心客端程式員不
小心將僅供內部使用的部份當做他們可使用的一部份介面。
上述原因直接影響了第二個理由- 將介面和實作分離。如果某個結構被用
於一組程式中，而客端程式員除了發送訊息給public 介面(譯註：亦即呼
叫public 函式)，完全無法進行任何動作，那麼你便可以在不修改客端程
式碼的情況下更動所有non-public ( 包括friendly 、protected 、
private)成員。
我們正置身於物件導向編程世界中。在這個世界裡，class 實際上所描述
的是「某一類物件」，就像你描述某一種魚或某一種鳥一樣。任何隸屬於
某個class 的所有物件都具備同樣的特徵(譯註：資料)和行為。所謂
class，就是所有同型物件的外觀長相及行為舉措的描述。
在最原始的物件導向程式語言Simula-67 中，關鍵字class 被用來描述新
的資料型別。這個關鍵字亦被沿用於大多數物件導向程式語言。這種語言
所關注的焦點是：產生一些「不僅只是內含資料和函式」的新資料型別。
Java 中的class 是極為基礎的OOP 觀念。它是本書不以粗體表示的關鍵字
之一，因為對於出現如此頻繁的字來說，以粗體表示實在太煩人了。
為了讓程式更清楚，你可能會喜歡將public 成員置於class 起始處，其後
再接著protected 成員、friendly 成員、private 成員。這種作法的優點
是，class 使用者可以由上而下，先看到對他們來說最為重要的部份(亦即
public 成員，因為它們可於檔案之外被取用)，而在看到non-public 成
員時停下來，因為已經抵達內部實作細節：
public class X {
public void pub1( ) { /* . . . */ }
public void pub2( ) { /* . . . */ }
Chapter 5: Hiding the Implementation 263
public void pub3( ) { /* . . . */ }
private void priv1( ) { /* . . . */ }
private void priv2( ) { /* . . . */ }
private void priv3( ) { /* . . . */ }
private int i;
// . . .
}
但是這種寫法只能稍微增加程式的易讀性，因為介面和實作仍舊混在一
起。也就是說你仍然會看到原始碼(所謂實作部份)，因為它們就在class
之內。此外javadoc 所提供的「寓文件於註解」的功能(第2 章介紹過)
也降低了程式碼可讀性對客端程式員的重要性。將class 介面呈現給其使用
者的責任，其實應該由class browser(類別瀏覽器)擔負起來。這是一種
用以檢閱所有可用之classes，並顯示在它們身上能夠進行什麼動作(亦即
顯示出可用成員)的一種工具。當你閱讀本書時，這類瀏覽器應該已經成
為優良的Java 開發工具中不可或缺的標準配備了吧。
Class 的存取權限
Java 的存取權限飾詞也可以用來決定「程式庫中哪些classes 可以被程式庫
使用者所用」。如果你希望某個class 可被客端程式員所用，你得將關鍵字
public 置於class 主體之左大括號前某處。為classes 而設的存取權限，可
以控制客端程式員是否有權力產生某個class 的物件。
如果你想控制class 的存取權限，飾詞必須置於關鍵字class 之前。因此，
你可以這麼寫：
public class Widget {
現在，如果你的程式庫名為mylib，所有客端程式員都可以經由以下這種
寫法來取用Widget：
import mylib.Widget;
或
import mylib.*;
264 Thinking in Java www.BruceEckel.com
不過，這裡還是存在一些額外限制：
1. 每個編譯單元(檔案)都僅能有一個public class。其中的觀念
是，每個編譯單元都擁有一個由public class 所表現的單一public
介面。當然， 編譯單元內可以存在許多個支援用的friendly
classes。如果編譯單元中的public class 不只一個，編譯器會給你
錯誤訊息。
2. public class 的名稱(含大小寫)必須恰與其編譯單元(檔案)名稱
相符。所以，對Widget 而言，其檔名必須是Widget.java 而不
能是widget.java 或WIDGET.java。如果不是這樣，會出現編譯
錯誤。
3. 雖然通常不會這麼做，但編譯單元內的確可以不含任何public
class。這種情況下，你可以任意給定檔案名稱。
假設你在mylib 中撰寫某個class，僅僅只是為了用它來協助完成Widget
或mylib 內的其他public class 的工作。你不想為了撰寫說明文件給客端
程式員看而傷腦筋，而且你認為一段時間之後，你可能會徹底改變原有作
法並完全捨棄舊版本，以全新版本替代。如果想擁有上述彈性，你得確保
沒有任何客端程式員倚賴mylib 內的特定實作細目。欲達此一目的，只要
拿掉class 的public 飾詞，它就成了friendly(那麼它也就只能用於
package 內部了)。
請注意，class 不能是private(這麼做會使得除了它自己沒有任何class
可加以取用)或protected4。所以，對於class 存取權限，你只有兩個選
擇：friendly 或public。如果你不希望其他任何人取用某個class，請將其
所有建構式宣告為private，這麼一來便可阻止任何人產生其物件，唯有
4 事實上inner class(內隱類別)可以是private 或protected，不過這是特例。詳見第7
章。
Chapter 5: Hiding the Implementation 265
一個例外，那就是在class static 成員中可以辦到5。下面便是一例：
//: c05:Lunch.java
// Demonstrates class access specifiers.
// Make a class effectively private
// with private constructors:
class Soup {
private Soup() {}
// (1) Allow creation via static method:
public static Soup makeSoup() {
return new Soup();
}
// (2) Create a static object and
// return a reference upon request.
// (The "Singleton" pattern):
private static Soup ps1 = new Soup();
public static Soup access() {
return ps1;
}
public void f() {}
}
class Sandwich { // Uses Lunch
void f() { new Lunch(); }
}
// Only one public class allowed per file:
public class Lunch {
void test() {
// Can't do this! Private constructor:
//! Soup priv1 = new Soup();
Soup priv2 = Soup.makeSoup();
Sandwich f1 = new Sandwich();
Soup.access().f();
}
} ///:~
5 你也可以透過繼承(第6 章)辦到。
266 Thinking in Java www.BruceEckel.com
到目前為止，我們所用的大多數函式皆傳回void 或基本型別，因此以下定
義乍見之下令人有點困惑：
public static Soup access() {
return ps1;
}
上述函式名稱(access)之前的字，指出該函式回傳的東西。截至目前，
在我們的例子中，此字常常是void，表示不回傳任何東西。但你也可以回
傳一個object reference，這就是上述式子的作為。上面這個函式所回傳
的，即是一個reference，代表一個class Soup 物件。
class Soup 示範如何將所有建構式都宣告為private 以防止直接產生某
個class 物件。請千萬記住，如果你沒有自行撰寫至少一個建構式，會有一
個default 建構式(不具任何引數的建構式)被自動合成出來。如果我們
撰寫自己的default 建構式，它就不會被自動合成；如果我們讓它成為
private，就沒有任何人能夠產生這個class 的物件。但是這麼一來別人又
該如何使用這個class 呢？上述例子示範了兩種作法，一是撰寫static 函
式來產生新的Soup 並回傳其reference。如果你希望在執行Soup 之前先
進行某些額外處理，或希望記錄(或限制)究竟有多少個Soup 物件被產
生出來，這種作法十分有用。
第二種作法是使用某個設計樣式(design patterns，這個主題涵蓋於
《Thinking in Patterns with Java》書中，可於www.BruceEckel.com 下
載)。這個樣式被稱為"singleton"，因為它讓整個程式面對某個class 時只
能產出唯一一個物件。class Soup 的物件是被Soup 的static private 成
員函式產生出來的，所以恰恰只能有一份。而且，除了透過public
access() 加以存取，別無它法。
如前所述，如果你未指定某個class 的存取權限，預設便是friendly。這表
示同一個package 內的其他classes 能夠生成該class 的物件，而package
之外則否。(請千萬記得，同一目錄中的所有檔案，如果沒有明確的
package 宣告，都會被視為是該目錄的default package。)不過，如果
該class 有某個static public 成員，那麼客端程式員即使無法生成該class
的物件，仍然能夠存取這個static 成員。
Chapter 5: Hiding the Implementation 267
摘要
在任何相互關係中，讓多個參予者共同遵循某些界限，是相當重要的事。
當你開發程式庫時，會建立起和使用者(亦即客端程式員，也就是將你的
程式庫結合至應用程式，或藉以開發更大型程式庫的人)之間的關係。
如果缺乏規範，客端程式員可以對class 的成員進行他們想進行的任何動作
- 即使你可能不希望他們直接操作這些成員。喔，每樣東西都攤在全世界
面前。
本章討論如何將眾多的classes 組成程式庫。首先介紹如何將一組classes
包裝於程式庫中，然後介紹如何控制class 成員的存取權限。
據估計，以C 語言來開發專案，大概發展五萬行至十萬行程式碼時，就會
開始出現問題。因為C 僅有單一命名空間，所以容易發生命名衝突問題，
引發許多額外的管理代價。Java 語言的package 關鍵字、package 命名架
構、import 關鍵字，讓你得以完全掌控命名機制，所以命名衝突的問題
可輕易規避之。
我們之所以要控制成員的存取權限，基於兩個理由。首先，讓使用者無法
碰觸他們不該碰觸的東西；這些東西僅供資料型別內部機制所用，不在
「使用者賴以解決問題」的介面之中。因此，將這些函式和資料成員宣告
為private，對使用者來說是一種服務。使用者可以因此輕易看出，哪些
東西對他們來說是重要的，哪些東西對他們來說可以略而不見。如此一來
便可以減輕他們「認識class」的負擔。
存取權限控制的第二個存在理由，同時也是最重要的理由，就是讓程式庫
設計者可以更動class 內部運作方式，而無需擔心波及客端程式員。一開始
你可能會以某種方式開發class，然後發現如果更改程式結構，可以提高執
行速度。一旦介面和實作可以被明確地加以隔離和保護，此一目標便可達
成，無需強迫程式庫使用者重新改寫程式碼。
268 Thinking in Java www.BruceEckel.com
Java 的「存取權限飾詞」賦予classes 開發者極具價值的控制能力。
classes 使用者可以清楚看出，哪些是他們可以使用的，哪些是他們應該略
而不見的。更重要的是，這能夠確保不存在任何使用者「倚賴class 底層實
作細節」。身為classes 開發者，如果你的任何改變可以完全不干擾你的使
用者，你便可以安心改變你的底層實作，因為客端程式員無法存取class 的
這一部份。
當你擁有改變底層實作的能力，你不僅可以在日後改善你的設計，也擁有
了犯錯的自由。因為不論多麼小心翼翼地規劃和設計，人終究難免犯錯。
當你知道犯下錯誤但相對安全的時候，你便能夠更放心地進行實驗，以更
快的速度學習，並更早完成專案。
class 的公開(public)介面，是使用者看得到的部份。因此在分析與設計
階段，這一部份也是class 正確與否的關鍵。即使如此，你仍對它擁有些許
改變和調整的空間。如果你沒有一開始便製作出正確的介面，你可以於日
後加入額外的函式- 是的，只要不刪去客端程式員已經用於應用程式中的
任何東西，都行。
練習
某些經過挑選的題目，其解答置於《The Thinking in Java Annotated Solution Guide》電子文件中。
僅需小額費用便可自www.BruceEckel.com.網站取得。
1. 撰寫一個程式，在其中產生ArrayList 物件，但不明確匯入
java.util.*。
2. 將標題為「package：程式庫單元(library unit )」一節中與
mypackage 有關的程式碼片段，改寫為一組可編譯、可執行的
Java 檔案。
3. 將標題為「衝突」一節中的程式碼片段，改寫為完整程式，並檢查
實際發生的命名衝突。
4. 將本章所定義的P class 更一般化：加入rint() 和rintln() 的所有
重載版本，使其足以處理所有Java 基本型別。
Chapter 5: Hiding the Implementation 269
5. 改變TestAssert.java 中的import 述句，試著開啟、關閉
assertion 機制。
6. 撰寫一個具有public、private、protected、friendly 等等資料
成員和成員函式的class。為它產生一個物件並進行觀察：當你嘗試
取用所有class 成員時，會產生什麼類型的編譯訊息？注意，位於
同一目錄中的所有classes，都被設定於default package 內。
7. 撰寫一個class，令它具備protected 資料。並在同一個檔案中撰
寫第二個class，為此class 提供函式，使它操作第一個class 的
protected 資料。
8. 改寫標題為「protected：幾分友善」一節中的Cookie。驗證其中
的bite() 並非public。
9. 你可以在標題為「Class 的存取權限」一節中，找到描述mylib 和
Widget 的程式片段。請完成這個程式庫，並撰寫一個不在mylib
package 中的Widget class。
10. 建立一個新目錄，並將它加到你的CLASSPATH 環境變數中。將
P.class 檔(com.bruceeckel.tools.P.java 編譯後的產品)複製
到新目錄，並改變檔案名稱、內部的P class 名稱、及其函式名
稱。你可能會想加入其他輸出訊息，藉以觀看運作方式。在另一個
目錄下撰寫這個新的class 的應用程式。
11. 請你依循範例程式Lunch.java 中的格式， 撰寫一個名為
ConnectionManager 的class，使其能夠管理固定大小的array
中的Connection 物件。請你限制客端程式員，使他們無法自行產
生Connection 物件，只能經由ConnectionManager 的static
函式來獲得這些物件。當ConnectionManager 之中不再存有任
何物件時，便回傳null reference。請在main() 中測試這兩個
classes。
12. 在c05/local 目錄下(這應該記錄於你的CLASSPATH 環境變
數)，建立如下檔案：
///: c05:local:PackagedClass.java
package c05.local;
270 Thinking in Java www.BruceEckel.com
class PackagedClass {
public PackagedClass() {
System.out.println(
"Creating a packaged class");
}
} ///:~
然後在c05 之外的另一目錄中產生如下檔案：
///: c05:foreign:Foreign.java
package c05.foreign;
import c05.local.*;
public class Foreign {
public static void main (String[] args) {
PackagedClass pc = new PackagedClass();
}
} ///:~
請解釋為什麼編譯器會發出錯誤訊息。如果將Foreign class 置於
c05.local package 內，能夠改變什麼嗎？
271
6: 重複運用Classes
Java 有著眾多令人讚嘆的功能，程式碼的重複運用便是其
中之一。但是，如果想獲得革命性的改變，你得遠遠超越
「複製程式碼、然後改變之」的舊有模式。
C 之類的程序性(procedural)語言便採用這種舊方法，但是沒有得到很好
的效果。就像Java 中的所有事物一樣，解決之道圍繞在class 身上。你可
以產生新的classes 來重複運用程式碼，不須重頭寫起。你可以使用某人已
經開發好、除錯完畢的既有classes。
此中秘訣便在於能夠使用既有的classes 而不破壞其程式碼。你會在本章看
到，兩種方法足以達成上述目的。第一種方法十分直觀：在新的class 中產
生既有class 的物件。這種方法稱為「複合(composition)」，或稱組
合，因為新的class 是由既有classes 的物件組成。這種情形只是很單純地
重複運用既有程式碼的功能，而非重複運用其形式。
第二種方法更為精巧，能夠讓新的class 成為既有class 的一類。你可以實
際接收既有class 的形式，並加入新碼，無需更動既有的class。這種神奇
行為被稱為「繼承(inheritance)」，而且編譯器能夠為你完成大部份工
作。繼承是物件導向程式設計的基石之一，第7 章還會探究其深遠意涵。
對複合(composition)和繼承(inheritance)而言，語法及行為大多類似
(這麼做饒富意義，因為二者都是從既有型別產生出新型別)。你可以在
本章之中學到這兩種「程式碼重複運用」的機制。
複合(Composition)語法
本書至此，屢屢使用複合技術。只要將object references 置於新的classes
中即是。假設你想擁有某個物件，它必須能夠儲存多個String 物件、兩三
272 Thinking in Java www.BruceEckel.com
個基本型別資料、以及另一個class 物件。你可以直接定義基本型別資料，
但是對非基本型別的物件來說，你得將其references 置於新的class 內：
//: c06:SprinklerSystem.java
// Composition for code reuse.
class WaterSource {
private String s;
WaterSource() {
System.out.println("WaterSource()");
s = new String("Constructed");
}
public String toString() { return s; }
}
public class SprinklerSystem {
private String valve1, valve2, valve3, valve4;
WaterSource source;
int i;
float f;
void print() {
System.out.println("valve1 = " + valve1);
System.out.println("valve2 = " + valve2);
System.out.println("valve3 = " + valve3);
System.out.println("valve4 = " + valve4);
System.out.println("i = " + i);
System.out.println("f = " + f);
System.out.println("source = " + source);
}
public static void main(String[] args) {
SprinklerSystem x = new SprinklerSystem();
x.print();
}
} ///:~
WaterSource 所定義的函式中，有一個很不同尋常：toString()。稍後
你會學到，每個非基本型別的物件都具備toString()，當編譯器希望得到
一個String，而你手上卻只有那些物件的情況下，這個函式便會被喚起。
所以下列算式：
System.out.println("source = " + source);
Chapter 6: Reusing Classes 273
會讓編譯器知道你企圖將String 物件("source = " )和WaterSource
相加。這對編譯器來說不具意義，因為你只能將String 加至另一個
String。所以編譯器說話了：『我將呼叫toString()，把source 轉為一
個String！』完成這個動作後它便能夠將兩個String 合併在一塊兒，並
將結果傳給System.out.println()。如果你希望你的class 具備這種行
為，只要為它撰寫toString() 即可。
乍見之下你可能會假設編譯器自動為上述程式碼中的每一個references 產
生相應的物件(喔是的，Java 應該表現出安全謹慎的一面)；例如它會呼
叫WaterSource 的default 建構式，將source 初始化。但印出來的結
果卻是：
valve1 = null
valve2 = null
valve3 = null
valve4 = null
i = 0
f = 0.0
source = null
是的，class 之中屬於基本型別的資料欄位，的確會被自動初始化為零，就
如我在第2 章所言。但object references 會被初始為null，而且如果你試
著透過這些reference 呼叫任何函式，會引發異常(exception)。如果可
以印出其內容而不出現異常，對我們來說是好事(而且也很實用)。
編譯器「不為每個reference 產生預設物件」是有意義的，因為這麼做在許
多情況下造成不必要的負擔。如果你希望初始化這些references，你可以
在下列地點進行：
1. 在物件定義處。這表示它們一定能夠在「建構式被呼叫前」完成初
始化動作。
2. 在class 建構式中。
3. 在你實際需要用到該物件的地方。這種方式常被稱為「緩式初始化
(lazy initialization)」。在無需每次都產生物件的場合中，這種
作法可以降低額外負擔。
274 Thinking in Java www.BruceEckel.com
以下例子同時示範了上述三種作法：
//: c06:Bath.java
// Constructor initialization with composition.
class Soap {
private String s;
Soap() {
System.out.println("Soap()");
s = new String("Constructed");
}
public String toString() { return s; }
}
public class Bath {
private String
// Initializing at point of definition:
s1 = new String("Happy"),
s2 = "Happy",
s3, s4;
Soap castille;
int i;
float toy;
Bath() {
System.out.println("Inside Bath()");
s3 = new String("Joy");
i = 47;
toy = 3.14f;
castille = new Soap();
}
void print() {
// Delayed initialization:
if(s4 == null)
s4 = new String("Joy");
System.out.println("s1 = " + s1);
System.out.println("s2 = " + s2);
System.out.println("s3 = " + s3);
System.out.println("s4 = " + s4);
System.out.println("i = " + i);
System.out.println("toy = " + toy);
System.out.println("castille = " + castille);
Chapter 6: Reusing Classes 275
}
public static void main(String[] args) {
Bath b = new Bath();
b.print();
}
} ///:~
注意，Bath 建構式中，有一行述句在任何初始化動作之前執行。如果你未
在定義處進行初始化，那麼就無法保證在你發送訊息給object references
之前能夠進行任何初始化- 反倒是無可避免會發生執行期異常。
以下是這個程式的輸出：
Inside Bath()
Soap()
s1 = Happy
s2 = Happy
s3 = Joy
s4 = Joy
i = 47
toy = 3.14
castille = Constructed
當print() 被呼叫，它會填寫s4 的值。因此所有資料欄位(fields)在它
們被使用之際都已被妥善初始化了。
繼承(Inheritance)語法
繼承是Java(一般而言也是OOP 語言)不可或缺的一個部份。事實上當
你撰寫class 的同時便已進行了繼承。是的，即使沒有明確指出要繼承某個
class，你仍然會繼承Java 的標準根源類別Object。
「複合」語法平淡無奇，「繼承」則必須以截然不同的形式為之。當你進
行繼承，你得宣告「新class 和舊class 是類似的」。和平常一樣，首先給
定class 名稱， 但是在寫下class 主體左大括號前， 先寫下關鍵字
extends，其後緊接著base class(基礎類別)名稱，這樣便完成了繼承宣
告動作。至此便自動獲得了base class 的所有資料成員和成員函式。
276 Thinking in Java www.BruceEckel.com
以下便是一例：
//: c06:Detergent.java
// Inheritance syntax & properties.
class Cleanser {
private String s = new String("Cleanser");
public void append(String a) { s += a; }
public void dilute() { append(" dilute()"); }
public void apply() { append(" apply()"); }
public void scrub() { append(" scrub()"); }
public void print() { System.out.println(s); }
public static void main(String[] args) {
Cleanser x = new Cleanser();
x.dilute(); x.apply(); x.scrub();
x.print();
}
}
public class Detergent extends Cleanser {
// Change a method:
public void scrub() {
append(" Detergent.scrub()");
super.scrub(); // Call base-class version
}
// Add methods to the interface:
public void foam() { append(" foam()"); }
// Test the new class:
public static void main(String[] args) {
Detergent x = new Detergent();
x.dilute();
x.apply();
x.scrub();
x.foam();
x.print();
System.out.println("Testing base class:");
Cleanser.main(args);
}
} ///:~
Chapter 6: Reusing Classes 277
這個程式示範了許多特性。首先，在Cleanser append() 中我以+= 運
算子將String 物件接續於s 之後。+= 運算子是Java 設計者重載後用以處
理Strings 的運算子之一(另一個是"+")。
第二，Cleanser 和Detergent 都含有main()。你可以為每個classes 都
撰寫main()。通常我會建議你以這種方式撰寫程式碼，以便將測試碼包
裝於class 內。不過如果某個程式擁有許多classes，僅有命令列所調用的
那個class 的main() 會被喚起- 這個main() 必須是public，其所屬
class 則無所謂是否為public。在這個例子中，你的命令列可以是java
Detergent，於是Detergent.main() 便被喚起。你也可以鍵入java
Cleanser，於是Cleanser.main() 便被喚起- 即使Cleanser 並非
public class。這種「為每個class 提供main()」的技巧，可以使每個
class 的單元測試(unit testing)更為容易。而且在完成單元測試之後，無
需刪去main()；你可以將它留下以待日後再加測試。
在這裡你可以看到，Detergent.main() 明確呼叫Cleanser.main()，
並將命令列引數原封不動傳過去(當然你也可以傳入任意的String
array)。
這裡有一點很重要：Cleanser 的所有函式都是public。請千萬記得，如
果你未指定成員的存取權限，預設便是friendly，也就是說只能在同一個
package 中加以取用。因此，如果沒有指定存取權限，同一個package 中
的所有classes 皆能使用這些函式。這對Detergent 沒有問題。但是如果
位於另一個package 中的某個class 繼承了Cleanser，它便僅能存取其
public 成員。所以，為了繼承著想，一般原則是將所有資料成員宣告為
private，將所有函式宣告為public(protected 成員也允許讓衍生的
classes 取用，這點稍後馬上會說明)。當然，你得針對特別情況做一些調
整，但上述所言的確是個實用準則。
請注意，Cleanser 的介面含括了一組函式：append()、dilute()、
apply()、scrub()、print()。由於Detergent 衍生自Cleanser(透過
關鍵字extends)，所以它會自動從Cleanser 的介面中取得所有函式。
你可以將繼承視為「介面的重複運用」。實作細目亦隨之繼承而來，但並
非最主要目的。
278 Thinking in Java www.BruceEckel.com
正如scrub() 所顯示，你可以修改定義於base class 中的函式。在這個例
子中，你可能會想要在新版本中呼叫base class 函式。但在scrub() 中你
無法僅僅呼叫scrub() 來達成目的，因為這麼做會產生遞迴- 這不是你
要的。為了解決這個問題，Java 提供了關鍵字super，透過它便可以取用
目前class 所繼承的「superclass(超類別，父類別)」。因此，算式
super.scrub() 會呼叫base class 內的scrub()。
實施繼承時，你不一定非得使用base class 函式不可。你也可以將新的函
式加至derived class，就像將函式加入一般class 沒有兩樣：只要加以定義
即可。foam() 便是一個例子。
在Detergent.main() 中你可以看到，除了Detergent 函式(例如
foam())之外，你也可以呼叫Cleanser 的所有可用的函式。
base class 的初始化
由於現在有兩個classes 牽扯進來(base class 和derived class)，不單只
是一個，所以當你想像derived class 所產生的物件時，可能會感到難以理
解。外界看來，它像是一個具有「和base class 相同介面」的新class，也
許還多了些額外的函式和資料成員。但繼承不單只是複製base class 的介
面而已。當你產生derived class 物件時，其中會包含base class 子物件
(subobject)。這個子物件就和你另外產生的base class 物件一模一樣。
外界看來，base class 子物件被包裝於derived class 物件之內。
當然，將base class 子物件正確地加以初始化，極為重要。只有一種方法
可以保證此事：呼叫base class 建構式，藉以執行建構式中的初始化動
作。base class 建構式具備了執行base class 初始化動作的所有知識和權
力。Java 編譯器會自動在derived class 建構式中插入對base class 建構式
的呼叫動作。以下範例說明此一特性在三層繼承關係上的運作方式：
Chapter 6: Reusing Classes 279
//: c06:Cartoon.java
// Constructor calls during inheritance.
class Art {
Art() {
System.out.println("Art constructor");
}
}
class Drawing extends Art {
Drawing() {
System.out.println("Drawing constructor");
}
}
public class Cartoon extends Drawing {
Cartoon() {
System.out.println("Cartoon constructor");
}
public static void main(String[] args) {
Cartoon x = new Cartoon();
}
} ///:~
這個程式的輸出，說明了前述的「建構式自動被喚起」行為：
Art constructor
Drawing constructor
Cartoon constructor
你可以看到，建構動作會由base class「往外」擴散。所以base class 會在
derived class 建構式取用它之前，先完成本身的初始化動作。
即使你並未撰寫Cartoon() 建構式，編譯器也會為你合成一個default 建
構式，並在其中呼叫base class 的建構式。
280 Thinking in Java www.BruceEckel.com
帶有引數(arguments)的建構式
上例各個classes 都具備default 建構式，也就是說它們都不帶有引數。對
編譯器而言，呼叫它們很容易，因為不需擔心應該傳入什麼引數。但如果
你的class 不具備default 建構式，或如果你想呼叫帶有引數的base class
建構式，你便得運用關鍵字super，並搭配適當的引數列，明白寫作出呼
叫動作：
//: c06:Chess.java
// Inheritance, constructors and arguments.
class Game {
Game(int i) {
System.out.println("Game constructor");
}
}
class BoardGame extends Game {
BoardGame(int i) {
super(i);
System.out.println("BoardGame constructor");
}
}
public class Chess extends BoardGame {
Chess() {
super(11);
System.out.println("Chess constructor");
}
public static void main(String[] args) {
Chess x = new Chess();
}
} ///:~
如果你未在BoardGame() 中呼叫base class 建構式，程式將無法順利編
譯，因為編譯器無法找到符合Game() 形式的建構式。此外，對base
class 建構式的呼叫，必須是derived class 建構式所做的第一件事(如果你
做錯了，編譯器會提醒你)。
Chapter 6: Reusing Classes 281
捕捉base 建構式的異常
上面說了，編譯器會強迫你將base class 建構式呼叫動作置於derived class
建構式起始處。這表示沒有任何動作可以發生在它之前。第10 章會提到，
這個限制也使得derived class 建構式無法捕捉所有來自base class 的異
常。有時候這挺不方便的。
兼容複合(composition)及繼承(inheritance)
同時使用複合與繼承，是極為常見的事。以下例子同時使用兩種技術，配
合必要的建構式初始化，為你示範更為複雜的class 撰寫手法。
//: c06:PlaceSetting.java
// Combining composition & inheritance.
class Plate {
Plate(int i) {
System.out.println("Plate constructor");
}
}
class DinnerPlate extends Plate {
DinnerPlate(int i) {
super(i);
System.out.println(
"DinnerPlate constructor");
}
}
class Utensil {
Utensil(int i) {
System.out.println("Utensil constructor");
}
}
282 Thinking in Java www.BruceEckel.com
class Spoon extends Utensil {
Spoon(int i) {
super(i);
System.out.println("Spoon constructor");
}
}
class Fork extends Utensil {
Fork(int i) {
super(i);
System.out.println("Fork constructor");
}
}
class Knife extends Utensil {
Knife(int i) {
super(i);
System.out.println("Knife constructor");
}
}
// A cultural way of doing something:
class Custom {
Custom(int i) {
System.out.println("Custom constructor");
}
}
public class PlaceSetting extends Custom {
Spoon sp;
Fork frk;
Knife kn;
DinnerPlate pl;
PlaceSetting(int i) {
super(i + 1);
sp = new Spoon(i + 2);
frk = new Fork(i + 3);
kn = new Knife(i + 4);
pl = new DinnerPlate(i + 5);
System.out.println(
"PlaceSetting constructor");
Chapter 6: Reusing Classes 283
}
public static void main(String[] args) {
PlaceSetting x = new PlaceSetting(9);
}
} ///:~
雖然編譯器會強迫你初始化base classes，並且規定你一定得在建構式起始
處完成，但它並不會看管你是否將成員物件也初始化，你得自己記得。
保證適當清理
Guaranteeing proper cleanup
Java 並不具備C++的解構式(destructor)概念。所謂解構式是物件被摧
毀時自動被呼叫的一個函式。這或許是因為Java 裡頭的「物件摧毀方式」
很簡單，只要忘掉物件、讓垃圾回收器在必要時候回收其所佔記憶體，就
可以了，你無需明確地加以摧毀。
多數時候這是好事，但有時候你的class 可能會在其生命期中執行某些需要
事後清理的動作。然而第4 章告訴我們，你無法得知垃圾回收器被喚起的
時機，也無法知道它是否會被喚起。所以，如果你希望清除class 所留下的
某些東西，你得自行撰寫特殊的函式來進行此事，並讓客端程式員確知他
們得呼叫此一函式來完成清理工作。首要之務一如第10 章所說，便是將此
類清理動作置於finally 子句中，以防異常發生。下面這個例子，是個能
夠在螢幕上繪出圖案的電腦輔助設計系統：
//: c06:CADSystem.java
// Ensuring proper cleanup.
import java.util.*;
class Shape {
Shape(int i) {
System.out.println("Shape constructor");
}
void cleanup() {
System.out.println("Shape cleanup");
284 Thinking in Java www.BruceEckel.com
}
}
class Circle extends Shape {
Circle(int i) {
super(i);
System.out.println("Drawing a Circle");
}
void cleanup() {
System.out.println("Erasing a Circle");
super.cleanup();
}
}
class Triangle extends Shape {
Triangle(int i) {
super(i);
System.out.println("Drawing a Triangle");
}
void cleanup() {
System.out.println("Erasing a Triangle");
super.cleanup();
}
}
class Line extends Shape {
private int start, end;
Line(int start, int end) {
super(start);
this.start = start;
this.end = end;
System.out.println("Drawing a Line: " +
start + ", " + end);
}
void cleanup() {
System.out.println("Erasing a Line: " +
start + ", " + end);
super.cleanup();
}
}
Chapter 6: Reusing Classes 285
public class CADSystem extends Shape {
private Circle c;
private Triangle t;
private Line[] lines = new Line[10];
CADSystem(int i) {
super(i + 1);
for(int j = 0; j < 10; j++)
lines[j] = new Line(j, j*j);
c = new Circle(1);
t = new Triangle(1);
System.out.println("Combined constructor");
}
void cleanup() {
System.out.println("CADSystem.cleanup()");
// The order of cleanup is the reverse
// of the order of initialization
t.cleanup();
c.cleanup();
for(int i = lines.length - 1; i >= 0; i--)
lines[i].cleanup();
super.cleanup();
}
public static void main(String[] args) {
CADSystem x = new CADSystem(47);
try {
// Code and exception handling...
} finally {
x.cleanup();
}
}
} ///:~
在此系統之中，每樣東西都是某種Shape(而Shape 本身又是某種
Object，因為它暗自繼承了那個根源類別)。每個class 除了使用super
來呼叫base class 的cleanup() 之外，還會重新定義這個函式。這些特殊
的Shape classes(Circle、Triangle、Line)全都有個建構式進行「繪
製」動作- 雖然物件生命期中呼叫的每個函式，其實都可能做些需要清理
的事。每個class 都有專屬的cleanup()，用以將不存於記憶體中的東
西，回復至物件存在前的狀態。
286 Thinking in Java www.BruceEckel.com
main() 之中出現兩個前所未見的關鍵字：try 和finally。本書直到第10
章才會正式介紹它們。關鍵字try 表示，接下來的區段(以一組大括號括
起的範圍)即所謂守護區(guarded region)，這個區段必須得到特別對
待，其中之一便是，不論存在多少個try 區段，守護區之後的finally 子
句「絕對」會被執行。(注意，在異常處理機制下，可能有許多不正常離
開try 區段的方式。)此處finally 子句表示的是「不論發生什麼事，絕
對會呼叫x.cleanup()」。第10 章會對這兩個關鍵字做更透徹的解說。
請注意，在你的cleanup 函式中，你得留意「base class 及成員物件中的
cleanup 函式」的呼叫次序，以防範「某個子物件(subobject)與另一個
子物件相依」的情形。一般而言，你應該依循C++編譯器施加於其解構式
身上的形式：首先執行你的class 的所有特定清理動作(其次序和生成次序
相反)，這必須「base class 元素」尚且存活才行。然後，就像此處所示範
的，呼叫base class 的cleanup 函式。
許多時候，「清理(cleanup)」不是問題；你只要讓垃圾回收器做事就好
了。但是當你必須自行處理時，你得更加努力並且小心。
垃圾回收順序
一旦事情和「垃圾回收」有關，就不再有太多你可以信賴的事。垃圾回收
器可能永遠不會被喚起；即使它被喚起，也有可能以任何它想要的次序來
回收物件。因此，除了記憶體，最好不要倚賴垃圾回收機制。如果你希望
發生清理動作，請自行撰寫清理用的函式，不要倚賴finalize()(正如第
4 章所說，你可以強迫Java 呼叫所有的finalizers)。
名稱遮蔽(Name hiding)
只有C++程式員可能會對名稱遮蔽(name hiding)感到訝異，因為在那個
語言中，名稱遮蔽行為大不相同。如果Java 的base class 擁有某個被重載
多次的函式名稱，那麼在derived class 中重新定義此一函式，並不會遮蔽
它在base class 中的任何版本。因此，不論該層class 或base class 是否定
義了這個函式，都會發揮重載作用：
Chapter 6: Reusing Classes 287
//: c06:Hide.java
// Overloading a base-class method name
// in a derived class does not hide the
// base-class versions.
class Homer {
char doh(char c) {
System.out.println("doh(char)");
return 'd';
}
float doh(float f) {
System.out.println("doh(float)");
return 1.0f;
}
}
class Milhouse {}
class Bart extends Homer {
void doh(Milhouse m) {}
}
class Hide {
public static void main(String[] args) {
Bart b = new Bart();
b.doh(1); // doh(float) used
b.doh('x');
b.doh(1.0f);
b.doh(new Milhouse());
}
} ///:~
你在下一章中即將看到， 使用「和base class 一模一樣的標記式
(signature)及回傳型別」來覆寫(override)同名的函式，是再尋常不
過的事了。但這種方式也很容易造成混淆(這也是C++不允許你這麼做的
原因，以杜絕你可能犯下的錯誤)。
288 Thinking in Java www.BruceEckel.com
複合與繼承之間的抉擇
Choosing composition vs. inheritance
複合與繼承，都讓你可以將子物件(subobjects)置於新的class 中。你可
能會納悶，二者之間究竟有何差異，而且何時該選用哪一種技術呢？
當你想要在新class 中使用既有class 的功能，而非其介面，通常可以採用
複合技術。也就是說，嵌入某個物件，使你得以在新class 中以它實現你想
要的功能。但是新class 的使用者只能看到你為新class 所定義的介面，不
會看到內嵌的那個物件的介面。如果這正是你所希望的，你應該在新的
class 中以private 形式嵌入既有的classes 的物件。
但有時候，讓class 使用者直接取用新class 內的複合成份(也就是將成員
物件宣告為public)是有意義的。如果各個成員物件分別完成了實作細目
的隱藏，這種作法很安全。當使用者知道你組合了一堆組件，他們便更能
夠輕易了解其介面。car 物件便是個好例子：
//: c06:Car.java
// Composition with public objects.
class Engine {
public void start() {}
public void rev() {}
public void stop() {}
}
class Wheel {
public void inflate(int psi) {}
}
class Window {
public void rollup() {}
public void rolldown() {}
Chapter 6: Reusing Classes 289
}
class Door {
public Window window = new Window();
public void open() {}
public void close() {}
}
public class Car {
public Engine engine = new Engine();
public Wheel[] wheel = new Wheel[4];
public Door left = new Door(),
right = new Door(); // 2-door
public Car() {
for(int i = 0; i < 4; i++)
wheel[i] = new Wheel();
}
public static void main(String[] args) {
Car car = new Car();
car.left.window.rollup();
car.wheel[0].inflate(72);
}
} ///:~
由於car 本身的組成也是問題分析的一部份(而不僅是底層設計的一部
份)，所以將成員宣告為public，能夠幫助客端程式員了解此一class 的
使用方式，也降低class 開發者所須面對的程式碼複雜度。不過你得記住，
這是個特例，一般情況下，你應該將fields(資料欄)宣告為private。
實施繼承技術時，你會使用某個既有的class，然後開發它的一個特化版本
(special version)。一般來說這代表你使用某個通用性的class，並基於
特定目的對它進行特殊化(specializing)工程。稍加思索我們就知道，以
「交通工具」來合成一部車子是沒有意義的，因為車子並非包含交通工
具，車子「是一種」交通工具。這種「is-a(是一個)」的關係便以繼承來
表達。「has-a(有一個)」的關係則以複合來表達。
290 Thinking in Java www.BruceEckel.com
protected(受保護的)
現在，我們已經完成了繼承的介紹。關鍵字protected 終於有了意義。在
理想世界中，private 成員應該是完全不能變通的，但實際專案中，有些
時候你會希望某些東西對整個世界隱藏，而derived classes 卻可加以存
取。關鍵字protected 便是這種實用主義的展現。它代表著「就此class
的使用者來說，這是private。但任何繼承自此一class 的derived
classes，或位於同一個package 內的其他classes，卻可加以存取」。也就
是說，Java 的protected 天生具有"friendly" 權限。
最好的準則就是，將資料成員宣告為private - 你應該絕對保留「更動底
層實作」的權限。然後便可透過protected 函式來控制繼承者對你所撰寫
的class 的存取權限：
//: c06:Orc.java
// The protected keyword.
import java.util.*;
class Villain {
private int i;
protected int read() { return i; }
protected void set(int ii) { i = ii; }
public Villain(int ii) { i = ii; }
public int value(int m) { return m*i; }
}
public class Orc extends Villain {
private int j;
public Orc(int jj) { super(jj); j = jj; }
public void change(int x) { set(x); }
} ///:~
你可以看到，change() 具有取用set() 的權限，因為它是protected。
Chapter 6: Reusing Classes 291
漸進式開發(Incremental development)
繼承的優點之一，便是支援漸進式開發模式。在此開發模式下，你可以加
入新的程式碼，而且絕不會在既有程式碼身上衍生臭蟲。此種開發模式能
夠將新的臭蟲侷限於新的程式碼中。藉由繼承既有的、基礎的classes，並
且加上新的資料成員和成員函式(並重新定義既有的函式)，便可讓既有
的程式碼- 也許某人正在使用－ 不被碰觸也不含錯誤。
classes 被隔離的乾淨程度令人感到十分訝異。如果想重複運用程式碼，你
甚至不需要其函式的原始碼，頂多只要匯入(import)package 就好了。
這句話對繼承和複合同時成立。
你得明白，程式的開發是一個漸進過程，就像人類的學習一樣。你可以竭
盡所能地分析，但是當你開始執行專案，你仍然無法知道所有解答。如果
你將專案視為一種有機、具演化能力的生物，而不是用蓋摩天大樓的方式
企圖一舉完成，你便會獲得更多的成功，以及更立即的回饋。
雖然就經驗而言，繼承是個有用的技術，但是在事情進入穩定狀態之後，
你得重新檢視你的classes 階層體系，思考如何將它縮減為更實用的結構。
記住，繼承代表著一種關係的展現，它代表「這個新的class 是一種舊的
class。」你的程式不應該只是圍繞在bits(位元)的處理，應該透過許多
不同類型的物件的生成和操作，以來自問題空間(problem space)中的術
語來表現一個模型(model)。
向上轉型(Upcasting)
「繼承」技術中最重要的一個面向並非是「為新的class 提供函式」。繼承
是介於新class 和base class 之間的一種關係。這種關係可以扼要地這麼
說：「新class 是既有class 的一種形式。」
292 Thinking in Java www.BruceEckel.com
這個描述並非只是解釋「繼承」的一堆華麗辭藻，而是直接由程式語言支
援的性質。假設有個名為Instrument(樂器)的base class，其derived
class 名為Wind(管樂器)。由於繼承意謂「在derived class 中可以使用
base class 的所有函式」，所以任何可發送給base class 的訊息，也都可以
發送給derived class。如果Instrument class 擁有play()，那麼Wind
也會有。這表示我們可以很精確地說， Wind 物件也是一種
Instrument。以下例子說明編譯器如何支援此種表示式：
//: c06:Wind.java
// Inheritance & upcasting.
import java.util.*;
class Instrument {
public void play() {}
static void tune(Instrument i) {
// ...
i.play();
}
}
// Wind objects are instruments
// because they have the same interface:
class Wind extends Instrument {
public static void main(String[] args) {
Wind flute = new Wind();
Instrument.tune(flute); // Upcasting
}
} ///:~
這個例子中有趣的是tune()，它接受一個Instrument reference。然而
當Wind.main() 呼叫tune() 時，傳給它的卻是一個Wind reference。
我們知道Java 對型別的檢查十分嚴格，而這個接受某種型別的函式，竟然
可以接受另一種型別。在你明白「Wind 物件其實也是Instrument 物
件」之前，你可能會覺得這真是件怪事。此例之中沒有什麼函式是
「tune() 可透過Instrument 呼叫起來」而卻不在Wind 之內的。
tune() 函式碼可作用於Instrument 以及任何衍生自Instrument 的
Chapter 6: Reusing Classes 293
classes 身上。這種「將Wind reference 轉為Instrument reference」的
動作稱為「向上轉型(upcasting)」。
為什麼需要向上轉型(Why “upcasting”)?
這個詞彙有其歷史背景，而且根據繪製繼承階層圖時的傳統方式：將根類
別(root)置於紙面上端，從上往下繪製(當然你也可以用任何你覺得有
用的方式來繪製你的圖形)。因此，Wind.java 的繼承圖為：
Instrument
Wind
從derived class 移至base class，在繼承圖中是向上移動，所以通常稱為
「向上轉型」。向上轉型一定安全，因為這是從專用型別移至通用型別。
也就是說derived class 是base class 的一個超集合。derived class 至少包
含base class 函式，而且可能更多。向上轉型過程中，對class 介面造成的
唯一效應是函式的「遺失」而非「獲得」。這也就是為什麼在「未曾明確
表示轉型」或「未曾指定特殊標記」的情況下，編譯器仍然允許向上轉型
的原因。
你也可以執行和向上轉型方向相反的「向下轉型(downcasting)」，但
這會牽扯到一個與第12 章討論課題有關的難題。
複合(Composition)vs. 繼承(inheritance)，再探
物件導向編程中，產生及運用程式碼的最可能形式，便是將資料和函式包
裝起來成為class，然後運用其物件。你可能透過「複合」，以既有的class
開發出新的classes。動用「繼承」的頻率比較少。所以雖然OOP 的學習
過程中常常強調繼承，但並不代表你應該處處使用它。
294 Thinking in Java www.BruceEckel.com
相反地，你應該謹慎使用它：只有在明顯能夠產生實用價值時，才使用繼
承。究竟應該使用複合或繼承，最清楚的判斷方式就是問你自己，是否需
要將新的class 向上轉型為base class。如果你必須向上轉型，你就應該使
用繼承。如果不需要向上轉型，那麼你應該仔細考慮是否需要動用繼承。
下一章(polymorphism，多型)將提出向上轉型的一個最具競爭力的理
由。如果你時時詢問自己：「我需要向上轉型嗎？」，那麼，當你面對複
合或繼承時，你便擁有一個極佳的判斷工具。
關鍵字final
如果望文生義，可能會對Java 的關鍵字final 有所誤解。一般來說其意思
是：「這是不能被改變的」。是的，基於設計和效率兩大理由你可能希望
阻止改變。這兩個理由十分不同，因此可能造成對關鍵字final 的誤用。
以下各節探討可以使用final 的三個地方：data、methods、classes。
Final data
許多程式語言都提供某種機制，用來告訴編譯器某塊資料是「固定不變
的」。不變的資料可能很有用，因為它：
1. 可以是永不改變的「編譯期常數(compile-time constant)」。
2. 可以在執行期(run-time)被初始化，而你卻不想再改變它。
以編譯期常數而言，編譯器可以將這個常數包進任何一個用到它的計算式
中；也就是說，編譯期間就能夠執行某些計算，減少執行期的負擔。在
Java 中，此類常數必須屬於基本型別，而且必須以關鍵字final 修飾之。
定義此類常數的同時，必須給定其值。
如果某一筆資料既是static 也是final，那麼它會擁有一塊無法改變的儲
存空間。
將final 用於object references 而不用於基本型別時，其實際意義可能有
點令人困惑。用於基本型別時，final 讓value(數值)保持不變，但是用
Chapter 6: Reusing Classes 295
於object reference 時，final 讓reference 保持不變。某個reference 一旦
被初始化用以代表某個物件之後，便再也不能改而指向另一個物件。但此
時物件本身的內容卻是可以更動的；Java 並未提供「讓任何物件保持不
變」的機制(不過你還是可以撰寫你自己的class，產生令物件保持不變的
效果)。此一限制對同樣身為物件的array 而言，也是成立的。
下面是個例子，用來示範final 資料成員：
//: c06:FinalData.java
// The effect of final on fields.
class Value {
int i = 1;
}
public class FinalData {
// Can be compile-time constants
final int i1 = 9;
static final int VAL_TWO = 99;
// Typical public constant:
public static final int VAL_THREE = 39;
// Cannot be compile-time constants:
final int i4 = (int)(Math.random()*20);
static final int i5 = (int)(Math.random()*20);
Value v1 = new Value();
final Value v2 = new Value();
static final Value v3 = new Value();
// Arrays:
final int[] a = { 1, 2, 3, 4, 5, 6 };
public void print(String id) {
System.out.println(
id + ": " + "i4 = " + i4 +
", i5 = " + i5);
}
public static void main(String[] args) {
FinalData fd1 = new FinalData();
//! fd1.i1++; // Error: can't change value
fd1.v2.i++; // Object isn't constant!
fd1.v1 = new Value(); // OK -- not final
296 Thinking in Java www.BruceEckel.com
for(int i = 0; i < fd1.a.length; i++)
fd1.a[i]++; // Object isn't constant!
//! fd1.v2 = new Value(); // Error: Can't
//! fd1.v3 = new Value(); // change reference
//! fd1.a = new int[3];
fd1.print("fd1");
System.out.println("Creating new FinalData");
FinalData fd2 = new FinalData();
fd1.print("fd1");
fd2.print("fd2");
}
} ///:~
由於i1 和VAL_TWO 都是帶有編譯期數值的final 基本型別，所以它們
都可以被當做編譯期常數來使用，沒有什麼重大區別。VAL_THREE 的
定義方式是更為典型的常數定義方式：定義為public，所以可被用於
package 之外；定義為static，強調它只有一份；定義為final，宣告它是
個常數。請注意，帶有常數初值的final static 基本型別，習慣上以底線
來隔開字與字(這個習慣濫觴於C 語言)。同時也請注意，i5 的值在編譯
期無法得知，所以並未以大寫字母表示。
我們不能只因為某筆資料被宣告為final，就認為在編譯期便知其值。上述
程式為了示範這一點，在執行期隨機產生的數字做為i4 和i5 的初值。這
也說明了將final 數值宣告為static 和宣告為non-static 的差別。這個差
別只有「當其數值係在執行期被初始化」時才會顯現，因為編譯器對待任
何編譯期數值(compile-time values)的態度都是一樣的(而且它們可能
因為最佳化而消失掉)。這個差別可以從某些執行結果觀察出來：
fd1: i4 = 15, i5 = 9
Creating new FinalData
fd1: i4 = 15, i5 = 9
Chapter 6: Reusing Classes 297
fd2: i4 = 10, i5 = 9
請注意，fd1 和fd2 中的i4 值皆不相同，但i5 值不會因為產生了第二個
FinalData 物件而改變。這是因為它是static，而且只有在載入class 時
才進行初始化，不會在每次產生新物件時都再被初始化一次。
從v1 到v4 的這幾個變數，說明了final reference 的意義。正如你在
main() 中觀察到的，不能因為v2 是final，就認為你無法改變其值。不
過，你無法將v2 重新指向另一個物件，因為v2 是final。這也正是final
用於reference 時的意義。你會發現，同樣的意義對array 來說依然成立，
因為它不過也只是另一種reference 罷了。不過就我所知，沒有任何方法可
以令array references 本身成為final。將references 宣告為final 似乎比
將基本型別宣告為final 不實用多了。
Blank finals
Java 允許產生所謂「留白的finals」(blank final)，也就是允許我們將
資料成員宣告為final，卻不給予初值。任何情況下，blank finals 必須在
使用之前進行初始化，而且編譯器會保證此事。不過blank finals 對於
final 關鍵字的使用提供了更多彈性，因為這麼一來，class 內的final 資
料成員便可以在每個物件中有所不同，但依舊保持其「恆長不變」的特
性。以下便是一例：
//: c06:BlankFinal.java
// "Blank" final data members.
class Poppet { }
class BlankFinal {
final int i = 0; // Initialized final
final int j; // Blank final
final Poppet p; // Blank final reference
// Blank finals MUST be initialized
// in the constructor:
BlankFinal() {
j = 1; // Initialize blank final
p = new Poppet();
}
298 Thinking in Java www.BruceEckel.com
BlankFinal(int x) {
j = x; // Initialize blank final
p = new Poppet();
}
public static void main(String[] args) {
BlankFinal bf = new BlankFinal();
}
} ///:~
編譯器強迫你一定得對所有finals 執行賦值動作- 如果不是發生在其定義
處，就得在每個建構式中以運算式設定其值。這也就是為什麼能夠保證
「final 資料成員在被使用前絕對會被初始化」的原因。
Final arguments
Java 允許你將引數(arguments)宣告為final，只要在引數列中宣示即
可，意謂你無法在此函式中令該引數(一個reference)改指它處：
//: c06:FinalArguments.java
// Using "final" with method arguments.
class Gizmo {
public void spin() {}
}
public class FinalArguments {
void with(final Gizmo g) {
//! g = new Gizmo(); // Illegal -- g is final
}
void without(Gizmo g) {
g = new Gizmo(); // OK -- g not final
g.spin();
}
// void f(final int i) { i++; } // Can't change
// You can only read from a final primitive:
int g(final int i) { return i + 1; }
public static void main(String[] args) {
FinalArguments bf = new FinalArguments();
bf.without(null);
bf.with(null);
}
Chapter 6: Reusing Classes 299
} ///:~
請注意，你仍然可以將null reference 當做final 引數，就像面對nonfinal
引數一樣。是的，這麼做並不會帶來編譯上的困擾。
f() 和g() 這兩個函式說明了「當基本型別引數為final」時會發生什麼
事：你可以讀取引數所代表的值，但無法改變該值。
Final methods
使用final methods(函式)的原因有二。第一，鎖住這個函式，使
derived class 無法改變其意義。這是基於設計的一種考量：也許你希望確
保某個函式的行為在繼承過程中保持不變， 而且無法被覆寫
(overridden)。
第二個原因是效率。如果你將某個函式宣告為final，等於允許編譯器將所
有對此函式的呼叫動作轉化為inline(行內)呼叫。當編譯器看到一個
final 函式呼叫動作，它可以(根據它自己的謹慎判斷)不採用正常對待方
式(亦即插入某段程式碼以執行「函式呼叫機制」：將引數送入stack、跳
至函式程式碼所在位置並執行、跳回並清除stack 內的引數、處理回傳
值)，而以函式本體取代那個呼叫動作。這麼做能夠降低函式呼叫動作所
引發的額外負擔。當然，如果函式體積龐大，inlining 會迫使整個程式碼大
小隨之膨脹。而且你可能無法藉此獲得效能的改善，是的，你獲得的效能
利益將因為「花費在函式中的時間」而顯得不成比例。這意味Java 編譯器
可以偵測這些情況，並聰明地決定是否對final 函式執行inline 動作。不
過，最好不要相信你的編譯器具備此種才華，最好是在某個函式真的體積
很小或是你真的不希望它被覆寫時，才將它宣告為final。
final 和private
class 中的所有private 函式自然而然會是final。因為你無法取用
private 函式，當然也就無從覆寫(即使當你嘗試覆寫它而編譯器沒有給
出任何錯誤訊息，你仍然沒有覆寫成功。實際上你是產生了一個新的
300 Thinking in Java www.BruceEckel.com
函式)。你可以將關鍵字final 加於private 函式身上，但這麼做不會帶
來任何額外意義。
這個問題可能引發人們的困惑，因為如果你試著覆寫某個private 函式
(隱隱有final 味道)，似乎也可以：
//: c06:FinalOverridingIllusion.java
// It only looks like you can override
// a private or private final method.
class WithFinals {
// Identical to "private" alone:
private final void f() {
System.out.println("WithFinals.f()");
}
// Also automatically "final":
private void g() {
System.out.println("WithFinals.g()");
}
}
class OverridingPrivate extends WithFinals {
private final void f() {
System.out.println("OverridingPrivate.f()");
}
private void g() {
System.out.println("OverridingPrivate.g()");
}
}
class OverridingPrivate2
extends OverridingPrivate {
public final void f() {
System.out.println("OverridingPrivate2.f()");
}
public void g() {
System.out.println("OverridingPrivate2.g()");
}
}
public class FinalOverridingIllusion {
Chapter 6: Reusing Classes 301
public static void main(String[] args) {
OverridingPrivate2 op2 =
new OverridingPrivate2();
op2.f();
op2.g();
// You can upcast:
OverridingPrivate op = op2;
// But you can't call the methods:
//! op.f();
//! op.g();
// Same here:
WithFinals wf = op2;
//! wf.f();
//! wf.g();
}
} ///:~
「覆寫」(overriding)只能夠發生在「函式屬於base class 介面」時。也
就是說，你必須能夠將某個物件向上轉型至其基本型別，並呼叫同一個
(同名)函式(下一章會對此點做更進一步的釐清)。如果某個函式是
private，它便不涵括於base class 的介面中。它只不過是隱藏在class 內
的某段程式碼，而恰好具有那個名字罷了。即使你在derived class 中撰寫
了某個public 或protected 或"friendly" 函式，對它而言也並不就因此
具備「剛好擁有base class 中的某個名稱」的關聯性。由於private 函式
無法接觸，有效隱藏，所以它不需要被任何事物納入考量- 它只是在它所
棲身的class 中因程式碼的組織而存在。
Final classes
當你將整個class 宣告為final(將關鍵字final 置於class 定義式前)，等
於宣告你並不想繼承此一class，也不允許別人這麼做。換句話說，或許基
於class 設計上的考量，你不需要再有任何更動；或許基於安全保密的考
量，你不希望繼承動作發生。你也許會想到效率議題，你應該確保與此
class objects 有關的任何活動，都儘可能地有效率。
//: c06:Jurassic.java
// Making an entire class final.
302 Thinking in Java www.BruceEckel.com
class SmallBrain {}
final class Dinosaur {
int i = 7;
int j = 1;
SmallBrain x = new SmallBrain();
void f() {}
}
//! class Further extends Dinosaur {}
// error: Cannot extend final class 'Dinosaur'
public class Jurassic {
public static void main(String[] args) {
Dinosaur n = new Dinosaur();
n.f();
n.i = 40;
n.j++;
}
} ///:~
請注意，不論class 是否被定義為final，資料成員既可以是final，也可
以不是，視你的意志而定。final data 的原始規則仍然適用。將class 定義
為final，只不過是要杜絕繼承。不過，由於這麼做會阻止繼承動作，所以
final class 中的所有函式也都自然是final，因為沒有人能夠加以覆寫。如
果你明確地將某個函式宣告為final，編譯器一樣具有效率上的選擇權。
你可以將關鍵字final 加於final class 內的函式之前，但這麼做並不會增
加任何意義。
最後的告誡
當你設計class 時，將函式宣告為final 可能是合理的。你可能認為使用
class 時效率很重要，而且不應該有任何人覆寫你的函式。某些時候這是對
的。
Chapter 6: Reusing Classes 303
但請格外小心你所做的假設。一般來說我們很難預先考慮class 可能被重複
運用的方式，對通用性的class 來說尤其如此。如果你將某個函式定義為
final，你可能會阻礙「其他程式員在另一個專案中，透過繼承，重複運用
此一class」的可能性。因為你沒有想到它會被這麼運用。
Java 標準程式庫便是一個極佳的例子。特別是在Java 1.0/1.1 中被廣泛使
用的Vector class，從它的名字看來，便知道其設計目的在於效率。如果
它的所有函式都未被宣告為final，它可能會更為有用。你可能想要繼承如
此有用的base class 並加以覆寫(override)。這種想法很容易理解。但是
不知怎的，其設計者卻認為這麼做不妥當。這裡有兩個出人意表的原因。
第一，Stack 繼承自Vector，意味Stack 是個Vector，事實上這不是正
確的思考邏輯。第二，Vector 的許多重要函式，例如addElement() 和
elementAt()，都是synchronized。第14 章會告訴你，這造成極大的
效能負擔，或許會因而抵消因final 而得到的所有效能改善。這種情況使
人們更加確信這一句話：程式員很難正確揣測最佳化動作應該發生於何
處。這麼拙劣的設計，竟然被放在我們大家都必須使用的標準程式庫中，
真是夠慘的了。幸好Java 2 的容器相關程式庫以ArrayList 汰換了
Vector。ArrayList 的行為合理多了，不幸的是許多新開發的程式仍然使
用那些老舊的容器程式庫。
Hashtable 亦頗值得一書。它是標準程式庫中的另一個class，但未具備
任何final 函式。一如本書它處所言，有些classes 很明顯是由一群完全不
相干的人設計出來(你會發現Hashtable 的函式名稱相對於Vector 而言
簡短多了，這是另一個證據)。對class library 使用者來說，這又是另一
種不該如此輕率的東西。規則的不一致，只會讓使用者付出更多額外工
夫。這是對草率設計和草率撰碼的另一個驚嘆。請注意，Java 2 的容器程
式庫已經以HashMap 汰換了Hashtable。
304 Thinking in Java www.BruceEckel.com
初始化以及class 的載入
有許多傳統語言，其程式在起動(startup)過程中便會全部被載入，緊接
著初始化動作，然後便開始執行。在這些語言中，初始化過程必須被小心
翼翼地控制，才能確保statics 的初始化順序不會引發問題。以C++為
例，如果某個static 預期另一個static「在初始化前能夠被正常使用」，
便會發生問題。
Java 沒有這種問題，因為它採用另一種載入方式。由於Java 中的每樣事物
都是物件，許多動作就變得更為簡單，載入動作亦如是。下一章會讓你學
得更完整。每個class 經過編譯之後，存於專屬的個別檔案中。這個檔案只
在必要時才被載入。一般而言你可以這麼說：「class 程式碼在初次被使用
時才被載入」。所謂初次被使用，不僅是其第一個物件被建構之時，也可
能是在某個static 資料成員或static 函式被取用時。
「首次使用class」的時間點，也正是靜態初始化(static initialization)
的進行時機。任何static 物件和static 程式區段被載入時，都會依據它們
在程式碼中的次序(也就是它們在class 定義式中的出現次序)加以初始
化。當然，statics 只會被初始化一次。
繼承與初始化
仔細檢視包括繼承在內的一整個初始化過程，對於其中因果關係的了解極
有幫助。請看以下程式碼：
//: c06:Beetle.java
// The full process of initialization.
class Insect {
int i = 9;
int j;
Insect() {
prt("i = " + i + ", j = " + j);
Chapter 6: Reusing Classes 305
j = 39;
}
static int x1 =
prt("static Insect.x1 initialized");
static int prt(String s) {
System.out.println(s);
return 47;
}
}
public class Beetle extends Insect {
int k = prt("Beetle.k initialized");
Beetle() {
prt("k = " + k);
prt("j = " + j);
}
static int x2 =
prt("static Beetle.x2 initialized");
public static void main(String[] args) {
prt("Beetle constructor");
Beetle b = new Beetle();
}
} ///:~
這個程式的輸出結果是：
static Insect.x1 initialized
static Beetle.x2 initialized
Beetle constructor
i = 9, j = 0
Beetle.k initialized
k = 47
j = 39
當你執行Beetle 時，首先發生的動作便是企圖取用Beetle.main()(這
是一個static 函式)，於是載入器被啟動，找出Beetle class 編譯過的程
式碼(應該被置於名為Beetle.class 的檔案中)。載入過程中由於關鍵字
extends 的存在，載入器得知這個class 擁有base class，於是接續載入。
無論你是否產生base class 的物件，這個動作都會發生。請試著將其「物
件生成空間」註解掉，藉此證明這一點。
306 Thinking in Java www.BruceEckel.com
如果base class 還有base class，那麼便會接續載入第二個base class，依
此類推。接下來，root base class(本例為Insect)中的靜態初始化動作
會被執行，然後是其derived class，依此類推。上述方式很重要，因為
derived class 的靜態初始化動作是否正確，可能和base class 的成員是否被
正確初始化有關。
至止，所有必要的classes 都已被載入，可以開始產生物件了。首先，物件
內的所有基本型別都會被設予預設值，object reference 則被設為null -
也就是說將物件記憶體都設為二進位零值。然後，base class 的建構式會被
喚起。本例之中它會被自動喚起，但你也可以使用super(做為Beetle()
建構式的第一個動作)，自行呼叫base class 的某個建構式。base class 的
建構過程和其derived class 建構式中的次序相同。base class 建構式完成之
後，其「instance 變數」(譯註：亦即資料成員；相對於「class 變數」)
會以其出現次序被初始化。最後才執行建構式本體的剩餘部份。
摘要
繼承和複合都允許你根據既有的型別產生新型別。一般而言你會使用「複
合」來重複運用既有型別，使其成為新型別底層實作的一部份；至於「繼
承」則用於介面的重複運用。由於derived class 具備了base class 的介
面， 所以它可以「向上轉型( upcast ) 」至base class ， 這對多型
(polymorphism)來說極為重要，詳見下一章。
儘管物件導向編程(OOP)極為強調「繼承」，但你一開始進行設計時，
應該先考慮使用「複合」，只有在明確必要時才使用「繼承」。「複合」
較具彈性，而經由「繼承」帶來的靈巧性，你可以在執行期改變成員物件
的實際型別和行為，如此一來便可以在執行期改變複合而成的物件的行
為。
Chapter 6: Reusing Classes 307
雖然，透過複合和繼承達到程式碼的重複運用，對於快速專案開發來說極
具助益，但是在其他程式員使用之前，通常還是得再一次設計你的class 階
層架構。我們的努力目標是：讓階層架構中的每個class 各自具備特定用
途，而且既不太大(包含太多功能，難以重複運用)也不太小(無法在不
加入其他功能的情況下單獨使用之)。
練習
某些經過挑選的題目，其解答置於《The Thinking in Java Annotated Solution Guide》電子文件中。
僅需小額費用便可自www.BruceEckel.com.網站取得。
1. 請撰寫兩個帶有default 建構式(引數列空白)的classes A 和B。
請繼承自A，產生一個class C，並在C 中以B 物件做為成員。請
不要為C 提供任何建構式。現在，產生一個C 物件，並觀察結果。
2. 修改上題程式，使A 和B 都具有帶引數的建構式，而非default 建
構式。為C 撰寫一個建構式，並在其中執行所有初始化動作。
3. 先撰寫一個簡單的class，並在撰寫第二個class 時，將某個資料成
員定義為第一個class 的物件。請使用緩式初始化( lazy
initialization)來產生這個物件實體。
4. 繼承class Detergent，產生一個新的class。覆寫其scrub() 並加
入一個名為sterilize() 的新的函式。
5. 使用Cartoon.java，並將Cartoon class 的建構式註解掉。請解
釋所發生的現象。
6. 使用Chess.java，並將Chess class 的建構式註解掉。請解釋所
發生的現象。
7. 請證明為你而產生的default 建構式是由編譯器合成的。
8. 請證明base class 的建構式(a) 絕對會被喚起、(b) 在derived class
建構式之前被喚起。
9. 撰寫一個base class，令它僅具有一個non-default 建構式。再撰
寫一個derived class，令它同時具備default 建構式和non-
308 Thinking in Java www.BruceEckel.com
default 建構式。請在derived class 建構式中呼叫base class 的建
構式。
10. 撰寫一個Root class，並令它分別含有以下class 的實體(亦由你
來撰寫)： Componenet1、Component2、Component3。
現在， 從Root 衍生出class Stem， 並令它含有上述各個
"component"。所有classes 都應該具備一個能夠印出class 相關訊
息的default 建構式。
11. 修改上題的程式，令每個class 僅有non-default 建構式。
12. 將cleanup() 適當加至練習11 中的所有classes。
13. 撰寫某個class，令它擁有一個重載三次的函式。為它衍生一個新的
class，並為上述函式加入一份新的重載定義。證明這四個函式在
derived class 中都可用。
14. 在Car.java 中，請將service() 加至class Engine，並在main()
中呼叫它。
15. 撰寫位於package 內的某個class，並令它含有一個protected 函
式。在此package 之外，試著呼叫該protected 函式，並解釋其結
果。接著，繼承剛才那個class，並在derived class 的某個函式中
呼叫上述的protected 函式。
16. 撰寫一個Amphibian class，並令Frog 繼承之。請將適當的函式
置於base class 中。並在main() 中產生Frog 物件，且向上轉型
至Amphibian。示範所有的函式都能夠有效運作。
17. 修改練習16 的程式，令Frog 覆寫其base class 中的函式的定義
(以同樣的函式標記式來撰寫新的定義)。請留意main() 所發生
的事。
18. 請撰寫一個class，令它擁有static final 資料成員和final 資料成
員，並說明二者的差異。
Chapter 6: Reusing Classes 309
19. 請撰寫一個class，令它擁有blank final reference。請在你使用這
個reference 之前，於某個函式(但非建構式)中執行該blank
final 的初始化動作。請說明以下保證：final 被使用之前一定會被
初始化，而且一經初始化便無法改變。
20. 請撰寫一個class，令它擁有final 函式。衍生一個新的class 並覆
寫該函式。
21. 請撰寫一個final class，並試著加以繼承。
22. 請證明，class 載入動作只會發生一次。也請證明，class 載入動作
可能發生在class 的第一個實體誕生時，或其static 成員第一次被
取用時。
23. 在Beetle.java 中，試著從class Beetle 繼承出一種特殊的甲蟲，
並令它依循既有classes 的相同形式。請追蹤輸出結果，並試著加
以解釋。
310 Thinking in Java www.BruceEckel.com
311
7: 多型Polymorphism
除了資料抽象化(data abstraction)與繼承(Inheritance)
以外，物件導向編程語言的第三個核心本質便是多型
(polymorphism)。
多型提供了「介面與實作分離」的另一個重要性，能將what(是什麼)自
how(怎麼做)之中抽離。多型不但能改善程式的組織架構及可讀性，更
能開發出「可擴充」的程式。具備此種特質的程式，不僅能夠在原本的專
案開發過程中逐漸成長，也能藉由增加新功能來擴充規模。
封裝( encapsulation ) 藉著「將特徵( characteristics ) 與行為
( behaviors ) 結合在一起」而產生新的資料型別。實作隱藏
(implementation hidden)則藉由「將細目(details)宣告為private」
而分離出介面(interface)與實作(implementation)。此類機制對於擁
有程序式(procedural)設計背景的人們來說，是有意義的。但多型
(polymorphism)卻打算除去型別之間的耦合關係。前一章你看到了，繼
承機制允許你不但能將某個物件以其本身型別視之，亦能以其基礎型別
(base type)視之。此一能力極為重要，有了這種能力，我們便能夠將多
個型別視為同一個型別，而一份程式碼也因此得以同時作用於這些(其實
並不相同的)型別之上。polymorphical method call(多型函式呼叫)使
某個型別有能力表現它與另一個相似型別的區別- 只要這兩個型別皆衍生
自相同的基礎型別(base type)。相似型別之間的區別可藉由「函式的行
為差異」來展現，而這些函式都可透過base class 喚起。
本章中，你會透過一些簡單範例(焦點全放在多型行為身上)學習有關多
型(也稱為動態繫結dynamic binding、後期繫結late binding、或執行時
期繫結run-time binding)的種種事物。
再探向上轉型(Upcasting)
你已經在第6 章看到了，物件既能以其自身型別的形式被使用，又能被視
為其基礎型別而被使用。「將某個object reference 視為一個reference to
312 Thinking in Java www.BruceEckel.com
base type」的動作，稱為「向上轉型(upcasting)」，之所以這麼說，是
因為我們習慣在繼承樹狀圖中將base class 置於上端。
在此同時，你也會看到伴隨而來的問題。下面是一個具體實例：
//: c07:music:Music.java
// Inheritance & upcasting.
class Note {
private int value;
private Note(int val) { value = val; }
public static final Note
MIDDLE_C = new Note(0),
C_SHARP = new Note(1),
B_FLAT = new Note(2);
} // Etc.
class Instrument {
public void play(Note n) {
System.out.println("Instrument.play()");
}
}
// Wind objects are instruments
// because they have the same interface:
class Wind extends Instrument {
// Redefine interface method:
public void play(Note n) {
System.out.println("Wind.play()");
}
}
public class Music {
public static void tune(Instrument i) {
// ...
i.play(Note.MIDDLE_C);
}
public static void main(String[] args) {
Wind flute = new Wind();
tune(flute); // Upcasting
}
Chapter 7: Polymorphism 313
} ///:~
Music.tune() 接受一個Instrument reference，但也接受所有衍生自
Instrument 的classes。你可以在main() 中觀察到這個特性，當Wind
被傳入tune() 時，無需任何轉型動作。這麼做是可以的，因為Wind 繼
承自Instrument，所以Instrument 的介面必定也存在於Wind 中。
自Wind 向上轉型至Instrument 可能會「窄化」其介面，但無論如何
不會窄於Instrument 的介面。
將物件的型別忘掉
你可能覺得這個程式頗為奇怪。為什麼有人要刻意把物件的型別忘掉呢？
這種情況發生於「向上轉型」之時。其實「讓tune() 接收Wind
reference」或許更為直觀，但如果你那麼做，你就得為系統中的每個
Instrument 型別重新撰寫tune()。如果我們採用那種作法，並加入
Stringed(弦樂器)與Brass(銅管樂器)：
//: c07:music2:Music2.java
// Overloading instead of upcasting.
class Note {
private int value;
private Note(int val) { value = val; }
public static final Note
MIDDLE_C = new Note(0),
C_SHARP = new Note(1),
B_FLAT = new Note(2);
} // Etc.
class Instrument {
public void play(Note n) {
System.out.println("Instrument.play()");
}
}
class Wind extends Instrument {
public void play(Note n) {
System.out.println("Wind.play()");
314 Thinking in Java www.BruceEckel.com
}
}
class Stringed extends Instrument {
public void play(Note n) {
System.out.println("Stringed.play()");
}
}
class Brass extends Instrument {
public void play(Note n) {
System.out.println("Brass.play()");
}
}
public class Music2 {
public static void tune(Wind i) {
i.play(Note.MIDDLE_C);
}
public static void tune(Stringed i) {
i.play(Note.MIDDLE_C);
}
public static void tune(Brass i) {
i.play(Note.MIDDLE_C);
}
public static void main(String[] args) {
Wind flute = new Wind();
Stringed violin = new Stringed();
Brass frenchHorn = new Brass();
tune(flute); // No upcasting
tune(violin);
tune(frenchHorn);
}
} ///:~
這麼寫當然行得通， 但主要的缺點是： 你得為你新加入的每個
Instrument class 撰寫專屬的函式。這代表一開始你得花不少編程功夫，
這也代表如果你想加入和tune() 類似的新的函式，或是加入衍生自
Instrument 的新型別，得花不少力氣。此外，如果你忘了重新定義函
Chapter 7: Polymorphism 315
式，編譯器不會給你任何錯誤訊息，因而使得型別的整個使用過程變得更
難以管理。
如果我們能夠只寫一份函式，接收base class(而非任何特定的derived
class)作為引數，事情會變得更好嗎？也就是說，如果能夠忘掉derived
class 的存在，只撰寫與base class 溝通的程式碼，會不會比較好？
這正是多型允許你做的事。然而，大多數擁有程序式(procedural)設計
背景的程式員，對於多型的運作方式一開始都會有許多困惑。
竅門
Music.java 的困難點，在我們執行該程式之後便可發現。其輸出結果顯
示Wind.play() 會被執行。這無疑是我們想要的，但這個結果卻似乎不太
合理。請看tune()：
public static void tune(Instrument i) {
// ...
i.play(Note.MIDDLE_C);
}
它接收一個Instrument reference。那麼，在這個例子中，編譯器如何才
有可能知道此Instrument reference 指向的是Wind 而非Brass 或
Stringed 呢？編譯器無能為力。想要對此課題做更深入的了解，必須仔細
檢驗繫結(binding)這個主題。
Method-call(函式呼叫)繫結方式
所謂「繫結(binding)」，就是建立method call(函式呼叫)和method
body(函式本體)的關聯。如果繫結動作發生於程式執行前(由編譯器和
連結器完成)，稱為「先期繫結(early binding)」。以往你可能從未聽
過這個名詞，因為程序式語言沒有其他選擇，一定是先期繫結。C 編譯器
只有一種method call，就是先期繫結。
316 Thinking in Java www.BruceEckel.com
前述範例程式之所以令人困惑，完全是因為先期繫結。因為，當編譯器手
上只握有一個Instrument reference 時，它無法得知究竟該呼叫哪一個
函式。
解決方法便是透過所謂的後期繫結(late binding)：繫結動作將在執行期
才根據物件型別而進行。後期繫結也被稱為執行期繫結( run-time
binding)或動態繫結(dynamic binding)。程式語言若欲實作出後期繫
結，必須具備「得以在執行期判知物件型別」並「呼叫其相應之函式」的
機制。也就是說，編譯器仍然不知道物件的型別，但「method call 機制」
會找出正確的method body 並加以呼叫。程式語言的後期繫結機制作法因
人而異，但是你可以想像，必得有某種「型別資訊」被置於物件內。
Java 的所有函式，除了被宣告為final 者，皆使用後期繫結。這意味在一
般情況下，你不需要判斷後期繫結動作何時發生- 它會自動發生。
為什麼會想將某個函式宣告為final 呢？一如前一章所述，這是為了防止
其他人覆寫該函式。但或許更重要的是，這麼做可以「關閉」動態繫結。
或者說，這麼做便是告訴編譯器：動態繫結是不需要的。於是編譯器便得
以為final method call 產生效率較佳的程式碼。不過大多數時候這麼做並
不會為你的程式帶來整體效能提昇。所以最好是基於設計上的考量來決定
是否使用final，而不要企圖藉由它來改善效能。
產生正確的行為
一旦你知道所有Java 函式都是透過後期繫結達到多型性之後，你便可以撰
寫與base class 溝通的程式碼。而且你也明白，同一份程式碼在面對所有
derived classes 時皆能運作無誤。另一個說法是：只要「發送訊息給某個
物件，讓該物件自行找到應該做的事」就好了。
OOP 中最經典的例子，莫過於「形狀(shape)」了。因為它極易被視覺
化，所以被廣泛採用。不幸的是這個例子容易誤導程式員以為OOP 僅能用
於圖形化程式設計，那當然不是真的。
Chapter 7: Polymorphism 317
在shape 範例程式中，有個名為Shape 的base class，以及許多不同的
derived class：Circle、Square、Triangle 等等。我們可以說「圓是一
種形狀」，這話極易理解。這便是這個例子之所以好的原因。classes 繼承
圖顯示了它們之間的關係：
Cast "up" the
inheritance
diagram
Circle
Handle
Shape
draw()
erase()
Circle
draw()
erase()
Square
draw()
erase()
Triangle
draw()
erase()
向上轉型可以發生在這麼簡單的一行述句中：
Shape s = new Circle();
這裡產生了一個Circle 物件，所得的reference 立即被指派給Shape。指
派(賦值)動作看似錯誤(將某個型別指派至另一型別)，但因為Circle
是一個Shape，這麼做絲毫沒有問題。所以，編譯器接受此行述句而不發
出錯誤訊息。
假設你呼叫某個base class 函式(它被derived class 覆寫)：
s.draw();
你也許會以為是Shape 的draw() 被喚起，因為s 終究是個Shape
reference。編譯器如何能夠得知其他任何事情呢！然而，由於後期繫結
(多型)，最終還是正確喚起了Circle.draw()。
下面這個例子有一點變化：
//: c07:Shapes.java
318 Thinking in Java www.BruceEckel.com
// Polymorphism in Java.
class Shape
void draw() {}
void erase() {}
}
class Circle extends Shape {
void draw()
System.out.println("Circle.draw()");
}
void erase()
System.out.println("Circle.erase()");
}
}
class Square extends Shape {
void draw()
System.out.println("Square.draw()");
}
void erase()
System.out.println("Square.erase()");
}
}
class Triangle extends Shape {
void draw()
System.out.println("Triangle.draw()");
}
void erase()
System.out.println("Triangle.erase()");
}
}
public class Shapes {
public static Shape randShape() {
switch((int)(Math.random() * 3)) {
default:
case 0: return new Circle();
case 1: return new Square();
case 2: return new Triangle();
Chapter 7: Polymorphism 319
}
}
public static void main(String[] args) {
Shape[] s = new Shape[9];
// Fill up the array with shapes:
for(int i = 0; i < s.length; i++)
s[i] = randShape();
// Make polymorphic method calls:
for(int i = 0; i < s.length; i++)
s[i].draw();
}
} ///:~
base class Shape 建立的是繼承自Shape 的所有classes 的共同介面- 也
就是說，所有形狀都能被繪製(draw)和擦拭(erase)。derived class 藉
由覆寫這些定義而提供自己(特定形狀)的獨特行為。
main class Shapes 含有一個static randShape()。每次呼叫它，它便產
生並回傳一個reference，指向隨機挑選的一個Shape 物件。請注意，其
中每一個return 述句，無論將「指向Circle 或Square 或Triangle」
之reference 回傳，都會發生向上轉型，使型別轉為Shape。所以當你呼
叫這個函式，你永遠無法察知你所獲得的物件的實際型別究竟為何，因為
你永遠只會拿到一個(被一般化了的)Shape reference。
main() 內含一個由Shape reference 組成的array，並透過randShape()
填入元素。此時，你知道你擁有一些Shapes，但你不知道任何更細部的
事情(編譯器也不知道)。不過當你一一走訪array 元素，並呼叫每個
Shape 的draw() 時，各型別的專屬行為竟然神奇地發生了。這可以從執
行結果得知：
Circle.draw()
Triangle.draw()
Circle.draw()
Circle.draw()
Circle.draw()
Square.draw()
Triangle.draw()
Square.draw()
Square.draw()
320 Thinking in Java www.BruceEckel.com
當然，由於每次執行都是隨機挑選不同的形狀，所以你會得到不同的執行
結果。採用隨機挑選，是為了更透徹地指出，在編譯期中，編譯器對於如
何產生正確的呼叫動作，可以完全不需任何特定知識。對draw() 的每一
次呼叫，都是透過動態繫結達成。
擴充性(Extensibility)
此刻，讓我們回到先前的樂器實例。因為有了多型，所以你可以依你的需
要，將任意數量的新型別加入系統，而無需更動tune()。在妥善設計的
OOP 程式中，大多數或甚至全部的函式都會依循tune() 的模式，並且只
與base class 介面相溝通。此類程式被稱為可擴充的(extensible)，因為
你可以藉由「從共通的base class 繼承出新的資料型別」來加入新功能。
處理base class 介面的那些函式，完全不需任何更動就可以因應新classes
的加入。
仔細想想，在樂器實例中，如果將更多函式加至base class，並加上許多新
的classes，會發生什麼事？下面是一張圖示：
Chapter 7: Polymorphism 321
Instrument
void play()
String what()
void adjust()
Wind
void play()
String what()
void adjust()
Stringed
void play()
String what()
void adjust()
Woodwind
void play()
String what()
Brass
void play()
void adjust()
Percussion
void play()
String what()
void adjust()
是的，不需更動tune()，所有新classes 便都能和舊classes 相安無事。即
使tune() 被置於另一個檔案，而Instrument 介面也加入了一些新函
式，但tune() 仍然無需重新編譯便能運作無誤。以下便是這個程式的實作
內容：
//: c07:music3:Music3.java
// An extensible program.
import java.util.*;
class Instrument { // 樂器
public void play() {
System.out.println("Instrument.play()");
}
public String what() {
return "Instrument";
}
322 Thinking in Java www.BruceEckel.com
public void adjust() {}
}
class Wind extends Instrument { // 管樂器
public void play() {
System.out.println("Wind.play()");
}
public String what() { return "Wind"; }
public void adjust() {}
}
class Percussion extends Instrument { // 敲擊樂器
public void play() {
System.out.println("Percussion.play()");
}
public String what() { return "Percussion"; }
public void adjust() {}
}
class Stringed extends Instrument { // 弦樂器
public void play() {
System.out.println("Stringed.play()");
}
public String what() { return "Stringed"; }
public void adjust() {}
}
class Brass extends Wind { // 銅管
public void play() {
System.out.println("Brass.play()");
}
public void adjust() {
System.out.println("Brass.adjust()");
}
}
class Woodwind extends Wind { // 木管
public void play() {
System.out.println("Woodwind.play()");
}
Chapter 7: Polymorphism 323
public String what() { return "Woodwind"; }
}
public class Music3 {
// Doesn't care about type, so new types
// added to the system still work right:
static void tune(Instrument i) {
// ...
i.play();
}
static void tuneAll(Instrument[] e) {
for(int i = 0; i < e.length; i++)
tune(e[i]);
}
public static void main(String[] args) {
Instrument[] orchestra = new Instrument[5];
int i = 0;
// Upcasting during addition to the array:
orchestra[i++] = new Wind();
orchestra[i++] = new Percussion();
orchestra[i++] = new Stringed();
orchestra[i++] = new Brass();
orchestra[i++] = new Woodwind();
tuneAll(orchestra);
}
} ///:~
新增加的函式是what() 和adjust()。what() 將class 描述文字以
String reference 回傳，adjust() 則提供樂器調音方式。
在main() 中，當你將某個reference 置於Instrument array 內，形同自
動向上轉型至Instrument。
我們發現，tune() 很幸福地完全不知道它週遭程式碼所發生的變動，依舊
正常運作。這正是我們所期望的多型帶來的效果。你所做的程式碼更動，
並不會傷害到程式中不應被影響的部份。換個角度來看，讓程式員「將變
動的事物與不變的事物隔離」的所有技術中，多型是最重要的技術之一。
324 Thinking in Java www.BruceEckel.com
覆寫(overriding)vs. 重載(overloading)
讓我們換個角度看看本章的第一個範例。下列程式中，play() 的介面在覆
寫過程中被改變了，這表示你其實並沒有覆寫(overridden)此一函式，
而是加以重載(overloaded)。編譯器允許你進行函式的重載(多載
化)，所以不會提出怨言。但這裡的行為或許並非你所想要：
//: c07:WindError.java
// Accidentally changing the interface.
class NoteX {
public static final int
MIDDLE_C = 0, C_SHARP = 1, C_FLAT = 2;
}
class InstrumentX {
public void play(int NoteX) {
System.out.println("InstrumentX.play()");
}
}
class WindX extends InstrumentX {
// OOPS! Changes the method interface:
public void play(NoteX n) {
System.out.println("WindX.play(NoteX n)");
}
}
public class WindError {
public static void tune(InstrumentX i) {
// ...
i.play(NoteX.MIDDLE_C);
}
public static void main(String[] args) {
WindX flute = new WindX();
tune(flute); // Not the desired behavior!
}
} ///:~
Chapter 7: Polymorphism 325
這個例子還呈現了另一件令人困惑的事實。在InstrumentX 中，play()
接受int，並以NoteX 做為識別字。是的，即使NoteX 是個class 名
稱，它仍舊可被用來做為識別字而不會引發任何錯誤訊息。而在WindX
中，play() 接收一個NoteX reference 並以n 做為識別字(當然你也可以
寫成play(NoteX NoteX) 而不會獲得任何編譯錯誤)。明眼人一下子便
可看出，程式員想覆寫play()，卻在撰寫函式時出現小小的打字失誤。請
注意，如果你遵守標準的Java 命名習慣，引數識別字應該是noteX(小
寫的’n’)，因而可以和class 名稱有所區別。
tune() 之內部發送play() 訊息給InstrumentX i，並以NoteX 的成員
之一(MIDDLE_C)做為引數。由於傳入的NoteX 成員是int，所以呼
叫的是本例重載後的play() 的int 版本- 因為沒有play() 覆寫版本可
用。
以下是輸出結果：
InstrumentX.play()
這當然不是一種polymorphical method call。了解事情的原由之後，我們
便能輕易修正此一問題。但如果這個問題被埋藏於大型程式中，請你想
想，找出這個問題的難度有多高。
Abstract classes(抽象類別)
和Abstract methods(抽象函式)
前述的樂器實例中，base class 內的所有函式都只是掛名性質。如果這些函
式被呼叫了，可能會引發一些問題。這是因為Instrument 的存在目的僅
止於為它的所有derived classes 提供「共同的介面」。
建立此一共同介面的唯一理由是，任何子型別都可以以不同方式來表現此
一共同介面。共同介面建立了一個基本形式，讓你可以陳述所有derived
classes 的共同點。
326 Thinking in Java www.BruceEckel.com
另一種說法便是將Instrument 稱為「抽象基礎類別(abstract base
class)」，或簡稱「抽象類別(abstract class)」。當你想要透過共通介
面來操作一組classes 時，便可撰寫abstract class。Derived class 中所有與
「base class 所宣告之標記式」相符的函式，都會透過動態繫結的機制來呼
叫。然而正如前一節所言，如果某個函式名稱和base class 函式名稱相
同， 但引數相異， 這是一種重載( overloading ) 行為， 而非覆寫
(overriding)行為。這或許不是你想要的。
如果你撰寫了一個像Instrument 這樣的abstract class，那麼其物件幾乎
沒有任何意義。也就是說Instrument 只被用來表示介面，沒有專屬的實
作內容。因此，產生Instrument 物件不僅完全沒有意義，你甚至可能希
望阻止使用者這麼做。只要讓Instrument 的所有函式都印出錯誤訊息，
就可以達成這個目的，但這麼做得等到執行期才能透露出這項資訊，而且
得在客戶端進行可信賴的持久性測試。如果我們能在編譯期就找出問題
來，當然最好。
對此，Java 提供了所謂abstract method 1機制。這是一種不完全的函式，
只有宣告而無本體。以下便是abstract method 的宣告語法：
abstract void f();
含有abstract methods(抽象函式)者我們稱為abstract class(抽象類
別)。如果class 含有單一或多個abstract methods，便需以關鍵字
abstract 做為這個class 的飾詞，否則編譯器會發出錯誤訊息。
如果class 是個半成品，那麼當我們試著產生其物件時，編譯器如何反應
呢？唔，為abstract class 產生任何物件都是不安全的，編譯器會發出錯誤
訊息。這是編譯器確保abstract class 純粹性的方式，因此你不必擔心自己
誤用它。
如果你繼承一個abstract class，並且希望為新型別產生物件，那麼你得為
base class 中的所有abstract methods 都提供相應的定義。如果沒有這麼做
1對C++程式員而言，abstract method 相當於C++ 的純虛擬函式
(pure virtual function)。
Chapter 7: Polymorphism 327
(這是你的選擇)，derived class 便也成為一個abstract class，而且編譯
器會強迫你以關鍵字abstract 來修飾這個derived class。
我們也可以將不含任何abstract methods 的class 宣告為abstract。如
果你不希望你所撰寫的class 被產生出任何實體，但這個class 又不具備
「擁有abstract methods」的實際理由時，這項性質便極為有用。
Instrument class 可被輕易轉變為abstract class。這其中只有某些函式
會變成抽象，因為將某個class 宣告為abstract，並不強迫你得將所有函
式都宣告為abstract。以下是可能的樣子：
abstract Instrument
abstract void play();
String what() { /* ... */ }
abstract void adjust();
Wind
void play()
String what()
void adjust()
Stringed
void play()
String what()
void adjust()
Woodwind
void play()
String what()
Brass
void play()
void adjust()
Percussion
void play()
String what()
void adjust()
extends extends
extends extends extends
以下便是運用了abstract classes(抽象類別)和abstract methods(抽
象函式)之後的管弦樂器修定版：
328 Thinking in Java www.BruceEckel.com
//: c07:music4:Music4.java
// Abstract classes and methods.
import java.util.*;
abstract class Instrument {
int i; // storage allocated for each
public abstract void play();
public String what() {
return "Instrument";
}
public abstract void adjust();
}
class Wind extends Instrument {
public void play() {
System.out.println("Wind.play()");
}
public String what() { return "Wind"; }
public void adjust() {}
}
class Percussion extends Instrument {
public void play() {
System.out.println("Percussion.play()");
}
public String what() { return "Percussion"; }
public void adjust() {}
}
class Stringed extends Instrument {
public void play() {
System.out.println("Stringed.play()");
}
public String what() { return "Stringed"; }
public void adjust() {}
}
class Brass extends Wind {
public void play() {
System.out.println("Brass.play()");
}
Chapter 7: Polymorphism 329
public void adjust()
System.out.println("Brass.adjust()");
}
}
class Woodwind extends Wind {
public void play() {
System.out.println("Woodwind.play()");
}
public String what() { return "Woodwind"; }
}
public class Music4 {
// Doesn't care about type, so new types
// added to the system still work right:
static void tune(Instrument i) {
// ...
i.play();
}
static void tuneAll(Instrument[] e) {
for(int i = 0; i < e.length; i++)
tune(e[i]);
}
public static void main(String[] args) {
Instrument[] orchestra = new Instrument[5];
int i = 0;
// Upcasting during addition to the array:
orchestra[i++] = new Wind();
orchestra[i++] = new Percussion();
orchestra[i++] = new Stringed();
orchestra[i++] = new Brass();
orchestra[i++] = new Woodwind();
tuneAll(orchestra);
}
} ///:~
你看到了，除了base class，實際上沒有任何改變。
撰寫abstract classes 和abstract methods 是很實用的，因為它們可以明
確宣示class 的抽象性質，並告訴使用者和編譯器它所設想的被運用方式。
330 Thinking in Java www.BruceEckel.com
建構式(Constructors)和多型(polymorphism)
一如以往，建構式異於其他函式。即便現在加入了多型，這句話仍然成
立。雖然建構式不具多型性格(但你還是可以擁有某種「虛擬建構式」，
詳見12 章)，但是了解如何在複雜的繼承架構中以建構式搭配多型，還是
相當重要的。這樣的了解可以幫助你避免一些令人不快的困擾。
建構式叫用順序(order of constructor calls)
建構式的叫用順序，第4 章已經簡短討論過，第6 章亦再次討論。但那些
討論都是在多型被引入之前。
derived class 建構式一定會呼叫base class 建構式，由此將繼承階層串連起
來，使每個base class 的建構式皆被喚起。這麼做是有用的，因為建構式
有個十分特殊的任務：檢視物件是否被妥善建立。derived class 僅能存取
其自身的成員，無法存取base class 的成員(那些成員通常被宣告為
private)。唯有base class 建構式才具備合宜的知識，可以將自身元素加
以初始化。也唯有base class 建構式才能存取其自身元素。因此，讓所有
建構式都能夠被呼叫到，是十分重要的，否則整個物件便無法建構成功。
這就是編譯器之所以「強迫derived class 建構式必須呼叫base class 建構
式」的原因。如果你未在derived class 建構式本體中明確呼叫base class
建構式，base class 的default 建構式便會被自動喚起。如果缺乏default
建構式，編譯器便發出錯誤訊息。(注意：在class 不帶有建構式的情形
下，編譯器會自動合成出一個default 建構式)。
讓我們看看下面這個例子， 它說明了複合( composition ) 、繼承
(inheritance)、多型(polymorphism)在建構順序上產生的效應：
//: c07:Sandwich.java
// Order of constructor calls.
class Meal {
Meal() { System.out.println("Meal()"); }
}
Chapter 7: Polymorphism 331
class Bread {
Bread() { System.out.println("Bread()"); }
}
class Cheese {
Cheese() { System.out.println("Cheese()"); }
}
class Lettuce {
Lettuce() { System.out.println("Lettuce()"); }
}
class Lunch extends Meal {
Lunch() { System.out.println("Lunch()");}
}
class PortableLunch extends Lunch {
PortableLunch() {
System.out.println("PortableLunch()");
}
}
class Sandwich extends PortableLunch {
Bread b = new Bread();
Cheese c = new Cheese();
Lettuce l = new Lettuce();
Sandwich()
System.out.println("Sandwich()");
}
public static void main(String[] args) {
new Sandwich();
}
} ///:~
這個例子以其他classes 為素材，製作出一個複雜的class；每個class 都擁
有一個能印出自己名稱的建構式。最重要的class 是Sandwich，它反映
出三階繼承(如果你把內定的Object 繼承也算在內的話，則是四階繼
承)，並擁有三個成員物件。當Sandwich 物件在main() 中被產生出
來，其輸出結果是：
332 Thinking in Java www.BruceEckel.com
Meal()
Lunch()
PortableLunch()
Bread()
Cheese()
Lettuce()
Sandwich()
這說明了此一複雜物件的建構式叫用順序如下：
1. 呼叫base class 建構式。這個步驟會反覆遞迴，使繼承階層的根源
最先被建構，然後是次一層derived class，直至最末一層derived
class 為止。
2. 根據各個成員的宣告順序， 呼叫各個成員的初值設定式
(initializers)。
3. 呼叫derived class 建構式本體。
建構式的叫用順序很重要。當你動用繼承機制，你已知道base class 的所
有資訊，並可存取base class 中宣告為public 和protected 的所有成
員。這意味當你置身於derived class 時，你必須假設base class 的所有成
員都是有效的。在一般函式之內，建構動作早已完成，所以物件內的所有
成份(譯註：因複合而形成的東西)的所有成員皆已建構完成。然而在建
構式中，你得設法讓你所使用的成員事先建構完成。要得到這樣的保證，
方法之一便是讓base class 的建構式先一步被喚起。然後，當你置身於
derived class 建構式時，base class 中所有可供取用的成員便已初始化完
畢。在建構式中「確知所有成員皆可被合法取用」這一理由，促使我們儘
可能在成員物件(亦即複合狀態，如上例的b、c、l)出現於class 定義式
時，便將它們初始化。如果你依循這個習慣，便能夠確保所有base classes
的成員以及當前這個物件的成員物件都已被初始化。不幸的是，這種做法
仍然無法因應所有情況。詳見下節。
Chapter 7: Polymorphism 333
繼承與finalize()
當你使用複合技術來撰寫新的class，你不需要煩惱它的成員物件的終止
(finalizing)問題。每個成員都是獨立物件，因此會被垃圾回收器回收並
終止。這和它恰巧是你的class 成員沒有任何關係。不過，在繼承關係中，
如果你有某些特別的清理動作(cleanup)得在垃圾回收時進行，你就得在
derived class 中覆寫finalize()。如果你這麼做，千萬別忘了呼叫base
class 的finalize() ， 因為如果不這樣， base class 的終止動作
(finalization)就不會發生。下面是一個驗證：
//: c07:Frog.java
// Testing finalize with inheritance.
class DoBaseFinalization {
public static boolean flag = false;
}
class Characteristic {
String s;
Characteristic(String c) {
s = c;
System.out.println(
"Creating Characteristic " + s);
}
protected void finalize() {
System.out.println(
"finalizing Characteristic " + s);
}
}
class LivingCreature {
Characteristic p =
new Characteristic("is alive");
LivingCreature() {
System.out.println("LivingCreature()");
}
protected void finalize() throws Throwable {
System.out.println(
"LivingCreature finalize");
334 Thinking in Java www.BruceEckel.com
// Call base-class version LAST!
if(DoBaseFinalization.flag)
super.finalize();
}
}
class Animal extends LivingCreature {
Characteristic p =
new Characteristic("has heart");
Animal() {
System.out.println("Animal()");
}
protected void finalize() throws Throwable {
System.out.println("Animal finalize");
if(DoBaseFinalization.flag)
super.finalize();
}
}
class Amphibian extends Animal {
Characteristic p =
new Characteristic("can live in water");
Amphibian() {
System.out.println("Amphibian()");
}
protected void finalize() throws Throwable {
System.out.println("Amphibian finalize");
if(DoBaseFinalization.flag)
super.finalize();
}
}
public class Frog extends Amphibian {
Frog() {
System.out.println("Frog()");
}
protected void finalize() throws Throwable {
System.out.println("Frog finalize");
if(DoBaseFinalization.flag)
super.finalize();
}
Chapter 7: Polymorphism 335
public static void main(String[] args) {
if(args.length != 0 &&
args[0].equals("finalize"))
DoBaseFinalization.flag = true;
else
System.out.println("Not finalizing bases");
new Frog(); // Instantly becomes garbage
System.out.println("Bye!");
// Force finalizers to be called:
System.gc();
}
} ///:~
class DoBaseFinalization 中只有一個旗標，用以代表「每個繼承階層中
的class 是否呼叫super.finalize() 」。程式會依據命令列引數
(command line argument)來設定旗標值，讓你觀察帶有(或不帶有)
base class 終止動作的行為表現。
在這個階層體系中，每個class 都含有一個Characteristic 成員物件。你
會發現， 無論base class 的終止式( finalizers ) 是否被呼叫，
Characteristic 成員物件都一定會被終止。
每個被覆寫的finalize() 至少得具有存取protected 成員的權限，因為
class Object 的finalize() 是個protected 函式，而編譯器不允許你在繼
承過程中降低存取權限(注意："Friendly" 的存取權限小於protected)
在Frog.main() 中，DoBaseFinalization 旗標會被設立，並產生一個
Frog 物件。記住，垃圾回收動作(更明確地說是終止動作)可能不會發生
於某個物件身上。所以，為了強迫讓垃圾回收動作發生，我們呼叫
System.gc() 觸發垃圾回收動作的進行，並因此引發終止動作。如果不進
行base class 終止動作，輸出結果是：
Not finalizing bases
Creating Characteristic is alive
LivingCreature()
Creating Characteristic has heart
Animal()
Creating Characteristic can live in water
Amphibian()
336 Thinking in Java www.BruceEckel.com
Frog()
Bye!
Frog finalize
finalizing Characteristic is alive
finalizing Characteristic has heart
finalizing Characteristic can live in water
你可以看到，的確沒有Frog 的任何base classes 的finalizers(終止式)
被喚起(至於其成員物件則如你所預期地被終止了)。如果你在命令列加
入"finalize" 引數，你會得到這樣的結果：
Creating Characteristic is alive
LivingCreature()
Creating Characteristic has heart
Animal()
Creating Characteristic can live in water
Amphibian()
Frog()
bye!
Frog finalize
Amphibian finalize
Animal finalize
LivingCreature finalize
finalizing Characteristic is alive
finalizing Characteristic has heart
finalizing Characteristic can live in water
雖然成員物件的終止順序和生成順序相同，但技術上而言，物件的終止順
序是未經規範的。不過，透過base classes，你可以控制終止順序。最佳順
序便如此處所示範，也就是與初始化順序恰恰相反。依循此種(C++用於
解構式的)形式，你應該先執行derived class 的終止式，然後才是base
class 的終止式。這是因為derived class 的終止動作可能會呼叫某些base
class 函式，而這些終止動作的正常運作有賴其「base class 成份」仍舊可
用才行，所以你不能過早加以摧毀。
Chapter 7: Polymorphism 337
polymorphic methods 在建構式中的行為
constructor calls(建構式叫用動作)的階層架構，突顯了一個有趣的兩難
局面。如果在建構式中呼叫「正在建構中的那個物件」的某個動態繫結的
函式，會發生什麼事？如果這發生在一般函式之中，你可以想像會發生什
麼事：執行期間會解析這個動態繫結呼叫動作，因為物件並不知道它究竟
屬於此一函式所隸屬的class，還是屬於其某個derived class。基於一致
性，你可能會認為這也是建構式中發生的行為。
事實並非如此。如果你在建構式中呼叫動態繫結的某個函式，會喚起該函
式被覆寫(overridden)後的定義。然而其效應無法預期，甚至可能會遮
蓋某些難以發現的臭蟲。
就觀念而言，建構式的任務是讓物件從無到有(這很難被視為一般性工
作)。在任何建構式中，整個物件可能僅有部份被形成- 你只能確知
「base class 成份」已形成，但你無法知道有哪些classes 繼承自你。然而
一個動態繫結的method call 會在繼承階層中向外發散。它會呼叫到
derived class 的函式。如果你在建構式中這麼做的話，你便會喚起某個函
式，其中可能取用尚未被初始化的一些成員。這當然是災難的開始。
你可以從以下例子觀察到這個問題：
//: c07:PolyConstructors.java
// Constructors and polymorphism
// don't produce what you might expect.
abstract class Glyph {
abstract void draw();
Glyph() {
System.out.println("Glyph() before draw()");
draw();
System.out.println("Glyph() after draw()");
}
}
338 Thinking in Java www.BruceEckel.com
class RoundGlyph extends Glyph {
int radius = 1;
RoundGlyph(int r) {
radius = r;
System.out.println(
"RoundGlyph.RoundGlyph(), radius = "
+ radius);
}
void draw()
System.out.println(
"RoundGlyph.draw(), radius = " + radius);
}
}
public class PolyConstructors {
public static void main(String[] args) {
new RoundGlyph(5);
}
} ///:~
在Glyph 中，draw() 是抽象的(abstract)，所以其作用是讓其他人進
行覆寫。於是你被強迫在RoundGlyph 中加以覆寫。但Glyph 建構式呼
叫了此一函式，結果喚起了RoundGlyph.draw()。這似乎就是我們的意
圖，現在請看看輸出結果：
Glyph() before draw()
RoundGlyph.draw(), radius = 0
Glyph() after draw()
RoundGlyph.RoundGlyph(), radius = 5
當Glyph 建構式呼叫draw() 時，radius 尚未被設定初值1，其值當時
為0。這可能造成只有一個點(或甚至沒有任何東西)被繪製於螢幕上。
你會在一旁乾瞪眼，並試圖找出這個程式無法正常運作的原因。
前一節所描述的初始化順序並不十分完整，而這正是此一謎題的解答關
鍵。實際的初始化過程是：
Chapter 7: Polymorphism 339
1. 任何事情發生之前，配置給此物件的儲存空間會被初始化為二進制
零值(binary zero)。
2. 以先前所述方式，呼叫base class 建構式。此時，覆寫後的draw()
會被呼叫(在RoundGlyph 建構式被呼叫之前)。由於步驟1 之
故，draw() 看到的radius 值為零。
3. 以「成員宣告順序」來呼叫各成員的初始式(initializers)。
4. 呼叫derived class 建構式本體。
這個過程有好的一面，那就是每樣東西至少都會先被初始化為零值(不論
零值對特定資料型別而言是否有意義)，而不是雜七雜八的內容。即使是
「藉由複合手法而被置於class 內」的object references，其值都會是
null。所以如果你忘了為該reference 設定初值，便會在執行期收到異常。
所有其他物件的值也都是零- 那常常是檢視輸出結果時顯露問題的地方。
從另一個角度說，這個程式的結果應該會令你感到十分驚恐。你做的一切
都符合邏輯，其行為卻不可思議地出錯了，而編譯器沒有給你任何訊息
(C++在這個情況下有比較合理的行為)。諸如此類的臭蟲很容易隱匿起
來，得花許多時間才能把它們找出來。
因此，撰寫建構式時，一條原則便是：「儘可能簡單地讓物件進入正確狀
態。如果可以的話，別呼叫任何函式」。建構式中唯一可以安全呼叫的函
式便是「base class 中的final 函式」(這對private 函式來說一樣成立，
因為它們天生就是final)。此類函式無法被覆寫，也就不會產生這一類令
人驚訝的結果。
將繼承(inheritance)運用於設計
學習了多型(polymorphism)之後，你可能覺得每樣東西都應該被繼承，
因為多型是如此巧妙。這麼做可能會造成設計上的負擔；事實上當你使用
既有的class 來產生新的class 時，如果先選擇繼承手法，有可能導致不必
要的複雜情況。
340 Thinking in Java www.BruceEckel.com
當你不知道該選擇「繼承」或「複合」手法時，最好先選擇複合。複合手
法不會強迫你的設計出現一大串繼承階層架構。複合手法的彈性比較大，
因為它可以動態選擇一個型別(也就選擇了其行為)。如果使用繼承手
法，便得在編譯期知道確切型別。以下例子說明這一點：
//: c07:Transmogrify.java
// Dynamically changing the behavior of
// an object via composition.
abstract class Actor {
abstract void act();
}
class HappyActor extends Actor {
public void act()
System.out.println("HappyActor");
}
}
class SadActor extends Actor {
public void act()
System.out.println("SadActor");
}
}
class Stage {
Actor a = new HappyActor();
void change() { a = new SadActor(); }
void go() { a.act(); }
}
public class Transmogrify {
public static void main(String[] args) {
Stage s = new Stage();
s.go(); // Prints "HappyActor"
s.change();
s.go(); // Prints "SadActor"
}
} ///:~
Chapter 7: Polymorphism 341
此例之中，Stage 物件含有一個Actor reference，其初值指向一個
HappyActor 物件。這表示go() 會產生某種特殊行為。由於reference 可
於執行期被重新繫結至另一個不同的物件，所以我們可以將「指向
SadActor 物件」的reference 置入a 中，造成go() 的行為改變。於是我
們獲得了執行期的動態彈性。這種手法又被稱為State Pattern，詳見
《Thinking in Patterns with Java》(此書可於www.BruceEckel.com 下
載)。相較之下，你無法於執行期決定繼承對象，你一定得在編譯期決定
之。
下面是個一般準則：「請以繼承表達行為上的差異，以資料成員表達狀態
(state)上的變化」。上述例子同時使用了兩者：兩個不同的classes 被衍
生出來，表達act() 的行為差異，Stage 則以複合手法來允許狀態變化。
本例的狀態變化導致了行為變化。
純粹繼承(Pure inheritance)vs. 擴充(extension)
學習繼承時，最聰明的方法似乎是採用「純粹」繼承來建立整個繼承體
系。也就是說，只有base class(或謂interface)所建立的函式，才被
derived class 加以覆寫，如下所示：
Shape
draw()
erase()
Circle
draw()
erase()
Square
draw()
erase()
Triangle
draw()
erase()
這種作法可被視為純粹的is-a(是一種)關係，因為class 的介面確立了
它究竟是什麼。繼承機制確保所有derived class 都具備和base class 相同
342 Thinking in Java www.BruceEckel.com
的介面，而且一模一樣。如果你採用上述圖示，那麼derived classes 除了
「base class 介面」之外一無長物。
這種方式可被視為「純取代(pure substitution)」，因為derived class
物件可被完全取代為base class，而且當你使用它們時，完全不需要知道關
於subclass 的任何額外資訊。
Circle, Square,
Line, or new type
of Shape
Talks to Shape
Message
"Is-a"
relationship
也就是說，base class 可以接收所有發送給derived class 的訊息，因為二者
具有一模一樣的介面。你只需做一件事，便是將derived class 向上轉型，
完全不需回頭檢視你所處理的物件的確切型別。所有事務都可以透過多型
(polymorphism)來處理。
當你從這個角度來理解，似乎只有純粹的is-a 關係才是唯一合乎情理的作
法。所有其他設計都象徵不潔的思考方式，當然也就是拙劣的設計。是
嗎？呃，這是個陷阱。當你深入思考，你馬上會改變想法，並且發現，
「擴充介面(extending the interface)」才是解決特定問題的完美解答
(關鍵字extends 似乎也在鼓勵大家這麼做)。這種形式可被視為islike-
a(像是一個)的關係，因為derived class 像是一個base class：它具
備相同的基礎介面，以及由額外函式加以實作的功能。
Chapter 7: Polymorphism 343
Useful
void f()
void g()
void f()
void g()
void u()
void v()
void w()
MoreUseful
} Assume this
represents a big
interface
"Is-like-a"
} Extending
the interface
雖然這是有用而且合理的作法(視運用情況而定)，但它仍有缺點。在
derived class 中擴充的介面，在base class 中無法使用。所以當你向上轉型
之後，便無法呼叫新增的函式：
Useful part
Talks to Useful
object Message
MoreUseful
part
如果你沒有向上轉型，這便不會困擾到你。但你常常會遇到某些情況，使
你一定得知道物件的確切型別，才能夠存取該型別所擴充的函式。下一節
告訴你該怎麼做。
向下轉型(downcasting)與
執行期型別辨識(run-tine type identification)
由於向上轉型(亦即在繼承階層中向上移動)會遺失型別資訊，我們很自
然聯想，向下轉型(亦即在繼承階層中向下移動)可以取回型別資訊。不
過你知道，向上轉型絕對安全，因為base class 不會具備比derived class
344 Thinking in Java www.BruceEckel.com
更大型的介面，因此所有經由base class 介面所發送的訊息，都保證會被
接受。但使用向下轉型時，你無法明確知道「某個形狀實際上是圓形」。
喔，它可能是三角形、正方形、或其他形狀。
Useful
void f()
void g()
void f()
void g()
void u()
void v()
void w()
MoreUseful
} Assume this
represents a big
interface
"Is-like-a"
} Extending
the interface
為了解決上述問題，必須有某種方法保證向下轉型的正確性，使你不致於
一不小心做了錯誤的轉型動作，進而送出該物件無法接受的訊息- 這將是
極不安全的動作。
某些程式語言(如C++)為了確保向下轉型的安全，要求你執行某個特殊
動作(譯註：dynamic_cast)。但Java 裡頭的每個轉型動作都會被檢查！
所以即使看起來不過是以小括號表示的一般轉型動作，執行時期卻會加以
檢查以確保它的確是你所認知的型別。如果轉型不成功，你便會收到
ClassCastException。「在執行時期檢驗型別」這一動作被稱為「執行
期型別辨識(run-time type identification，RTTI)」。下例說明RTTI 的
行為：
//: c07:RTTI.java
// Downcasting & Run-time Type
// Identification (RTTI).
import java.util.*;
class Useful {
public void f() {}
Chapter 7: Polymorphism 345
public void g() {}
}
class MoreUseful extends Useful {
public void f() {}
public void g() {}
public void u() {}
public void v() {}
public void w() {}
}
public class RTTI {
public static void main(String[] args) {
Useful[] x = {
new Useful(),
new MoreUseful()
};
x[0].f();
x[1].g();
// Compile-time: method not found in Useful:
//! x[1].u();
((MoreUseful)x[1]).u(); // Downcast/RTTI
((MoreUseful)x[0]).u(); // Exception thrown
}
} ///:~
一如上頁圖片所示，MoreUseful 擴充了Useful 的介面。但因為它是繼
承而來，所以它也可以向上轉型至Useful。你可以在main() 的array x
初始化過程中看到這樣的向上轉型動作。由於array 中的兩個物件都是
class Useful，所以你可以對著兩者呼叫f() 和g()。如果你嘗試呼叫u()
(它僅存於MoreUseful 內)，便會收到編譯期錯誤訊息。
如果你想取用MoreUseful 物件內的擴充介面，可試著向下轉型。如果你
的轉型目標是正確的型別， 轉型動作便會成功。反之則會收到
ClassCastException。你不需要為此異常撰寫任何程式碼，因為它所代
表的是任何程式員可能在任何程式地點犯下的一種錯誤。
346 Thinking in Java www.BruceEckel.com
RTTI 比單純的轉型包含了更多內涵。舉例而言，有個方法可以讓你在嘗試
向下轉型之前，先取得你所處理的型別。第12 章便是討論Java 執行期型
別辨識(RTTI)機制的各個不同面向。
摘要
多型(polymorphism)意謂「不同的形式(difference forms)」。在物件
導向程式設計中，你會有同一份表徵(face，亦即base class 所提供的共同
介面) ， 以及不同的表徵運用形式： 不同版本的動態繫結函式
(dynamically bound methods)。
你已經在本章中看到，如果不使用資料抽象性和繼承，就不可能了解多型
並進而運用多型。多型是一個無法被單獨對待的特性，只能協同運作，作
為「class 相對關係」大局(a "big picture" of class relationshops)中的一
部份。人們常會被Java 的其他「非物件導向功能」混淆，例如「函式重
載」有時候會被說成是物件導向性質。啊，千萬別受騙：只要不是後期繫
結，就不是多型。
想要有效率地在程式中使用多型(以及物件導向技術)，你得延伸你的設
計視野，不僅觀察個別class 的成員和訊息(譯註：此處「訊息」意指
class 能接受的函式呼叫)，也要注意classes 之間的共通性及其彼此關
係。雖然這需要付出可觀的心力，但值得。因為這麼做能夠帶來更快速的
程式開發時程、更好的程式組織、可擴充的程式碼、以及更好的維護性。
練習
某些經過挑選的題目，其解答置於《The Thinking in Java Annotated Solution Guide》電子文件中。
僅需小額費用便可自www.BruceEckel.com.網站取得。
1. 將某個會印出訊息的函式加至Shapes.java 的base class 內，但不
在derived class 中加以覆寫。請解釋所發生的事情。然後在某個
(而非全部)derived class 中覆寫此一函式，並觀察所發生的事
情。最後，在所有derived class 中覆寫此一函式。
Chapter 7: Polymorphism 347
2. 將新的Shape 型別加至Shapes.java，並在main() 中檢查多型
是否作用於你的新型別身上，就像作用於舊型別那般。
3. 改寫Music3.java，使what() 成為Object 的toString()。請
使用System.out.println() ( 不進行任何轉型) 來印出
Instrument 物件內容。
4. 將新的Instrument 型別加入Music3.java，然後檢查多型是否
作用於你的新型別身上。
5. 修改Music3.java，使這個程式能以Shapes.java 中的方式隨機
產生Instrument 物件。
6. 建立Rodent(齧齒目動物)的繼承階層結構：Mouse(家鼠)、
Gerbil(沙鼠)、Hamster(倉鼠)等等。在base class 中提供
所有Rodents 的共同函式，並於derived classes 中加以覆寫，根
據特定的Rodent 型別，執行不同的行為。現在，產生一個
Rodent array，填入不同的Rodent 型別，並呼叫base class 函
式，觀察究竟會發生什麼事。
7. 修改上題，讓Rodent 成為abstract class。並將Rodent 的函式
宣告為abstract - 如果可以的話。
8. 產生某個abstract class，並令它不含任何abstract methods。驗
證你的確無法為該class 產生一份實體。
9. 將Pickle(醃菜)加入Sandwich.java。
10. 修改練習6，使它展示base class 和derived class 的初始化順序。
然後在base class 和derived classes 中加入成員物件，並顯示建構
過程中它們的初始化動作發生順序。
11. 建立一個三階繼承體系。每一階class 都應該擁有finalize()，而
且這些函式都應該適當呼叫base class 的finalize()。請驗證你的
繼承體系運作恰當。
348 Thinking in Java www.BruceEckel.com
12. 撰寫一個base class，具有兩個函式，並在第一個函式中呼叫第二
個函式。然後，衍生一個新的class，並於其中覆寫第二個函式。現
在，產生一個derived class 物件，將它向上轉型至基礎型別(base
type)並呼叫第一個函式。請解釋所發生的事情。
13. 撰寫一個base class，具有abstract print()，並在derived class
中覆寫之。覆寫後的版本會印出derived class 所定義的某個int 變
數值。在此變數的定義地點，給予某個非零值。在base class 建構
式中呼叫此一函式。現在，在main() 中產生一個derived class 物
件，然後呼叫其print()。請解釋所發生的事情。
14. 依循Transmogrify.java 的例子，撰寫一個Starship class，內
含一個AlertStatus reference，它可以代表三種不同狀態。加入一
些能夠改變狀態(states)的函式。
15. 撰寫一個abstract class，不具任何函式。自此衍生出一個class，
並為它加上一個函式。撰寫某個static 函式，使其接受一個「指向
base class」的reference，並將它向下轉型為derived class，然後
呼叫前述那個函式。請在main() 中驗證這是可行的。接著，將此
函式的abstract 飾詞移至base class，因而免去向下轉型的需要。
349
8: Interfaces(介面)與
Inner Classes(內隱類別)
Interfaces(介面)和inner classes(內隱類別)，為你系
統中的物件提供更為精巧的組織與控制方式。
C++ 不含上述兩類機制- 雖然熟練的C++ 程式員還是能夠加以模擬。
Interfaces 和inner classes 存在於Java 之中，反映出它們的重要性已經受
到肯定，因而有必要透過語言關鍵字，提供直接的支援。
在第7 章中，你已經學到了關鍵字abstract。此一關鍵字讓你得以撰寫
「在class 中不具實際定義」的單一或多個函式- 是的，你只提供介面部
份而不提供相應的實作細目。實作細目由繼承者負責撰寫。本章即將介紹
的關鍵字interface 則造出完全抽象的class，絲毫不帶半點實作內容。很
快你會學到，interface 更勝於abstract class，因為我們能夠藉以撰寫出
「可被向上轉型為多個基本型別」的class，而達到C++ 多重繼承的變
形。
本章的另一個主題inner classes，乍看之下不過是單純的程式碼隱藏機
制：將classes 置於其他classes 之中。不過你會學到，inner classes 其實
更甚於此，它不僅知曉外圍(surrounding)class 的存在，亦能與之溝
通。雖然對大多數人來說，inner classes 是個新觀念，但是以inner classes
完成的程式碼比較優雅清晰。不過你得花一些時間才能夠自在地以inner
classes 進行設計。
Interfaces(介面)
關鍵字interface 將abstract 的概念做了更進一步的發揮。你可以想像
它是「純粹」的abstract class。它讓撰寫者得以建構出class 的形式：函
350 Thinking in Java www.BruceEckel.com
式的名稱、引數列、回傳型別，但不含函式主體。interface 可以內含資
料成員，但這些資料成員都會自然而然成為static 和final。是的，
interface 所提供的只是形式( form ) ， 不含實作細目
(implementation)。
interface 所陳述的是：「所有實作出本介面的classes，看起來都應該像
這樣」。因此，使用某個interface 的所有程式碼便都知道，經由該
interface 所能夠喚起的函式有哪些，而且也就只有那些。可以說，所謂
interface 是在classes 之間建立起一個協定(protocol)。某些物件導向
編程語言以關鍵字protocol 來達到相同目的。
撰寫interface 時，請使用關鍵字interface 而非關鍵字class。你可以
在關鍵字interface 之前加上關鍵字public(但只有當這個interface 被
定義於同名檔案中才行)，否則它就成為"friendly"，僅可被使用於同一個
package 之內。
如果想讓某個class 符合某一個(或某一組)特定的interface，請使用關
鍵字implements。這麼做相當於宣告「所謂interface 只是外觀描述，
而我現在要說明它的運作方式」。這種型式看起來像繼承，以下的樂器圖
說明了這一點(譯註：請和p327 圖比較)：
Chapter 8: Interfaces & Inner Classes 351
interface Instrument
void play();
String what();
void adjust();
Wind
void play()
String what()
void adjust()
Stringed
void play()
String what()
void adjust()
Woodwind
void play()
String what()
Brass
void play()
void adjust()
Percussion
void play()
String what()
void adjust()
extends extends
implements implements implements
一旦你實作了某個interface，該份實作品便成為一個一般的class，能以
一般方式加以繼承。
你可以將interface 中的函式明白宣告為public。但即便沒有這麼宣告，
它們也會是public。所以當你實作(implement)某個interface 時，必
須將承襲自該interface 的所有函式都定義為public。否則它們的預設屬
性會是"friendly"，而你也就因此在繼承過程中降低了存取權限- 這在
Java 編譯器中是不允許的。
從新版的Instrument 中你可以觀察到這一點。請注意，interface 中的
每個函式都只能是宣告， 因為編譯器也只允許你這麼做。此外，
Instrument 中的眾多函式，沒有任何一個被宣告為public，但它們仍將
自動地被設為public：
352 Thinking in Java www.BruceEckel.com
//: c08:music5:Music5.java
// Interfaces.
import java.util.*;
interface Instrument {
// Compile-time constant:
int i = 5; // static & final
// Cannot have method definitions:
void play(); // Automatically public
String what();
void adjust();
}
class Wind implements Instrument {
public void play() {
System.out.println("Wind.play()");
}
public String what() { return "Wind"; }
public void adjust() {}
}
class Percussion implements Instrument {
public void play() {
System.out.println("Percussion.play()");
}
public String what() { return "Percussion"; }
public void adjust() {}
}
class Stringed implements Instrument {
public void play() {
System.out.println("Stringed.play()");
}
public String what() { return "Stringed"; }
public void adjust() {}
}
class Brass extends Wind {
public void play() {
System.out.println("Brass.play()");
}
Chapter 8: Interfaces & Inner Classes 353
public void adjust()
System.out.println("Brass.adjust()");
}
}
class Woodwind extends Wind {
public void play() {
System.out.println("Woodwind.play()");
}
public String what() { return "Woodwind"; }
}
public class Music5 {
// Doesn't care about type, so new types
// added to the system still work right:
static void tune(Instrument i) {
// ...
i.play();
}
static void tuneAll(Instrument[] e) {
for(int i = 0; i < e.length; i++)
tune(e[i]);
}
public static void main(String[] args) {
Instrument[] orchestra = new Instrument[5];
int i = 0;
// Upcasting during addition to the array:
orchestra[i++] = new Wind();
orchestra[i++] = new Percussion();
orchestra[i++] = new Stringed();
orchestra[i++] = new Brass();
orchestra[i++] = new Woodwind();
tuneAll(orchestra);
}
} ///:~
其餘程式碼的運作方式不變，它們和「向上轉型的目標究竟是名為
Instrument 的一般class，抑或名為Instrument 的abstract class，
抑或名為Instrument 的interface」沒有絲毫關係，行為都相同。事實
上，你可以在tune() 中觀察到，沒有任何跡象顯示Instrument 究竟是
354 Thinking in Java www.BruceEckel.com
個一般class 或是個abstract class，或是一個interface。這正是目的所
在：每種方法都賦予程式員面對「物件的生成和使用」時有不同的掌控。
Java 的多重繼承(multiple inheritance in Java)
interface 不單只是一種「更純粹」的abstract class，其用途更甚於此。
由於interface 不帶任何實作細目，也就是說interface 不與任何儲存空
間有關連，因此合併多個interfaces 是一件輕而易舉的工作，編譯器不需
如臨大敵。此事極具價值，因為有時候你需要宣告「x 是個a，也是個b，
同時也是個c」。在C++中，「合併多個class 介面」的行為稱為多重繼承
(multiple inheritance)，其中揹負著某種頗為棘手的包袱，因為每個
class 都內含實作細目。在Java 裡頭你可以進行同樣的動作，但其中只有
一個class 可以擁有實作內容。因此，合併多個介面時，C++所面臨的問題
不會出現於Java 之中：
Abstract or Concrete
Base Class
interface 1
interface 2
interface n
Base Class Functions interface 1 ... interface 2 interface n
......
derived class 並不一定非得有個抽象或具象(無任何abstract methods)
的base class。但如果它繼承自non-interface(譯註：亦即抽象或具象
class)，便僅能繼承一個，其餘繼承來源都得是interfaces 才行。請將
繼承的interfaces 名稱置於關鍵字implements 之後，並以逗號隔開。
繼承而來的interfaces 數目不受限制，每一個都是獨立型別，都可以成為
你向上轉型的目標。以下示範組合多個interfaces 及一個具象class：
//: c08:Adventure.java
// Multiple interfaces.
import java.util.*;
Chapter 8: Interfaces & Inner Classes 355
interface CanFight {
void fight();
}
interface CanSwim {
void swim();
}
interface CanFly {
void fly();
}
class ActionCharacter {
public void fight() {}
}
class Hero extends ActionCharacter
implements CanFight, CanSwim, CanFly {
public void swim() {}
public void fly() {}
}
public class Adventure {
static void t(CanFight x) { x.fight(); }
static void u(CanSwim x) { x.swim(); }
static void v(CanFly x) { x.fly(); }
static void w(ActionCharacter x) { x.fight(); }
public static void main(String[] args) {
Hero h = new Hero();
t(h); // Treat it as a CanFight
u(h); // Treat it as a CanSwim
v(h); // Treat it as a CanFly
w(h); // Treat it as an ActionCharacter
}
} ///:~
你看到了，Hero 結合了具象類別ActionCharacter，以及CanFight、
CanSwim、CanFly 等interfaces。當你經由這種方式，將某個具象類別
和其他interfaces 結合在一起時，你得先寫下具象類別的名稱，然後才是
interfaces 的名稱，否則編譯器會發出錯誤訊息。
356 Thinking in Java www.BruceEckel.com
請注意，interface CanFight 及class ActionCharacter 中的fight()
的標記式(signature)是一致的，而且Hero 之中並未提供fight() 的定
義。interface 的遊戲規則是，你可以繼承interface(稍後便示範)，
得到的將又是一個interface。如果你要以此新型別生成一個物件，此一
型別必須是個定義齊全的class。不過雖然Hero 自身並未提供fight() 的
定義，但因ActionCharacter 擁有fight() 的定義，被自動繼承下來，
因此我們還是可以產生Hero 物件，沒有問題。
在class Adventure 中你可以觀察到，共有四個函式分別接受不同的
interfaces 和concrete class 做為引數。一旦Hero 物件被生成，便可被傳
入這些函式中的任何一個。這其實就是將該物件向上轉型至各個對應的
interface。Java 對interface 的設計方式，使得上述動作一點都不麻煩，
而且不需要程式員付出額外心力。
請千萬記得，interfaces 存在的根本原因已在上例中展現：能夠被向上轉型
至多個基本型別。至於使用interfaces 的第二個理由，和使用abstract
base class(抽象基礎類別)一致：讓客端程式員無法產生其物件，並因此
確保這只是一個「介面」(而無實體)。這同時引發了一個問題：究竟應
該使用interface 還是使用abstract class？interface 同時賦予你
abstract class 和interface 的好處，因此如果你的base class 可以不帶任
何函式定義式或任何成員變數，你應該優先選用interfaces。事實上如果
你知道某個東西將會成為base class ，你的優先考量便是使它成為
interface ， 只有在必須帶有函式定義式或成員變數時， 才請改用
abstract class，或甚至(必要時)改用concrete class。
介面合併時的名稱衝突(name collisions)問題
當你實作多重介面時，可能會掉進一個小小的陷阱。上例之中CanFight
和ActionCharacter 具有完全相同的void fight()。這沒有問題，因為
兩者的fight() 完全相同。但如果不是這樣呢？以下便是一例：
//: c08:InterfaceCollision.java
Chapter 8: Interfaces & Inner Classes 357
interface I1 { void f(); }
interface I2 { int f(int i); }
interface I3 { int f(); }
class C { public int f() { return 1; } }
class C2 implements I1, I2 {
public void f() {}
public int f(int i) { return 1; } // overloaded
}
class C3 extends C implements I2 {
public int f(int i) { return 1; } // overloaded
}
class C4 extends C implements I3 {
// Identical, no problem:
public int f() { return 1; }
}
// Methods differ only by return type:
//! class C5 extends C implements I1 {}
//! interface I4 extends I1, I3 {} ///:~
這個例子顯現出困難所在， 因為覆寫( overriding ) 、實作
(implementation)、重載(overloading)通通令人不愉快地混雜在一
起，而且重載函式無法僅靠回傳型別(return type)做為區隔。當最後兩
行註解被移走，錯誤訊息便解釋了一切：
InterfaceCollision.java:23: f() in C cannot
implement f() in I1; attempting to use
incompatible return type
found : int
required: void
InterfaceCollision.java:24: interfaces I3 and I1 are
incompatible; both define f
(), but with different return type
這裡我刻意結合不同的interfaces 並使用其中同名的函式，造成程式碼可
讀性的混亂。是的，請盡力避免此種情況。
358 Thinking in Java www.BruceEckel.com
透過繼承來擴充interface
利用繼承，你可以輕易將新的函式加至interface 中，也可以透過繼承將
多個interfaces 結合為一個新的interface。以下便示範這兩種產生新
interface 的手法：
//: c08:HorrorShow.java
// Extending an interface with inheritance.
interface Monster {
void menace();
}
interface DangerousMonster extends Monster {
void destroy();
}
interface Lethal {
void kill();
}
class DragonZilla implements DangerousMonster {
public void menace() {}
public void destroy() {}
}
interface Vampire
extends DangerousMonster, Lethal {
void drinkBlood();
}
class HorrorShow {
static void u(Monster b) { b.menace(); }
static void v(DangerousMonster d) {
d.menace();
d.destroy();
}
public static void main(String[] args) {
Chapter 8: Interfaces & Inner Classes 359
DragonZilla if2 = new DragonZilla();
u(if2);
v(if2);
}
} ///:~
在這裡，DangerousMonster 單純只是擴充Monster 而得到的一個新
的interface，實作於DragonZilla。
Vampire 所使用的語法只適用於interfaces 繼承。一般情況下你只能將
extends 應用於單一class，但由於interface 可由多個interfaces 組成，
所以製作新的interface 時， extends 也可用來指涉多個base
interfaces。如你所見，只要以逗號隔開多個interface 名稱即可。
產生常數群(grouping constants)
由於interface 中的所有資料成員都會自動成為static 和final，所以對
於常數群的產生(就如C 或C++中的enum 一樣)，interface 是個十分
便利的工具。例如：
//: c08:Months.java
// Using interfaces to create groups of constants.
package c08;
public interface Months {
int
JANUARY = 1, FEBRUARY = 2, MARCH = 3,
APRIL = 4, MAY = 5, JUNE = 6, JULY = 7,
AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,
NOVEMBER = 11, DECEMBER = 12;
} ///:~
請注意，具備常數初值的static finals，在Java 中一律以大寫字母表示，
並以底線區隔同一個識別名稱中的不同字詞。
interface 中的資料成員會自動成為public，所以無需明白標示。
現在，你可以透過package 的運用方式匯入c08.* 或c08.Months，藉以
使用目前package 之外的常數，也可以經由Months.JANUARY 之類的
360 Thinking in Java www.BruceEckel.com
算式來取用其值。當然，你所取用的僅僅只是int，並不存在C++ enum
所具備的型別安全保證。儘管如此，此一廣泛被運用的技巧仍然可以改善
你的程式，避免直接將數字寫死於程式之中- 那會成為所謂的「魔術數字
(magic numbers)」，使程式碼極難維護。
如果你要額外進行型別安全檢驗，可以設計如下的class1：
//: c08:Month2.java
// A more robust enumeration system.
package c08;
public final class Month2 {
private String name;
private Month2(String nm) { name = nm; }
public String toString() { return name; }
public final static Month2
JAN = new Month2("January"),
FEB = new Month2("February"),
MAR = new Month2("March"),
APR = new Month2("April"),
MAY = new Month2("May"),
JUN = new Month2("June"),
JUL = new Month2("July"),
AUG = new Month2("August"),
SEP = new Month2("September"),
OCT = new Month2("October"),
NOV = new Month2("November"),
DEC = new Month2("December");
public final static Month2[] month = {
JAN, JAN, FEB, MAR, APR, MAY, JUN,
JUL, AUG, SEP, OCT, NOV, DEC
};
public static void main(String[] args) {
Month2 m = Month2.JAN;
System.out.println(m);
m = Month2.month[12];
1 這個作法是受到一封來自Rich Hoffarth 的電子郵件的啟發。
Chapter 8: Interfaces & Inner Classes 361
System.out.println(m);
System.out.println(m == Month2.DEC);
System.out.println(m.equals(Month2.DEC));
}
} ///:~
此一class 名為Month2，避免和Java 標準程式庫的Month class 衝突。
它是一個具有private 建構式的final class，所以不僅無法被繼承，也無
法產生其實體(instances)。這個class 的所有實體都是它自身的final
static 實體：JAN、FEB、MAR 等等。這些物件被用於array month 之
中，讓你得以透過數字(而非名稱)來選擇月份。請注意，array month
之中多放進了一個JAN，目的是要使其索引偏移一個位置，這麼一來
December 便真的是12 月。你可以觀察到main() 之中的型別安全性：m
是個Month2 物件，所以m 僅可被賦予一個Month2 值。這和前例不
同，前例的Months.java 僅提供int 值，因此用來表示月份的int 變數
實際上可能被賦予任意整數值，這就不夠安全。
在這種作法之下，== 或equals() 都可被用來進行相等測試，一如main()
最後所示範。
將interfaces 內的資料成員初始化
定義於interfaces 內的資料成員會自動成為static 和final。它們不能是
blank finals(譯註：見p297)，但可以被非常數(non-constant)運算式
初始化，例如：
//: c08:RandVals.java
// Initializing interface fields with
// non-constant initializers.
import java.util.*;
public interface RandVals {
int rint = (int)(Math.random() * 10);
long rlong = (long)(Math.random() * 10);
float rfloat = (float)(Math.random() * 10);
double rdouble = Math.random() * 10;
} ///:~
362 Thinking in Java www.BruceEckel.com
由於這些資料成員都是static，所以當class 首次被載入(此事發生於其中
任何一個資料成員首次被取用時)，它們便都會被初始化。以下是個簡單
測試：
//: c08:TestRandVals.java
public class TestRandVals {
public static void main(String[] args) {
System.out.println(RandVals.rint);
System.out.println(RandVals.rlong);
System.out.println(RandVals.rfloat);
System.out.println(RandVals.rdouble);
}
} ///:~
當然，這些資料成員並非interface 的一部份，只不過是被儲存於interface
的static 儲存區域中罷了。
巢狀的(nesting)interfaces
2interfaces 可巢狀位於某個class 或其他interface 內。這能發展出許多有
趣的性質來：
//: c08:NestingInterfaces.java
class A {
interface B {
void f();
}
public class BImp implements B {
public void f() {}
}
private class BImp2 implements B {
public void f() {}
}
public interface C {
void f();
2 感謝Martin Danner 在研討班上提出這個問題。
Chapter 8: Interfaces & Inner Classes 363
}
class CImp implements C {
public void f() {}
}
private class CImp2 implements C {
public void f() {}
}
private interface D {
void f();
}
private class DImp implements D {
public void f() {}
}
public class DImp2 implements D {
public void f() {}
}
public D getD() { return new DImp2(); }
private D dRef;
public void receiveD(D d)
dRef = d;
dRef.f();
}
}
interface E {
interface G {
void f();
}
// Redundant "public":
public interface H {
void f();
}
void g();
// Cannot be private within an interface:
//! private interface I {}
}
public class NestingInterfaces {
public class BImp implements A.B {
public void f() {}
}
364 Thinking in Java www.BruceEckel.com
class CImp implements A.C {
public void f() {}
}
// Cannot implement a private interface except
// within that interface's defining class:
//! class DImp implements A.D {
//! public void f() {}
//! }
class EImp implements E {
public void g() {}
}
class EGImp implements E.G {
public void f() {}
}
class EImp2 implements E {
public void g() {}
class EG implements E.G {
public void f() {}
}
}
public static void main(String[] args) {
A a = new A();
// Can't access A.D:
//! A.D ad = a.getD();
// Doesn't return anything but A.D:
//! A.DImp2 di2 = a.getD();
// Cannot access a member of the interface:
//! a.getD().f();
// Only another A can do anything with getD():
A a2 = new A();
a2.receiveD(a.getD());
}
} ///:~
將某個interface 巢狀置於某個class 之中，語法相當直覺。巢狀interfaces
和非巢狀interfaces 一樣，也可以擁有public 或"friendly" 兩種可視性
(visibility)。你可以看到，不論public 或"friendly" 的巢狀介面都可被
實作為public、"friendly"、private 三種巢狀類別。
Chapter 8: Interfaces & Inner Classes 365
interfaces 也可以是private，就如本例的A.D。這種語法既適用於巢狀
interfaces 也適用於巢狀classes。巢狀的private interfaces 究竟可以帶來
什麼好處呢？你可能會猜想，private interface 只可被實作為巢狀的
private class，就像DImp 那樣。但是A.DImp2 的存在卻告訴我們，
private interface 也能被實作為一個public class。不過即便如此，
A.DImp2 也不能為外界所用。你無法對外界說它實作出一個private
interface。因此所謂將private interface 實作出來，只是一種方法，用以
強迫「定義於該interface 中的函式」不要被加上任何型別資訊。這也就是
說，不允許任何向上轉型發生。
getD() 引出一個和private interface 相關的問題：這是一個public 函
式，回傳一個reference 指向private interface。你能夠使用這個回傳值來
做些什麼事呢？在main() 裡頭你會發現，嘗試使用該回傳值(假設為
x)的動作失敗了。只有在其回傳值被指派給某個物件，而該物件擁有x 的
使用權，才會成功。這樣的物件在本例是以另一個A 透過receiveD() 取
得。
interface E 告訴我們，interfaces 可彼此相互套疊。但是套用於interfaces
身上的種種規則，尤其是「所有interface 的元素都必須為public」這一
條，在此會被嚴格執行。所以「巢狀位於另一個interface 內」的那些個
interfaces 會自動成為public，而且無法被宣告為private。
NestingInterface 示範了巢狀interfaces 的多種實作方式。請特別注意，
當你實作某個interface，你無需實作其中任何巢狀interfaces。此外，
private interfaces 無法在其所定義的classes 之外被實作。
或許加入這些特性的最初理由，只是為了語法上的一致性。但我總認為，
你知道語言的某個特性之後，往往能夠找到這個特性的用處。
Inner classes(內隱類別)
將某個class 的定義置於另一個class 定義之中是可行的，此即所謂inner
class(內隱類別)。inner class 是個極實用的特性，讓你得以將邏輯相關
的classes 組織起來，並讓你得以控制「某個class 在另一個class 中的可視
366 Thinking in Java www.BruceEckel.com
性(visibility)」。不過你一定得知道一件事：inner classes 和所謂複合
(composition)是截然不同的兩回事。
通常，當你學習inner classes 時，需求並不會立刻湧現。本節結束前，當
inner classes 的所有語法和語意都已說明完畢後，你會讀到一些範例，它
們應該能夠將inner classes 帶來的好處解釋清楚。
inner class 的產生方式，就如你所預期的一樣：將class 的定義置於某個外
圍(outer)class 之內：
//: c08:Parcel1.java
// Creating inner classes.
public class Parcel1 {
class Contents {
private int i = 11;
public int value() { return i; }
}
class Destination {
private String label;
Destination(String whereTo) {
label = whereTo;
}
String readLabel() { return label; }
}
// Using inner classes looks just like
// using any other class, within Parcel1:
public void ship(String dest) {
Contents c = new Contents();
Destination d = new Destination(dest);
System.out.println(d.readLabel());
}
public static void main(String[] args) {
Parcel1 p = new Parcel1();
p.ship("Tanzania");
}
} ///:~
在ship() 之內使用inner classes，看起來就和使用其他classes 一樣。這
裡唯一的差別是，其名稱乃巢狀位於Parcel1 之內。稍後你會發現，這其
實並非唯一差別。
Chapter 8: Interfaces & Inner Classes 367
典型的作法是，外圍class 有一個函式，可以傳回一個reference 指向
inner class，像這樣：
//: c08:Parcel2.java
// Returning a reference to an inner class.
public class Parcel2 {
class Contents {
private int i = 11;
public int value() { return i; }
}
class Destination {
private String label;
Destination(String whereTo) {
label = whereTo;
}
String readLabel() { return label; }
}
public Destination to(String s) {
return new Destination(s);
}
public Contents cont()
return new Contents();
}
public void ship(String dest) {
Contents c = cont();
Destination d = to(dest);
System.out.println(d.readLabel());
}
public static void main(String[] args) {
Parcel2 p = new Parcel2();
p.ship("Tanzania");
Parcel2 q = new Parcel2();
// Defining references to inner classes:
Parcel2.Contents c = q.cont();
Parcel2.Destination d = q.to("Borneo");
}
} ///:~
368 Thinking in Java www.BruceEckel.com
如果你想要在外圍class 的non-static 函式之外產生一個inner class 物
件，你就得以OuterClassName.InnerClassName 的型式指定該物件的型
別，一如上述main() 的行為。
Inner classes(內隱類別)與upcasting(向上轉型)
截至目前，inner classes 似乎並不多麼引人注目。畢竟，如果只是為了隱
藏，Java 具備了極佳的隱藏機制- 讓class 成為"friendly"(於是只能在
同一個package 內被看到)，不必將它製作成inner class。
但是當你開始向上轉型至base class，尤其是轉型為interface，就能突顯
inner classes 的好處(注意，從某個「實作出interface I」的inner class
物件身上產生一個reference 指向I，本質上和「向上轉型至base class」
是一樣的)，這是因為inner class(也就是I 的實現者)可以在接下來的
情境中完全不被看見，而且不為任何人所用。這麼一來我們就很方便能夠
「隱藏實作細目」。你所得到的只是「指向base class 或interface」的一
個reference 而已。
首先，共有的interfaces 會被定義於專屬的檔案中，這使它們得以被用於
所有範例之中：
//: c08:Destination.java
public interface Destination {
String readLabel();
} ///:~
//: c08:Contents.java
public interface Contents {
int value();
} ///:~
現在， Contents 和Destination 表現出客端程式員可使用的
interfaces。記住，interface 會自動將其所有成員都設為public。
當你得到一個reference，指向base class 或base interface 時，你甚至可
能無法找到其確切型別，一如下例所示：
//: c08:Parcel3.java
// Returning a reference to an inner class.
Chapter 8: Interfaces & Inner Classes 369
public class Parcel3 { // 譯註：以下Contents 見p368
private class PContents implements Contents {
private int i = 11;
public int value() { return i; }
}
protected class PDestination
implements Destination { // 譯註：Destination 見p368
private String label;
private PDestination(String whereTo) {
label = whereTo;
}
public String readLabel() { return label; }
}
public Destination dest(String s) {
return new PDestination(s);
}
public Contents cont()
return new PContents();
}
}
class Test {
public static void main(String[] args) {
Parcel3 p = new Parcel3();
Contents c = p.cont();
Destination d = p.dest("Tanzania");
// Illegal -- can't access private class:
//! Parcel3.PContents pc = p.new PContents();
}
} ///:~
請注意，由於main() 位於Test 之中，所以當你想要執行這個程式時，你
不該執行Parcel3，而是應該執行：
java Test
在這個例子中，main() 必須位於另一個獨立class 內，才能夠說明inner
class PContents 的隱密性。
370 Thinking in Java www.BruceEckel.com
Parcel3 之內有了一些新東西：由於inner class PContents 是為
private ， 所以除了Parcel3 之外， 其他classes 都無法存取之。
PDestination 是為protected，所以除了Parcel3、Parcel3 package
內的其他classes、以及Parcel3 的繼承者之外，其他classes 皆無法存取
PDestination。上述第二個原因是protected 也能帶來「package 存取
權限」，也就是說protected 也包括了"friendly"。以上意味客端程式員
不僅所知受限，對這些成員的存取能力也同樣受限。事實上你甚至無法向
下轉型至一個private inner class(或一個protected inner class，除非
你是其繼承者)，因為你根本無法取用其名稱，一如class Test 中所見。
因此，private inner class 讓class 設計者得以完全避免任何「與型別相依
的程式碼」，並得以完全隱藏實作相關的種種細節。此外，從客端程式員
的角度來看，interface 的擴充是沒有用的，因為對客端程式員而言，所有
不在public interface class 內的函式都無法取用。這使得Java 編譯器有
機會產生更高效率的碼。
一般的(non-inner)classes 無法被宣告為private 或protected，只能
是public 或"friendly"。
位於methods 和scopes 之內的
inner classes(內隱類別)
截至目前你所見到的內容完全圍繞在inner classes 一般用途上。通常你所
撰寫並閱讀的inner classes 程式碼，都是單純率直易於理解的inner
classes。然而inner classes 的設計極為完整，如果你需要，它還提供一些
隱晦的使用方式：你可以將inner classes 置於函式之內或甚至置於任意程
式範疇(scopes)之內。基於兩個理由你可能會想那麼做：
1. 一如先前所見，你想要實作某種interface，使你得以產生並回傳某
個reference。
2. 你正在解決某個複雜問題，而你希望在解決方案中設計某個class，
又不希望這個class 被外界所用。
以下例子會修改先前出現的程式碼，以便運用下面各種東西：
1. 定義於函式之內的class。
Chapter 8: Interfaces & Inner Classes 371
2. 定義於函式內某一段範疇(scope)內的class。
3. 一個匿名(anonymous)class，用以實作某個interface。
4. 一個匿名class，用來擴充一個擁有non-default 建構式的class。
5. 一個匿名class，用來執行資料成員初始化動作。
6. 一個匿名class，以實體(instance)初始化來執行建構動作。注
意，匿名的inner classes 不得擁有建構式。
雖然Wrapping 只是個一般的(帶有實作細目的)class，但它同時被用
來做為其derived classes 的共同介面。
//: c08:Wrapping.java
public class Wrapping {
private int i;
public Wrapping(int x) { i = x; }
public int value() { return i; }
} ///:~
請注意，上述Wrapping 的建構式要求傳入一個引數，這使得事情稍為有
趣些。第一個例子示範如何在函式的某個範疇內(而非另一個class 範疇
內)製作inner class：
//: c08:Parcel4.java
// Nesting a class within a method.
public class Parcel4 {
public Destination dest(String s) {
class PDestination // 譯註：以下Destination 見p368
implements Destination {
private String label;
private PDestination(String whereTo) {
label = whereTo;
}
public String readLabel() { return label; }
}
return new PDestination(s);
}
372 Thinking in Java www.BruceEckel.com
public static void main(String[] args) {
Parcel4 p = new Parcel4();
Destination d = p.dest("Tanzania");
}
} ///:~
class PDestination 是dest() 的一部份，不是Parcel4 的一部份(請注
意，對同一磁碟目錄下的每個class 內的inner class 而言，你可以使用相
同class 名稱而不至於發生衝突)，因此你無法在dest() 之外取用
PDestination。注意發生於return 述句中的向上轉型動作- dest() 只
回傳一個reference 指向base class Destination。當然啦，雖然dest()
內的class 是PDestination，但這並不意味PDestination 物件在dest()
回返之後就成了一個不合法的物件。
以下例子示範如何將inner class 巢狀置於任意程式範疇(scope)內：
//: c08:Parcel5.java
// Nesting a class within a scope.
public class Parcel5 {
private void internalTracking(boolean b) {
if(b) {
class TrackingSlip {
private String id;
TrackingSlip(String s) {
id = s;
}
String getSlip() { return id; }
}
TrackingSlip ts = new TrackingSlip("slip");
String s = ts.getSlip();
}
// Can't use it here! Out of scope:
//! TrackingSlip ts = new TrackingSlip("x");
}
public void track() { internalTracking(true); }
public static void main(String[] args) {
Parcel5 p = new Parcel5();
p.track();
}
Chapter 8: Interfaces & Inner Classes 373
} ///:~
class TrackingSlip 被巢狀置於if 述句所形成的範疇內。這並不意味該
class 會隨條件的成立才被產生，啊不，它會和其他classes 一起被編譯出
來。不過它在它所處的範疇之外就無法被使用。除此之外看起來和一般
class 沒什麼兩樣。
匿名的(anonymous)inner classes
以下例子看起來有點奇怪：
//: c08:Parcel6.java
// A method that returns an anonymous inner class.
public class Parcel6 {
public Contents cont() {
return new Contents() {
private int i = 11;
public int value() { return i; }
}; // Semicolon required in this case
}
public static void main(String[] args) {
Parcel6 p = new Parcel6();
Contents c = p.cont();
}
} ///:~
cont() 竟然將「回傳值的產生」和「用以表現回傳值」的那個class 的定
義合併在一起！而且那個class 沒有命名- 是的，它沒有名稱。整個動作
看起來像是要產生Contents 物件似的：
return new Contents()
但是然後(在你看到最後那個分號之前)你說：『等一下，我想我進入了
一個class 定義式』：
return new Contents() {
private int i = 11;
public int value() { return i; }
};
374 Thinking in Java www.BruceEckel.com
這個奇怪語法的意思是說：「產生某個匿名class 的物件，此一匿名class
係繼承自Contents。」new 傳回的reference 會被自動向上轉型為一個
Contents reference。上述匿名inner class 的語法可被展開為：
class MyContents implements Contents {
private int i = 11;
public int value() { return i; }
}
return new MyContents();
在此匿名的inner class 之中，Contents 是透過default 建構式產生的。
下面這份程式碼示範「當base class 需要一個帶有引數的建構式時」你該
如何處理：
//: c08:Parcel7.java
// An anonymous inner class that calls
// the base-class constructor.
public class Parcel7 {
public Wrapping wrap(int x) {
// Base constructor call:
return new Wrapping(x)
public int value() {
return super.value() * 47;
}
}; // Semicolon required
}
public static void main(String[] args) {
Parcel7 p = new Parcel7();
Wrapping w = p.wrap(10);
}
} ///:~
是的，只要將適當引數傳入base class 建構式中，就像將x 傳入new
Wrapping(x) 中一樣。匿名class 不能擁有建構式，所以通常你會呼叫
super()。
Chapter 8: Interfaces & Inner Classes 375
前兩個例子並不以分號做為class 主體部份的結束標記(C++則是如此)。
取而代之的是，分號用來標示「含有匿名class」之算式的結束。因此它就
像其他地方對分號的運用完全一樣。
如果你得為某個匿名inner class 的物件執行某種初始化動作，又該如何
呢？由於此類class 不具名稱，因而無法給予其建構式任何名稱- 因此它
無法擁有建構式。不過你還是可以在資料成員定義處執行初始化動作：
//: c08:Parcel8.java
// An anonymous inner class that performs
// initialization. A briefer version
// of Parcel5.java.
public class Parcel8 {
// Argument must be final to use inside
// anonymous inner class:
public Destination dest(final String dest) {
return new Destination() {
private String label = dest;
public String readLabel() { return label; }
};
}
public static void main(String[] args) {
Parcel8 p = new Parcel8();
Destination d = p.dest("Tanzania");
}
} ///:~
如果你定義了某個匿名inner class，並且希望用到定義於匿名inner class
之外的某個物件，編譯器會限制該外部物件必須為final。這也就是為什麼
dest() 的引數是final 的原因。如果你忘了這麼做，你會收到編譯期錯誤
訊息。
如果你只是簡單地對某個資料成員賦值，上述方式不會有任何問題。但如
果你必須執行某些類似建構式的動作，該怎麼辦？透過所謂實體初始化
(instance initialization)你可以實際完成一個匿名inner class 的建構：
//: c08:Parcel9.java
376 Thinking in Java www.BruceEckel.com
// Using "instance initialization" to perform
// construction on an anonymous inner class.
public class Parcel9 {
public Destination
dest(final String dest, final float price) {
return new Destination() {
private int cost;
// Instance initialization for each object:
{
cost = Math.round(price);
if(cost > 100)
System.out.println("Over budget!");
}
private String label = dest;
public String readLabel() { return label; }
};
}
public static void main(String[] args) {
Parcel9 p = new Parcel9();
Destination d = p.dest("Tanzania", 101.395F);
}
} ///:~
在實體初值設定式(initializer)中你可以看到，有一段程式碼無法做為資
料成員初值設定式的一部份(我說的是那個if 述句)。所以實體初值設定
式實際上等於無名inner class 的建構式。當然啦，其能力受到限制；你無
法重載實體初值設定式，所以你只能擁有唯一一個建構式。
與外圍(outer)class 的連結關係
截至目前，inner classes 看起來似乎只不過是一種用於名稱隱藏和程式碼
組織的體制。這兩個用途的確有用，但並不能完全讓人信服。是的，其實
它還有另一種作用。當你建立一個inner class 時，其物件便擁有了與其製
造者- 那個外圍(enclosing)物件- 之間的一種連結關係，所以它可存
取外圍物件的所有成員而無需添加任何飾詞。此外，inner classes 亦能
Chapter 8: Interfaces & Inner Classes 377
存取enclosing class 的所有元素3。以下例子說明這一點：
//: c08:Sequence.java
// Holds a sequence of Objects.
interface Selector {
boolean end();
Object current();
void next();
}
public class Sequence {
private Object[] obs;
private int next = 0;
public Sequence(int size) {
obs = new Object[size];
}
public void add(Object x) {
if(next < obs.length) {
obs[next] = x;
next++;
}
}
private class SSelector implements Selector {
int i = 0;
public boolean end() {
return i == obs.length;
}
public Object current() {
return obs[i];
}
public void next() {
if(i < obs.length) i++;
}
}
3 這一點和C++巢狀類別(nested classes)的設計極為不同。在C++中，那只是單純的名
稱隱藏機制罷了，並不存在與外圍物件之間的連結關係，也沒有暗含的存取權。
378 Thinking in Java www.BruceEckel.com
public Selector getSelector() {
return new SSelector();
}
public static void main(String[] args) {
Sequence s = new Sequence(10);
for(int i = 0; i < 10; i++)
s.add(Integer.toString(i));
Selector sl = s.getSelector();
while(!sl.end()) {
System.out.println(sl.current());
sl.next();
}
}
} ///:~
Sequence 只是一個大小固定的Object array，以class 形式加以包裝。
你可以呼叫add() 將新的Object 加至該序列之末(前提是尚有空間)。
如果想取得Sequence 中的每個物件，有個名為Selector 的interface，
可讓你檢查目前是否已到序列末端( end() ) 、取得目前Object
(current())、以及移至下一個Object(next())。由於Selector 是
個interface ， 所以任何classes 都可以以自己的方式來實作此一
interface，而許多函式都可以接受此一interface 做為引數，藉以產生一般
化的程式碼。
在這裡，SSelector 是一個提供Selector 機能的private class。在
main() 中你可以看到，首先產生一個Sequence，然後將一些String 物
件加入，接下來便經由呼叫getSelector() 產生一個Selector，再利用它
來走訪Sequence 並選擇其中的每一筆元素。
乍見之下，SSelector 只不過是個inner class，但是讓我們更深入地觀
察。注意，end()、current()、next() 等函式都用到了obs，那是個
reference，並非SSelector 的一部份，而是enclosing class 的一個
private 資料成員。由於inner class 可以存取enclosing class 的所有成
員，就像inner class 自己擁有這些成員一樣，所以帶來很大的便利，一如
上例所示。
換句話說inner class 天生具有對enclosing class 之所有成員的存取權力。
這是怎麼做到的呢？inner class 必須記錄一個reference，指向enclosing
Chapter 8: Interfaces & Inner Classes 379
class 的某個特定物件。當你取用enclosing class 的成員時，剛才說的那個
(隱藏的)reference 便被用來選擇成員。很幸運地，編譯器會自動為你處
理所有細節。但你現在終於可以了解，inner class 物件被產生時，一定得
關聯至其enclosing class 的某個物件。建構inner class 物件的同時，得有
其enclosing class 之物件(的reference)才行。如果編譯器無法取得這麼
一個reference，便會給出錯誤訊息。大多數情況下這個過程無需程式員插
手便會自動完成。
static inner classes(靜態內隱類別)
如果你不需要inner class 物件和enclosing class 物件之間的連結關係，你
可以將inner class 宣告為static。如果你想了解這麼宣告的確切時機，記
住，一般的inner class(譯註：也就是non-static inner class)會自動記
錄一個reference 指向enclosing class 的某個物件，而後者也就是此inner
class 物件的製造者。但是一旦你將inner class 宣告為static，上述說法便
不成立。static inner class 意味著：
1. 產生其物件時，並不需要同時存在一個enclosing class 物件。
2. 你無法在static inner class 物件中存取enclosing class 物件。
static 和non-static inner class 從另一個角度來看也不一樣。Non-static
inner class 內的所有資料和函式都只能夠位於class 的外層(outer level。
譯註：此語應只是一種形容，不具實際技術意義)，所以它不能夠擁有任
何static data、static fields、static inner class。然而static inner
classes 可以擁有那些東西：
//: c08:Parcel10.java
// Static inner classes.
public class Parcel10 {
private static class PContents
implements Contents { // 譯註：Contents 見p368
private int i = 11;
public int value() { return i; }
}
380 Thinking in Java www.BruceEckel.com
protected static class PDestination
implements Destination { // 譯註：Destination 見p368
private String label;
private PDestination(String whereTo) {
label = whereTo;
}
public String readLabel() { return label; }
// Static inner classes can contain
// other static elements:
public static void f() {}
static int x = 10;
static class AnotherLevel {
public static void f() {}
static int x = 10;
}
}
public static Destination dest(String s) {
return new PDestination(s);
}
public static Contents cont() {
return new PContents();
}
public static void main(String[] args) {
Contents c = cont();
Destination d = dest("Tanzania");
}
} ///:~
main() 函式內完全不需要Parcel10 物件；它只要採用一般用來選擇
static 成員的語法，呼叫「傳回reference(指向Contents)和reference
(指向Destination)」的函式即可。
一如你將於稍後所見，non-static inner class 之中對於enclosing class 物
件的連結關係，是透過一個特殊的this reference 形成。static inner class
不具此一特殊的this reference，因而和static 函式有些相似。
一般而言，你不能將任何程式碼置於interface 內，但static inner class
卻可以是interface 的一部份。這是因為class 既然被宣告為static，也
就不會破壞interface 的規則- static inner class 只不過是被置於
interface 的命名空間中罷了：
Chapter 8: Interfaces & Inner Classes 381
//: c08:IInterface.java
// Static inner classes inside interfaces.
interface IInterface {
static class Inner {
int i, j, k;
public Inner() {}
void f() {}
}
} ///:~
本書稍早我曾經建議你為每個class 設計main()，做為測試該class 之
用。這種作法的缺點之一就是，你得攜帶額外份量的編譯後程式碼。如果
這對你來說是個問題，你可以運用static inner class 來擺放你的測試碼：
//: c08:TestBed.java
// Putting test code in a static inner class.
class TestBed {
TestBed() {}
void f() { System.out.println("f()"); }
public static class Tester {
public static void main(String[] args) {
TestBed t = new TestBed();
t.f();
}
}
} ///:~
這種作法會產生一個名為TestBed$Tester 的獨立class(如果想執行該
程式，得輸入java TestBed$Tester 才行)。你可以使用這個class 來進
行測試，但是在出貨產品中不需要含括此一class。
取用(referring)outer class 的物件
在你需要產生一個reference 指向outer class 物件時，命名方式便是在
outer class 名稱之後緊接一個句點，然後再接this。舉個例子，class
Sequence.SSelector 內的任何函式都可以透過Sequence.this 來產生
一個reference 指向Sequence。產生出來的reference 會自動被設定正確
382 Thinking in Java www.BruceEckel.com
型別。是的，編譯期即可得知確切型別並加以檢查，所以不會有執行期的
額外負擔。
有時候，你會希望某個物件產生其本身內的某個inner classes 物件。要達
到這個目的，你得在new 運算式中提供一份reference，它得指向某個
outer class 物件，像這樣：
//: c08:Parcel11.java
// Creating instances of inner classes.
public class Parcel11 {
class Contents {
private int i = 11;
public int value() { return i; }
}
class Destination {
private String label;
Destination(String whereTo) {
label = whereTo;
}
String readLabel() { return label; }
}
public static void main(String[] args) {
Parcel11 p = new Parcel11();
// Must use instance of outer class
// to create an instances of the inner class:
Parcel11.Contents c = p.new Contents();
Parcel11.Destination d =
p.new Destination("Tanzania");
}
} ///:~
如果你想直接產生inner class 物件，你不能像你所(可能)想像地在new
算式中使用outer class 的名稱Parcel11，你必須使用outer class 物件來
產生inner class 物件，一如上例中的此行：
Parcel11.Contents c = p.new Contents();
因此，除非你已經擁有一個outer class 物件，否則便無法產生其inner
class 物件。這是因為inner class 物件會被暗中連接到某個outer class 物件
Chapter 8: Interfaces & Inner Classes 383
上，後者即該inner class 物件的製造者。不過，如果你製作的是static
inner class，那就不需要一個reference 指向outer class 物件。
從多層巢狀class 向外伸展觸角
4無論inner class 被巢狀置放的層次有多深，其所有outer classes 的成員都
可被它存取，一如下例所示：
//: c08:MultiNestingAccess.java
// Nested classes can access all members of all
// levels of the classes they are nested within.
class MNA {
private void f() {}
class A {
private void g() {}
public class B {
void h() {
g();
f();
}
}
}
}
public class MultiNestingAccess {
public static void main(String[] args) {
MNA mna = new MNA();
MNA.A mnaa = mna.new A();
MNA.A.B mnaab = mnaa.new B();
mnaab.h();
}
} ///:~
4 再次謝謝Martin Danner。
384 Thinking in Java www.BruceEckel.com
你看到了，MNA.A.B 內可以直接呼叫g() 和f() 這兩個函式，無需添加
任何飾詞(儘管它們實際上是private)。這個例子同時也為你示範如何
在另一個class 中產生「多層巢狀inner classes 物件」。.new 語法會自動
產生正確範疇(scope)，所以呼叫建構式時你無需為class 名稱加上任何
飾詞。
繼承inner classes
由於inner class 的建構式必須連接到一個reference 指向outer class 物件
身上，所以當你繼承inner class 時，事情便稍微複雜些。問題出在「指向
outer class 物件」的那個神秘reference 必須被初始化，但derived class 之
內不存有可連結的預設物件。這個問題的答案是，使用專用語法，明確產
生該關聯性：
//: c08:InheritInner.java
// Inheriting an inner class.
class WithInner {
class Inner {}
}
public class InheritInner
extends WithInner.Inner {
//! InheritInner() {} // Won't compile
InheritInner(WithInner wi) {
wi.super();
}
public static void main(String[] args) {
WithInner wi = new WithInner();
InheritInner ii = new InheritInner(wi);
}
} ///:~
你看到了，InheritInner 繼承的是inner class 而非outer class。但是當
編譯至建構式時，default 建構式有問題；而且你也不能夠只是傳入一個
reference 指向outer object，你還必須在建構式中使用以下語法：
enclosingClassReference.super();
Chapter 8: Interfaces & Inner Classes 385
這麼一來便能提供所需的reference，而程式也能順利編譯下去。
inner classes 可被覆寫(overridden)嗎？
當你撰寫某個inner class，然後再寫一個class 繼承enclosing class 並在自
身之內重新定義那個inner class，會發生什麼事？也就是說，我們能否覆
寫(overriding)inner class？這似乎是個極具威力的概念，但是覆寫
inner class(好似把inner class 視為outer class 的一個函式)，其實沒有
什麼用處：
//: c08:BigEgg.java
// An inner class cannot be overriden
// like a method.
class Egg {
protected class Yolk {
public Yolk() {
System.out.println("Egg.Yolk()");
}
}
private Yolk y;
public Egg() {
System.out.println("New Egg()");
y = new Yolk();
}
}
public class BigEgg extends Egg { // 譯註：繼承outer.
public class Yolk { // 譯註：這一段視為「覆寫inner」.
public Yolk() {
System.out.println("BigEgg.Yolk()");
}
}
public static void main(String[] args) {
new BigEgg();
}
} ///:~
注意，這個default 建構式由編譯器自動合成，而且它必定會呼叫base
class 的default 建構式。你可能會以為，由於main() 所產生的乃是
386 Thinking in Java www.BruceEckel.com
BigEgg 物件，所以會使用覆寫過的Yolk。事實並非如此，輸出如下：
New Egg()
Egg.Yolk()
這個範例告訴我們，當你繼承一個outer class，不會有什麼神奇作用發生
在inner class 身上。上述兩個inner classes 是完全獨立的個體，各有其專
屬的命名空間。不過你還是可以明確指出想要繼承自inner class：
//: c08:BigEgg2.java
// Proper inheritance of an inner class.
class Egg2 {
protected class Yolk {
public Yolk() {
System.out.println("Egg2.Yolk()");
}
public void f() {
System.out.println("Egg2.Yolk.f()");
}
}
private Yolk y = new Yolk();
public Egg2() {
System.out.println("New Egg2()");
}
public void insertYolk(Yolk yy) { y = yy; }
public void g() { y.f(); }
}
public class BigEgg2 extends Egg2 {
public class Yolk extends Egg2.Yolk {
public Yolk() {
System.out.println("BigEgg2.Yolk()");
}
public void f() {
System.out.println("BigEgg2.Yolk.f()");
}
}
public BigEgg2() { insertYolk(new Yolk()); }
public static void main(String[] args) {
Chapter 8: Interfaces & Inner Classes 387
Egg2 e2 = new BigEgg2();
e2.g();
}
} ///:~
現在，BigEgg2.Yolk 會明確繼承自Egg2.Yolk， 並覆寫其函式。
insertYolk() 允許BigEgg2 將它所擁有的Yolk 物件向上轉型為Egg2
中的y reference，所以當g() 呼叫y.f() 時，便會使用被覆寫過的f()。輸
出結果為：
Egg2.Yolk()
New Egg2()
Egg2.Yolk()
BigEgg2.Yolk()
BigEgg2.Yolk.f()
注意，對Egg2.Yolk() 的第二次呼叫，發生在BigEgg2.Yolk 建構式中
對其base class 建構式的呼叫動作上。你看到了，當g() 被呼叫，便會使
用f() 的覆寫版本。
Inner class 的識別符號(identifiers)
每個class 都會產生一個.class 檔，用來存放「生成此類物件時的所有必要
資訊」。這些資訊會產生一個所謂的Class 物件，這是一種meta-class
(譯註：請參考p662)。你可能會猜想inner classes 也必須產生.class
檔來儲存其Class 物件資訊。的確如此。這些檔案名稱與classes 名稱之間
有嚴謹的規則：先是outer class 名稱，其後緊接’$’ 符號，然後再緊接
inner class 名稱。舉個例子，由InheritInner.java 所產生的.class 檔就
有以下三個：
InheritInner.class
WithInner$Inner.class
WithInner.class
如果inner class 沒有名稱，編譯器就自動產生數字，做為inner class 的識
別符號。如果inner classes 被巢狀置於其他inner classes 內，其名稱就會
直接附加於’$’ 符號與outer class 識別符號(可能有多個)之後。
388 Thinking in Java www.BruceEckel.com
此種內部名稱產生方式不但單純而直覺，也十分穩當，而且能夠因應絕大
多數情況5。由於這是Java 的標準命名架構，所以產生出來的檔案自然而
然與平台無關。(注意，為了使這些檔案能夠運作，Java 編譯器會盡其所
能地改變你的inner classes)
為什麼需要inner classes？
現在，你已經看到了許多描述inner classes 運作方式的語法與語意，但是
這並無法回答inner classes 的存在原因。為什麼Sun 要大費周章地加入這
個語言功能呢？
一般來說，inner class 會繼承某個class 或實作某個interface，而且inner
class 內的程式碼會操作其outer class 物件。所以你可以說，inner class 所
提供的其實是針對outer class 的某種窗口。
有個問題直指inner class 的核心：如果我只需要「指向某個interface」
的reference，為什麼我不直接讓outer class 實作該interface 就好呢？答
案是，如果這麼做就能符合你的需求，你的確應該這麼做。那麼，「由
inner class 實作interface」和「由outer class 實作interface」兩者之
間的區別究竟在那兒？答案是後者將使你無法總是享受到interfaces 的便
利性- 有時候你得下探實作細目。所以，關於inner classes 的存在，最讓
人信服的理由是：
每個inner class 都能夠各自繼承某一實作類別(implementation)。
因此，inner class 不受限於outer class 是否已繼承自某一實作類別。
如果少了inner class 所提供的「繼承自多個具象(concrete)或抽象
(abstract)類別」的能力，設計上和編程上的某些問題會變得十分棘
手。所以，從某個角度來看inner class，你可以說它是多重繼承問題的完
整解決方案。interface 能夠解決其中一部份問題，但inner classes 才能有
5 ’$’ 符號同時也是Unix Shell 中的meta 字元，所以在列示.class 檔案時，有時候會發生
一些問題。對Sun 這麼一個以Unix 為根據的公司來說，這種問題實在有點奇怪。我的猜測
是，他們並沒有考慮這個問題，他們認為你應該只專注源碼檔案。
Chapter 8: Interfaces & Inner Classes 389
效而實際地允許「多重實作繼承( multiple implementation
inheritance)」。也就是說，inner classes 實際上允許你繼承多個noninterface
。
為了更仔細地思考這個問題，請設想你目前擁有兩個interfaces，它們必須
以某種方式被實作於某個class 內。由於interfaces 所具備的彈性，你有兩
個選擇：採用single class 或inner class：
//: c08:MultiInterfaces.java
// Two ways that a class can
// implement multiple interfaces.
interface A {}
interface B {}
class X implements A, B {} // 譯註：狀況1
class Y implements A { // 譯註：狀況2
B makeB() {
// Anonymous inner class:
return new B() {}; // 譯註：{} 造成inner class.
}
}
public class MultiInterfaces {
static void takesA(A a) {}
static void takesB(B b) {}
public static void main(String[] args) {
X x = new X();
Y y = new Y();
takesA(x);
takesA(y);
takesB(x);
takesB(y.makeB());
}
} ///:~
當然，首先我們得假設，你的程式結構在上述任何一種方式下，都有其邏
輯意義。通常你會從問題的本質得到決策上的某種導引，並以此選擇究竟
390 Thinking in Java www.BruceEckel.com
該使用single class 或inner class。如果沒有任何其他限制，從實作觀點來
看，上例任何一種方式都沒有多大分別。兩種方式都行得通。
然而如果你所擁有的不是interfaces，而是抽象或具象的classes，你就必
須使用inner classes 來解決「多重繼承」的問題：
//: c08:MultiImplementation.java
// With concrete or abstract classes, inner
// classes are the only way to produce the effect
// of "multiple implementation inheritance."
class C {}
abstract class D {}
class Z extends C {
// 譯註：以下的{} 造成inner class.
D makeD() { return new D() {}; }
}
public class MultiImplementation {
static void takesC(C c) {}
static void takesD(D d) {}
public static void main(String[] args) {
Z z = new Z();
takesC(z);
takesD(z.makeD());
}
} ///:~
如果你不需要解決「多重實作繼承」的問題，那麼你可以使用其他各種方
法來撰寫程式，不需動用到inner classes。但是，透過inner classes，你
可以擁有下列幾個額外性質：
1. inner class 可以擁有多份實體(instances)，每個實體都擁有專屬
的狀態資訊(state information)，而這些資訊和outer class 物件
的資訊是相互獨立的。
Chapter 8: Interfaces & Inner Classes 391
2. 在單一outer class 內你可以擁有多個inner classes，每個都實作相
同的interface，或以不同方式繼承同一個class。對此，稍後我會
有一個範例說明。
3. 產生inner class 物件的時間點，不見得必須和產生outer class 物件
同時。
4. outer class 和inner class 之間不存在is-a 的關係，inner class 是獨
立個體。
舉個例子，如果Sequence.java 不使用inner class，那麼你就得宣稱
「Sequence 是個Selector」，而且對特定某個Sequence 而言你只能
擁有單一的Selector 。另外， 如果你希望擁有第二個函式：
getRSelector()，令它產生一個「回頭走」的Selector，那麼你必須採
用inner class，才能有如此彈性。
Closures(終結)和Callbacks(回呼)
所謂closure 是一種可被呼叫的物件，它會記錄一些資訊，這些資訊來自它
的產生地所在的程式範疇(scope)。從這個定義來看，你可以發現，
inner class 是一種OO closure，因為它不但包含來自outer class 物件的種
種資訊，而且還自動記錄一個「指向outer class 物件」的reference，並擁
有操縱所有outer class 成員的權限- 即使面對private 成員也不例外。
如果說有必要將指標機制含括到Java 裡頭，最讓人信服的一個理由便是為
了提供所謂callbacks(回呼)。在callback 機制底下，某個物件被賦予一
些資訊，這些資訊允許該物件在稍後某個時間點上呼叫原先的物件。一如
你將在13 章和16 章所見，這的確是一種極為有用的觀念。不過如果
callback 是以指標方式來完成，你就得指望程式員自己妥善處理，並且不
至於誤用指標。截至目前我們所看到的是，Java 在設計上傾向更小心謹
慎，所以指標並沒有被含括到這個程式語言內。
讓inner class 提供closure 功能，是完美的解決方案。比起指標來說，不
僅更具彈性，而且安全許多。以下是一個簡單範例：
//: c08:Callbacks.java
// Using inner classes for callbacks
392 Thinking in Java www.BruceEckel.com
interface Incrementable {
void increment();
}
// Very simple to just implement the interface:
class Callee1 implements Incrementable {
private int i = 0;
public void increment() {
i++;
System.out.println(i);
}
}
class MyIncrement {
public void increment() {
System.out.println("Other operation");
}
public static void f(MyIncrement mi) {
mi.increment();
}
}
// If your class must implement increment() in
// some other way, you must use an inner class:
class Callee2 extends MyIncrement {
private int i = 0;
private void incr() {
i++;
System.out.println(i);
}
private class Closure implements Incrementable {
public void increment() { incr(); }
}
Incrementable getCallbackReference() {
return new Closure();
}
}
class Caller {
private Incrementable callbackReference;
Chapter 8: Interfaces & Inner Classes 393
Caller(Incrementable cbh) {
callbackReference = cbh;
}
void go() {
callbackReference.increment();
}
}
public class Callbacks {
public static void main(String[] args) {
Callee1 c1 = new Callee1();
Callee2 c2 = new Callee2();
MyIncrement.f(c2);
Caller caller1 = new Caller(c1);
Caller caller2 =
new Caller(c2.getCallbackReference());
caller1.go();
caller1.go();
caller2.go();
caller2.go();
}
} ///:~
這個例子進一步突顯了「在outer class 中實作interface」和「在inner
class 中實作interface」之間的差異。就程式碼而言，Callee1 無疑是較簡
單的方法。Callee2 繼承自MyIncrement，後者擁有另一個不同的
increment() ， 這個函式會執行一些動作， 而這些動作和
Incrementable interface 預期應該要做的事毫無關聯。當
MyIncrement 被Callee2 繼承， 你無法覆寫increment() 以為
Incrementable 所用。所以你得利用inner class 另行提供一份獨立的實
作碼。請注意，當你撰寫inner class 時，你並不會將任何東西加入outer
class 的介面，或修改該介面。
請注意，Callee2 內除了getCallbackReference() 之外，都是private
成員。如果想要建立與外界的連繫關係，interface Incrementable 是關
鍵所在。在這個例子中，你可以看到interfaces 如何允許介面與實作完全
分離。
394 Thinking in Java www.BruceEckel.com
inner class Closure 很單純地藉由「實作Incrementable」來提供與
Callee2 之間的關聯。這個關聯的確很安全。當然， 不論誰取得了
Incrementable reference，它都只能呼叫increment()，而不具備其他
能力(這和指標不同；指標允許你進行任何動作)。
Caller 於其建構式中接受Incrementable reference 做為引數(儘管捕
獲callback reference 的動作隨時可能會發生)，而且在某段時間之後，它
會使用這個reference 來「回頭呼叫」Callee class。
callback 的價值在於其彈性- 你可以在執行時期動態決定究竟要呼叫哪個
函式。到了13 章，這個好處會更為明顯。那一章處處使用callbacks 來實
現圖形使用介面(graphics user interface，GUI)的各種功能。
Inner classes 和control frameworks
從以下即將介紹的所謂control framework(控制框架)中，你可以獲得
更為具體的inner classes 運用實例。
所謂application framework(應用程式框架)，是一組「被設計用來解決
特定某種問題」的classes。如果想套用某個application framework，你得
繼承一個或多個classes，並覆寫其中某些函式。透過被覆寫的函式內的新
版程式碼，便可將application framework 所提供的通用解法特殊化，針對
性地解決你的特定問題。所謂control framework，其實就是一種特殊型式
的application framework，用來解決「事件(events)回應」的需要。一
個系統如果主要工作在於回應諸般事件，我們稱為「事件驅動系統
(event-driven system)」。應用程式撰寫過程中最重要的一個題目便是
圖形使用介面(Graphic User Interface，GUI)，那幾乎完全是「事件驅
動」方式。一如你將於第13 章看到，Java Swing 程式庫便是一個control
framework，優雅解決了GUI 問題，並大量採用inner classes。
為了觀察inner class 究竟如何讓我們輕鬆建立並運用control framework，
讓我們假設，有個control framework，其主要工作是在事件(events)狀
態變成「就緒(ready)」時執行該事件。雖然「就緒」一詞有各種意義，
但本例以clock time 為根據。接下來要說明的是，control framework 並未
內含它所控制之事物的任何特定資訊。是的，會有一個介面用來描述每個
Chapter 8: Interfaces & Inner Classes 395
控制事件( control event ) ， 它將是個abstract class 而非一個
interface，因為其預設行逕是「根據時間來執行控制動作」，所以可具有
某種程度的實作：
//: c08:controller:Event.java
// The common methods for any control event.
package c08.controller;
abstract public class Event {
private long evtTime;
public Event(long eventTime) {
evtTime = eventTime;
}
public boolean ready() {
return System.currentTimeMillis() >= evtTime;
}
abstract public void action();
abstract public String description();
} ///:~
上例建構式只是單純取得「你希望Event 被執行起來」的時刻，ready()
會告訴你應該執行的時刻。當然，你也可以在derived class 中覆寫
ready()，不再以時刻為依據來決定事件是否該執行。
當Event 就緒(ready())時便會呼叫action()。透過description()
則可取得Event 相關文字訊息。
以下檔案內含一個實際的control framework，可以管理並觸發事件。第一
個class 實際上只是個輔助用的class(一個helper)，其職責是儲存
Event 物件。你可以使用任何適當的容器加以替換。你會發現，第9 章的
各種容器都是適當的候選人，你不需要自己寫一個。
//: c08:controller:Controller.java
// Along with Event, the generic
// framework for all control systems:
package c08.controller;
// This is just a way to hold Event objects.
class EventSet {
private Event[] events = new Event[100];
396 Thinking in Java www.BruceEckel.com
private int index = 0;
private int next = 0;
public void add(Event e) {
if(index >= events.length)
return; // (In real life, throw exception)
events[index++] = e;
}
public Event getNext() {
boolean looped = false;
int start = next;
do {
next = (next + 1) % events.length;
// See if it has looped to the beginning:
if(start == next) looped = true;
// If it loops past start, the list
// is empty:
if((next == (start + 1) % events.length)
&& looped)
return null;
} while(events[next] == null);
return events[next];
}
public void removeCurrent() {
events[next] = null;
}
}
public class Controller {
private EventSet es = new EventSet();
public void addEvent(Event c) { es.add(c); }
public void run() {
Event e;
while((e = es.getNext()) != null) {
if(e.ready()) {
e.action();
System.out.println(e.description());
es.removeCurrent();
}
}
}
} ///:~
Chapter 8: Interfaces & Inner Classes 397
EventSet 能儲存100 個Events。如果此處使用第9 章所說的容器，你就
不需要再擔心其最大容量，因為那些容器能夠自己調整大小。index 被用
來記錄下一個可用空間。當你尋找list 中的下一個Event 時，得使用
next 來檢查是否已經繞行一周。這在呼叫getNext() 時尤其重要，因為
當我們執行完Event 物件之後便得運用removeCurrent() 將這些
Event 物件移除，所以getNext() 會在list 的走訪過程中遇上一些「空
洞」。
請注意，removeCurrent() 並不會設定某種旗標以表示某個物件不再被
使用。相反地，它會將reference 設為null。這麼做很重要，因為如果垃
圾回收器看到某個仍在使用中的reference，它就不會清理該物件。如果你
認為你的reference 可能散於四處，那麼將它們設為null 是個不錯的方
式，讓垃圾回收器有權將它們清理掉。
Controller 是執行實際工作的地方。它使用EventSet 來儲存Event 物
件，並提供addEvent() 讓你將新事件(events)加入list。最重要的是
run()，它會走訪EventSet，尋找已經就緒而可被執行的Event 物件，
然後呼叫其action()，並利用description() 列印說明訊息，再將該
Event 自list 中移除。
請注意，上述這份設計，到目前為止，對於Event 實際上會做什麼事，你
其實是一無所知的。這也正是這份設計的關鍵所在；你看它是如何地隔離
了「可能更動的事物」和「不變的事物」。或者，以我的詞彙來說是，變
化發生於「各種Event 物件之間彼此互異的行為模式」上，而你解釋這些
不同行為模式的方式就是：撰寫不同的Event subclasses。
這正是inner classes 派上用場的地方。它們允許兩件事情：
1. 在單一class 內產生control framework 的完整實作內容，並因而將
專屬於該實作方式的所有資訊都封裝起來。inner classes 則用以表
現「解決問題所必要的」多個不同種類的action()。此外，稍後例
子還運用private inner class，使整個實作內容被完全隱藏起來，
因而即使有所改變也不會帶來傷害。
398 Thinking in Java www.BruceEckel.com
2. inner classes 能夠使實作手法不至於太拙劣，因為你可以輕易存取
outer class 的所有成員。一旦缺乏這種能力，程式碼可能會一團
糟，導致你必須尋找其他替代方案。
請試著設想某個特殊control framework 的實作內容- 它被設計用來控制
溫室的機能6。每個動作彼此之間完全不同：燈光控制、水、調溫器開關、
鳴鈴、系統重啟。但是control framework 被設計用來將這些不同的程式碼
輕易隔離開來。inner classes 讓你得以在單一class 內為同一個base class
(Event)提供多份衍生版本。面對每一種類型的行為，你都繼承一個新
的Event inner class，並在其action() 內撰寫控制碼。
做為一個典型的的application framework，GreenhouseControls 繼承
自Controller：
//: c08:GreenhouseControls.java
// This produces a specific application of the
// control system, all in a single class. Inner
// classes allow you to encapsulate different
// functionality for each type of event.
import c08.controller.*;
public class GreenhouseControls
extends Controller {
private boolean light = false;
private boolean water = false;
private String thermostat = "Day";
private class LightOn extends Event {
public LightOn(long eventTime) {
super(eventTime);
}
public void action() {
// Put hardware control code here to
// physically turn on the light.
light = true;
6基於某種理由，這一直都是我很樂意解決的一個問題。它出自於我先前的一本書
《C++ Inside & Out》，不過Java 提供了更優雅的解決方案。
Chapter 8: Interfaces & Inner Classes 399
}
public String description() {
return "Light is on";
}
}
private class LightOff extends Event {
public LightOff(long eventTime) {
super(eventTime);
}
public void action() {
// Put hardware control code here to
// physically turn off the light.
light = false;
}
public String description() {
return "Light is off";
}
}
private class WaterOn extends Event {
public WaterOn(long eventTime) {
super(eventTime);
}
public void action() {
// Put hardware control code here
water = true;
}
public String description() {
return "Greenhouse water is on";
}
}
private class WaterOff extends Event {
public WaterOff(long eventTime) {
super(eventTime);
}
public void action() {
// Put hardware control code here
water = false;
}
public String description() {
return "Greenhouse water is off";
}
400 Thinking in Java www.BruceEckel.com
}
private class ThermostatNight extends Event {
public ThermostatNight(long eventTime) {
super(eventTime);
}
public void action() {
// Put hardware control code here
thermostat = "Night";
}
public String description() {
return "Thermostat on night setting";
}
}
private class ThermostatDay extends Event {
public ThermostatDay(long eventTime) {
super(eventTime);
}
public void action() {
// Put hardware control code here
thermostat = "Day";
}
public String description() {
return "Thermostat on day setting";
}
}
// An example of an action() that inserts a
// new one of itself into the event list:
private int rings;
private class Bell extends Event {
public Bell(long eventTime) {
super(eventTime);
}
public void action() {
// Ring every 2 seconds, 'rings' times:
System.out.println("Bing!");
if(--rings > 0)
addEvent(new Bell(
System.currentTimeMillis() + 2000));
}
public String description() {
return "Ring bell";
Chapter 8: Interfaces & Inner Classes 401
}
}
private class Restart extends Event {
public Restart(long eventTime) {
super(eventTime);
}
public void action() {
long tm = System.currentTimeMillis();
// Instead of hard-wiring, you could parse
// configuration information from a text
// file here:
rings = 5;
addEvent(new ThermostatNight(tm));
addEvent(new LightOn(tm + 1000));
addEvent(new LightOff(tm + 2000));
addEvent(new WaterOn(tm + 3000));
addEvent(new WaterOff(tm + 8000));
addEvent(new Bell(tm + 9000));
addEvent(new ThermostatDay(tm + 10000));
// Can even add a Restart object!
addEvent(new Restart(tm + 20000));
}
public String description() {
return "Restarting system";
}
}
public static void main(String[] args) {
GreenhouseControls gc =
new GreenhouseControls();
long tm = System.currentTimeMillis();
gc.addEvent(gc.new Restart(tm));
gc.run();
}
} ///:~
請注意，light、water、thermostat 和rings 通通屬於outer class
GreenhouseControls；inner class 可以存取這些資料成員而無需添加任
何飾詞，也無需任何特別的存取權限。此外大多數action() 都和某種硬體
控制有關，而這些硬體控制極有可能得呼叫non-Java 程式碼。
402 Thinking in Java www.BruceEckel.com
大多數Event classes 看起來十分類似，但Bell 和Restart 較為特別。
Bell 會發出響聲，而且如果未能持續鳴響足夠的時間，它便會將新的Bell
物件加至事件串列(event list)中，所以稍後便會再度鳴響。請注意inner
classes 看起來多麼像多重繼承：Bell 具有Event 的所有函式，而它似乎
也擁有outer class GreenhouseControls 的所有函式。
Restart 負責將系統初始化，所以它會將所有合適的事件通通加入。當
然，欲達成這個目的，有個更具彈性的方法，那便是避免將事件寫死在程
式碼中，而是改由檔案讀出(第11 章有個練習，就是希望你修改這個範例
以達上述目標)。由於Restart() 只是另一個Event 物件，所以你也可以
在Restart.action() 中將Restart 物件加入，藉以使得系統能夠定期重
新啟動自己。你只需在main() 中產生GreenhouseControls 物件，然
後加入Restart 物件使其開始運作即可。
這個例子應該可以讓你深刻體會inner class 的價值，特別是將它應用於
control framework 時。第13 章還會讓你知道，inner classes 被用來描述
圖形使用介面(GUI)的行為模式時，有多麼優雅。一旦你讀完該章，應
該就會完全信服inner class 的價值了。
摘要
相較於許多OOP 語言所具備的其他觀念，interfaces 和inner classes 更為
複雜。C++之中並沒有兩者的類似機制。將兩者合併起來可以解決C++ 透
過多重繼承(multiple inheritance，MI)所嘗試解決的問題。C++ 多重繼
承用起來十分困難，對照起來，Java 的interfaces 和inner classes 比較容
易些。
雖然這兩個性質相當直觀而簡單，但它們的運用屬於設計上的議題，這一
點和多型(polymorphism)極為相像。使用一段時間之後，你就愈來愈能
判斷，什麼場合應該使用interface、什麼場合應該使用inner classes、什
麼場合應該二者併用。此刻，你應該至少能夠輕鬆掌握其語法和語意。一
旦你看到了這兩個性質被實際用上，最終便能融會貫通。
Chapter 8: Interfaces & Inner Classes 403
練習
某些經過挑選的題目，其解答置於《The Thinking in Java Annotated Solution Guide》電子文件中。
僅需小額費用便可自www.BruceEckel.com.網站取得。
1. 請證明interface 內的資料成員會被自動設為static 和final。
2. 撰寫一個interface ， 內含三個函式， 然後在另一個不同的
package 中實作此一interface。
3. 證明interface 內的所有函式都會被自動設為public。
4. 在c07:Sandwich.java 內撰寫名為FastFood 的interface(並
賦予它適宜的函式) ， 然後修改Sandwich ， 使它實作出
FastFood。
5. 撰寫三個interfaces，每一個都擁有兩個函式。撰寫一個新的
interface，繼承上述三者，並新增一個函式。撰寫一個class 實作
出那個新的interface，並繼承另一個concrete class(具象類
別)。接下來寫出四個函式，各自接受上述四個interfaces 之一
做為引數。在main() 中，為你的那個class 產生一個物件，並將
它傳入上述四個函式。
6. 修改練習5：撰寫一個abstract class(抽象類別)，並繼承此一
class 以獲得derived class。
7. 修改Music5.java：加入一個Playable interface。將play() 的
宣告自Instrument 移除。將Playable 放進implements list
中，藉以將Playable 加至derived class 內。修改tune() 使它接
受Playable 做為引數(取代原先的Instrument)。
8. 修改第7 章的練習6，使Rodent 成為一個interface。
9. 在Adventure.java 內加入名為CanClimb 的interface。讓這
個interface 依循其他interfaces 的形式。
10. 撰寫程式，在其中匯入(imports)Month2.java，並加運用。
11. 依循Month2.java 所給的範例，撰寫每週各日的列舉(enum)
集合。
404 Thinking in Java www.BruceEckel.com
12. 撰寫一個interface 並令它擁有一個以上的函式。在另一個
package 內撰寫另一個class，並在其中加入一個protected inner
class，實作出上述interface。在第三個package 內，繼承你自己
撰寫的那個class，並在某個函式中回傳上述那個protected inner
class 的物件。請在回傳時將此物件向上轉型至其base interface。
13. 撰寫一個interface 並令它具備一個以上的函式，並在某個函式中
定義inner class 以實作出該interface。inner class 必須傳回一個
reference，指向那個interface。
14. 重覆練習13，改在函式內的某個程式範疇(scope)中定義inner
class。
15. 重覆練習13，改用匿名的inner class。
16. 撰寫一個「實作出public interface」的private inner class。為
它撰寫函式，使後者傳回一個reference，指向該private inner
class 的一個實體(instance)，並將它向上轉型至該interface。
試著向下轉型至inner class，藉此證明inner class 被完全隱藏起
來。
17. 撰寫一個class，使之擁有non-default 建構式，並且不具任何
default 建構式。撰寫第二個class，使其函式回傳一個reference
指向第一個class。撰寫一個匿名的inner class 繼承自第一個
class，並為它產生一個物件做為函式回傳值。
18. 撰寫一個class 具備private 資料成員和private 函式。撰寫一個
inner class，使其函式修改outer class 資料成員，並呼叫outer
class 函式。請在第二個outer class 函式中產生inner class 物件，
並呼叫其函式。試說明outer class 物件身上發生的效應。
19. 重覆練習18，改而使用匿名的inner class。
20. 撰寫含有static inner class 的class。在main() 中產生其實體。
21. 撰寫含有static inner class 的一個interface。實作它，並產生該
inner class 的實體(instance)。
Chapter 8: Interfaces & Inner Classes 405
22. 撰寫一個class，內含一個inner class。後者本身尚且含有另一個
inner class。重覆上述要求，但改用static inner class。請注
意，.class 檔的檔名由編譯器產生。
23. 撰寫一個class，內含一個inner class。在另一個class 中產生此
inner class 的實體(instance)。
24. 撰寫一個class，內含一個inner class，後者擁有non-default 建構
式。撰寫第二個具備inner class 的class，令其inner class 繼承第
一個inner class。
25. 修正WindError.java 中的問題。
26. 修改Sequence.java ， 加入getRSelector() ， 後者回傳
Selector interface 的另一份實作品：能夠從末端移至前端，以反
向方式走訪此一序列。
27. 撰寫interface U 並使之具備三個函式。撰寫class A 並使之具備
一個函式，此函式透過匿名的inner class，產生一個reference 指
向U。撰寫class B，令它內含一個U array。B 擁有一個函式，接
受一個reference 指向「U array 中的某個U」，並將之儲存起來。
B 的第二個函式則是將array 中的某個reference(由函式引數指
定)設為null。第三個函式走訪array，並呼叫U 中的函式。請在
main() 中產生一組A 物件和一個B 物件。將A 物件所形成的U
references 填入B 中。使用B 回呼(call back)所有A 物件。並
嘗試移去B 中的某些references。
28. 在GreehhouseControls.java 內加入一個「風扇開啟、關閉」
的Event inner class。
29. 證明「inner class 具備對其outer class 之private 元素的存取權
限」。判斷反向是否成立。
406 Thinking in Java www.BruceEckel.com
407
9: 持有你的物件
這是個十分簡單的計劃：一群固定數量且壽命已知的物件
(objects)。
一般而言，你的程式總是會根據某些條件來產生新的物件，而這些條件只
有在程式執行時才有辦法知道。不到執行期，無法得知究竟需要多少數量
的物件，也無法知道這些物件的確切型別。為了解決這個常見的編程問
題，你必須有能力在任意時刻、任何地點產生任意個數的物件。因此你無
法只仰賴具名的reference 來持有物件，像這樣：
MyObject myReference;
因為你永遠不知道，實際上需要多少個這樣的物件。
為了解決這個十分基本的問題，Java 提供了物件(或者應該說是物件的
reference)的數種持有方式。其中屬於語言內建者，是先前介紹過的
array。此外Java 公用程式庫(utilities)也提供了一組相當完整的容器類
別(container classes)，又稱為群集類別(collection classes)，但因
Java 2 程式庫已經使用Collection 一詞代表程式庫中的某個子集，所以
我習慣使用的詞彙是「容器」。針對物件的持有和操作，容器提供了極為
精巧的作法。
Arrays(陣列)
第4 章最末一節已經涵蓋了array 的必要簡介。該節說明array 的定義和初
始化方式。至於物件的持有，則是本章焦點所在。array 不過是持有物件的
方式之一罷了，另有其他多種物件持有方式。那麼，array 的特色在哪裡？
408 Thinking in Java www.BruceEckel.com
關於array 和其他容器之間的區別，存在兩個議題：效率和型別。array 是
Java 用來「儲存及隨機存取一連串物件(其實是物件的references)」的
各種作法中，最有效率的一種。array 是個極簡單的線性序列，其中元素能
夠被快速存取。不過效率帶來的犧牲是：當你產生array 時，其容量固定
且無法動態改變。你可能會想要產生某個固定容量的array，在空間不敷使
用時再產生另一個新array，並將舊array 中的references 全部搬到新
array 中。此即ArrayList class 的運作方式，本章稍後會介紹它。不過由
於這種容量上的彈性必須付出額外代價，ArrayList 的效率明顯比array
差。
C++ 的vector 容器確切知道它所持有的物件隸屬什麼型別(譯註：目前
的JDK1.4 也辦得到)，但它和Java array 相較有個缺點：C++ vector 的
operator[ ] 並不進行邊界檢查，所以你的存取動作可以超越其尾端1。然
而Java 之中無論是array 或其他容器都會進行邊界檢查，一旦越界就會出
現RuntimeException。一如你將於第10 章看到，這類異常表示錯誤由
程式員造成，因此你不需要自行做邊界檢查。讓我說點題外話，C++
vector 之所以不在每次存取時進行邊界檢查，是基於效率考量；是的，
Java array 及其他容器都會因為邊界檢查而帶來額外的效率負擔。
本章還會討論其他泛型容器，包括List、Set、Map。它們不會以任何特
定型別來看待它們所持有的物件。或者說，它們將持有物件一律視為
Object 型別- 這是所有Java classes 的根類別。從某個觀點來看，這種
運作方式很好：只要產生單一容器，便可將任意Java 物件置於其中(基本
型別(primitive types)除外，但你可以將它們視為常數，透過Java 所提
供的外覆類別(wrapper)將它們置於容器內，或透過你自己撰寫的class
加以包裝，使其值可變動)。這正是array 比泛型容器優越的第二點：當
你產生array 時，它持有的是特定型別的物件。這意味編譯期的型別檢查
會防止你將不正確的型別置入array，或擷取出不正確的型別。當然，Java
最終還是能夠(在編譯期或執行期)預防你將不正確的訊息發送給物件。
1 不過，你可以查詢vector 的容量，而且at() 會進行邊界檢查。
Chapter 9: Holding Your Objects 409
所以並沒有哪一種方法比較不安全。只不過如果編譯器能夠為你指出問題
所在，總是比較好，程式的執行速度也會快些。而且使用者比較沒有機會
對異常(exceptions)發出驚訝聲。
基於效率和型別檢驗兩個理由，如果可以的話你應該儘可能使用array。不
過當你試著解決更一般化的問題時，array 的功能就可能過於受限。本章討
論完array 之後，剩餘部份將致力於介紹Java 的容器類別。
Arrays 是第一級物件(first-class objects)
不論你所使用的array 型別為何，array 名稱本身實際上是個reference，指
向heap 之內的某個實際物件。這個物件持有「指向其他物件」的一些
references。這個物件可經由「array 初始化語法」被自動產生，也可以以
new 運算式手動產生。array 物件之內有個名為length 的唯讀成員，它能
夠告訴你array 物件內的元素個數。除此之外，你唯有透過’[ ]’ 語法才能
取用array 物件。
譯註：請注意，本節所保留的英文術語中，array object 是指表現「array
本身」的那個物件，objects array 是指「由物件形成的array 」。
primitives array 是指由隸屬基本型別之元素所構成的array。
下面這個例子示範各種不同形式的array 初始化動作， 以及array
references 被指派至另一個不同的array objects 的方式。這個例子同時也
說明了，objects array 和primitives array 在運用上幾乎一模一樣。唯一
差別在於，前者持有的是references，後者直接持有基本型別之值。
//: c09:ArraySize.java
// Initialization & re-assignment of arrays.
class Weeble {} // A small mythical creature
public class ArraySize {
public static void main(String[] args) {
// Arrays of objects:
Weeble[] a; // Null reference
Weeble[] b = new Weeble[5]; // Null references
410 Thinking in Java www.BruceEckel.com
Weeble[] c = new Weeble[4];
for(int i = 0; i < c.length; i++)
c[i] = new Weeble();
// Aggregate initialization:
Weeble[] d = {
new Weeble(), new Weeble(), new Weeble()
};
// Dynamic aggregate initialization:
a = new Weeble[] {
new Weeble(), new Weeble()
};
System.out.println("a.length=" + a.length);
System.out.println("b.length = " + b.length);
// The references inside the array are
// automatically initialized to null:
for(int i = 0; i < b.length; i++)
System.out.println("b[" + i + "]=" + b[i]);
System.out.println("c.length = " + c.length);
System.out.println("d.length = " + d.length);
a = d;
System.out.println("a.length = " + a.length);
// Arrays of primitives:
int[] e; // Null reference
int[] f = new int[5];
int[] g = new int[4];
for(int i = 0; i < g.length; i++)
g[i] = i*i;
int[] h = { 11, 47, 93 };
// Compile error: variable e not initialized:
//!System.out.println("e.length=" + e.length);
System.out.println("f.length = " + f.length);
// The primitives inside the array are
// automatically initialized to zero:
for(int i = 0; i < f.length; i++)
System.out.println("f[" + i + "]=" + f[i]);
System.out.println("g.length = " + g.length);
System.out.println("h.length = " + h.length);
e = h;
System.out.println("e.length = " + e.length);
e = new int[] { 1, 2 };
Chapter 9: Holding Your Objects 411
System.out.println("e.length = " + e.length);
}
} ///:~
下面是程式的輸出：
b.length = 5
b[0]=null
b[1]=null
b[2]=null
b[3]=null
b[4]=null
c.length = 4
d.length = 3
a.length = 3
a.length = 2
f.length = 5
f[0]=0
f[1]=0
f[2]=0
f[3]=0
f[4]=0
g.length = 4
h.length = 3
e.length = 3
e.length = 2
array a 會被初始化為一個null reference。除非你給它適當初值，否則編
譯器不會允許你對它進行任何動作。array b 被初始化，指向一個以
Weeble references 構成的array，但並沒有任何實際的Weeble 物件被
置於其中。不過你還是可以查詢array 的容量，因為b 已經指向一個合法
的array object。這也指出了一個小小缺點：你無法判斷array 之中實際存
有多少元素，因為length 只能告訴你array 的容量，而非實際元素個數。
不過在array object 被產生的同時，其中所有references 都會被初始化為
null，所以只要檢查某個位置是否為null，便可判斷該位置是否持有物
件。類似情況，primitives array 會將數值元素自動初始化為0，將char
元素自動初始化為(char) 0，並將boolean 元素自動初始化為false。
412 Thinking in Java www.BruceEckel.com
array c 示範如何在產生array object 之後緊接著將Weeble 物件塞入所有
位置。array d 示範「聚集初始化(aggregate initialization)」語法，此語
法能夠產生array object(自動地在heap 上進行new，就和array c 一
樣)，並給定初始的Weeble 物件，所有動作以一行述句完成。
下一個array 初始化動作，可被視為一種「動態的聚集初始化(dynamic
aggregate initialization)」。前述d 所使用的聚集初始化方式，必須在d
的定義點進行。但透過第二種語法，便可在任意地點產生並初始化array
object。舉個例子，假設hide() 接收Weeble objects array，你可以這麼
呼叫之：
hide(d);
也可以動態產生那個將被傳入做為引數的array：
hide(new Weeble[] { new Weeble(), new Weeble() });
某些情況下，這個新語法可以為程式碼的撰寫提供更便捷的途徑。
底下這行算式：
a = d;
示範如何將「已經指向某個array object」的reference 指派至另一個
array object，動作和其他型別的object reference 沒有任何不同。現在，a
和d 指向heap 上的同一個array object。
ArraySize.java 的第二部份告訴我們，primitive array 的運作方式和
object array 類似，只不過前者直接持有基本型別的元素值罷了。
容納基本型別元素的容器(Containers of primitives)
容器類別(container classes)僅能持有references(指向物件)。但面對
array，我們卻可以產生直接持有基本型別數值的array(譯註：所謂
primitives array)，也可以產生持有references(全都指向物件)的
array(譯註：所謂objects array)。我們可以使用外覆類別(wrapper，
例如Integer, Double)將基本型別值置於容器中。但是這些外覆類別使
用起來可能不很容易上手。此外，primitives array 的效率比起「容納基本
Chapter 9: Holding Your Objects 413
型別之外覆類別(的reference)」的容器好太多了(你可稱那種容器為
wrapped primitives containers)。
當然，如果你的操作對象是基本型別，而且需要在空間不足時自動擴增容
量，array 便不適合，此時就得使用外覆類別的容器了。你可能會認為應該
針對各種基本型別都提供一份特殊版的ArrayList，但Java 並未如此。有
朝一日，某種模版機制(templatizing mechanism)也許能幫助Java 更妥
善地處理此一問題2。
回傳一個array
假設你正在撰寫某個函式，你希望它不只是回傳單一數值，而是回傳一大
串值。C/C++之類的程式語言會讓這個問題變得十分困難，因為你無法單
單只回傳array，你得回傳一個指向array 的指標。這種作法會帶來問題，
因為array 壽命的控制變得極其麻煩，很容易導致記憶體漏洞。
Java 採取類似手法，但你只要回傳array 就行了。當然，實際回傳的是個
reference，指向一個array，但此刻你不需要負起照料array 的責任- 只
要你還需要它，它就會持續存在。當你不再需要它，垃圾回收器會處理。
以下便是一例，回傳一個String array：
//: c09:IceCream.java
// Returning arrays from methods.
public class IceCream {
static String[] flav = {
"Chocolate", "Strawberry",
"Vanilla Fudge Swirl", "Mint Chip",
"Mocha Almond Fudge", "Rum Raisin",
"Praline Cream", "Mud Pie"
};
static String[] flavorSet(int n) {
2 這是C++明顯優於Java 之處。C++ 經由關鍵字template 支援所謂「參數化型別」
(parameterized types) (譯註：此一想法已於JDK1.4 實現，採用的技術不同於C++)
414 Thinking in Java www.BruceEckel.com
// Force it to be positive & within bounds:
n = Math.abs(n) % (flav.length + 1);
String[] results = new String[n];
boolean[] picked =
new boolean[flav.length];
for (int i = 0; i < n; i++) {
int t;
do
t = (int)(Math.random() * flav.length);
while (picked[t]);
results[i] = flav[t];
picked[t] = true;
}
return results;
}
public static void main(String[] args) {
for(int i = 0; i < 20; i++) {
System.out.println(
"flavorSet(" + i + ") = ");
String[] fl = flavorSet(flav.length);
for(int j = 0; j < fl.length; j++)
System.out.println("\t" + fl[j]);
}
}
} ///:~
flavorSet() 會產生名為results 的一個String array，其容量為n，由
函式的引數決定。接下來它會隨機從array flav 中選出各種味道
(flavor)，並將選出值置於results 內，最終便是回傳results。回傳
array 的動作就跟回傳其他物件一樣，畢竟array 只是一個reference。被回
傳的array 究竟是在flavorSet() 內產生的或是在其他地方產生，一點都
不重要。當你不再使用這個array，垃圾回收器便會清理它。當你還需要它
時，它便會持續存活。
題外話，請注意，當flavorSet() 隨機選擇各種味道時，它會確保絕不做
二次重複挑選。這種保證是因為do 迴圈不斷進行隨機選取，直至找到一
個不在picked array 中的元素為止(當然你也可以採用「字串比較」的方
式來檢查隨機選取的結果是否已在results array 內。不過「字串比較」法
Chapter 9: Holding Your Objects 415
的效率並不好)。如果找到了符合條件者，便將結果加入，然後再繼續尋
找下一個(i 值會遞增1)。
main() 會印出20 組味道。所以你可以觀察到，flavorSet() 每次皆以隨
機方式挑選各種不同的味道。如果你將輸出結果導至檔案，便可輕易進行
觀察。當你檢視檔案內容時，請千萬記住，你只是「想要」冰淇淋，但並
不「需要」它。
Arrays class
你可以在java.util 中找到Arrays class，它擁有一組static 函式，能夠
執行許多array 公用函式。計有四個基本函式：equals() 用來比較兩個
array 是否相等；fill() 用來將某值填入array 內；sort() 進行array 的排
序；binarySearch() 在已排序的array 中尋找元素。所有函式皆被重
載，可用於所有基本型別和Objects 身上。此外還有一個asList() 函式，
接受任意array，並將它轉換為List 容器- 此容器將在本章稍後出現。
雖然Array 十分有用，但它缺乏完整功能。舉個例子，如果能夠輕易印出
array 的每個元素，不必每次撰寫for 迴圈來處理，其實滿好的。而且如你
所見，fill() 僅接收單一值，然後將之填入array 內，那麼如果你想要以隨
機亂數值填滿array，fill() 便幫助不大。
因此為Arrays 補充一些函式是有實際意義的。我把它們置於pacckage
com.bruceeckel.util 中。它們可以印出任意型別的array，也可以將所
有generator(產生器)所產生的數值(或物件)填入array 內。此一產生
器可由你自行定義。
由於程式碼得處理Object 型別和各種基本型別，所以有大量幾近重複的
程式碼出現3。例如我得為每一種型別提供一份"generator" interface，因
為在不同型別的情況下，next() 的回傳值型別都不相同。
3 C++ 程式員會注意到，如果使用預設引數(default arguments)和模版(template)，程
式碼能夠收斂到怎樣的程度。Python 程式員則會注意到，這整個程式庫在該語言中大部份
都是沒有必要的。
416 Thinking in Java www.BruceEckel.com
//: com:bruceeckel:util:Generator.java
package com.bruceeckel.util;
public interface Generator {
Object next();
} ///:~
//: com:bruceeckel:util:BooleanGenerator.java
package com.bruceeckel.util;
public interface BooleanGenerator {
boolean next();
} ///:~
//: com:bruceeckel:util:ByteGenerator.java
package com.bruceeckel.util;
public interface ByteGenerator {
byte next();
} ///:~
//: com:bruceeckel:util:CharGenerator.java
package com.bruceeckel.util;
public interface CharGenerator {
char next();
} ///:~
//: com:bruceeckel:util:ShortGenerator.java
package com.bruceeckel.util;
public interface ShortGenerator {
short next();
} ///:~
//: com:bruceeckel:util:IntGenerator.java
package com.bruceeckel.util;
public interface IntGenerator {
int next();
} ///:~
//: com:bruceeckel:util:LongGenerator.java
package com.bruceeckel.util;
public interface LongGenerator {
long next();
} ///:~
Chapter 9: Holding Your Objects 417
//: com:bruceeckel:util:FloatGenerator.java
package com.bruceeckel.util;
public interface FloatGenerator {
float next();
} ///:~
//: com:bruceeckel:util:DoubleGenerator.java
package com.bruceeckel.util;
public interface DoubleGenerator {
double next();
} ///:~
Array2 含有許多print() 函式，分別針對各種型別進行重載。你可以單
純印出array、或是在array 被印出前加一段訊息，或是印出array 中某個
範圍內的元素。至於print() 函式碼本身無需多加解釋，你也能明白：
//: com:bruceeckel:util:Arrays2.java
// A supplement to java.util.Arrays, to provide
// additional useful functionality when working
// with arrays. Allows any array to be printed,
// and to be filled via a user-defined
// "generator" object.
package com.bruceeckel.util;
import java.util.*;
public class Arrays2 {
private static void
start(int from, int to, int length) {
if(from != 0 || to != length)
System.out.print("["+ from +":"+ to +"] ");
System.out.print("(");
}
private static void end() {
System.out.println(")");
}
public static void print(Object[] a) {
418 Thinking in Java www.BruceEckel.com
print(a, 0, a.length);
}
public static void
print(String msg, Object[] a) {
System.out.print(msg + " ");
print(a, 0, a.length);
}
public static void
print(Object[] a, int from, int to){
start(from, to, a.length);
for(int i = from; i < to; i++) {
System.out.print(a[i]);
if(i < to -1)
System.out.print(", ");
}
end();
}
public static void print(boolean[] a) {
print(a, 0, a.length);
}
public static void
print(String msg, boolean[] a) {
System.out.print(msg + " ");
print(a, 0, a.length);
}
public static void
print(boolean[] a, int from, int to) {
start(from, to, a.length);
for(int i = from; i < to; i++) {
System.out.print(a[i]);
if(i < to -1)
System.out.print(", ");
}
end();
}
public static void print(byte[] a) {
print(a, 0, a.length);
}
public static void
print(String msg, byte[] a) {
System.out.print(msg + " ");
Chapter 9: Holding Your Objects 419
print(a, 0, a.length);
}
public static void
print(byte[] a, int from, int to) {
start(from, to, a.length);
for(int i = from; i < to; i++) {
System.out.print(a[i]);
if(i < to -1)
System.out.print(", ");
}
end();
}
public static void print(char[] a) {
print(a, 0, a.length);
}
public static void
print(String msg, char[] a) {
System.out.print(msg + " ");
print(a, 0, a.length);
}
public static void
print(char[] a, int from, int to) {
start(from, to, a.length);
for(int i = from; i < to; i++) {
System.out.print(a[i]);
if(i < to -1)
System.out.print(", ");
}
end();
}
public static void print(short[] a) {
print(a, 0, a.length);
}
public static void
print(String msg, short[] a) {
System.out.print(msg + " ");
print(a, 0, a.length);
}
public static void
print(short[] a, int from, int to) {
start(from, to, a.length);
420 Thinking in Java www.BruceEckel.com
for(int i = from; i < to; i++) {
System.out.print(a[i]);
if(i < to - 1)
System.out.print(", ");
}
end();
}
public static void print(int[] a) {
print(a, 0, a.length);
}
public static void
print(String msg, int[] a) {
System.out.print(msg + " ");
print(a, 0, a.length);
}
public static void
print(int[] a, int from, int to) {
start(from, to, a.length);
for(int i = from; i < to; i++) {
System.out.print(a[i]);
if(i < to - 1)
System.out.print(", ");
}
end();
}
public static void print(long[] a) {
print(a, 0, a.length);
}
public static void
print(String msg, long[] a) {
System.out.print(msg + " ");
print(a, 0, a.length);
}
public static void
print(long[] a, int from, int to) {
start(from, to, a.length);
for(int i = from; i < to; i++) {
System.out.print(a[i]);
if(i < to - 1)
System.out.print(", ");
}
Chapter 9: Holding Your Objects 421
end();
}
public static void print(float[] a) {
print(a, 0, a.length);
}
public static void
print(String msg, float[] a) {
System.out.print(msg + " ");
print(a, 0, a.length);
}
public static void
print(float[] a, int from, int to) {
start(from, to, a.length);
for(int i = from; i < to; i++) {
System.out.print(a[i]);
if(i < to - 1)
System.out.print(", ");
}
end();
}
public static void print(double[] a) {
print(a, 0, a.length);
}
public static void
print(String msg, double[] a) {
System.out.print(msg + " ");
print(a, 0, a.length);
}
public static void
print(double[] a, int from, int to){
start(from, to, a.length);
for(int i = from; i < to; i++) {
System.out.print(a[i]);
if(i < to - 1)
System.out.print(", ");
}
end();
}
// Fill an array using a generator:
public static void
fill(Object[] a, Generator gen) {
422 Thinking in Java www.BruceEckel.com
fill(a, 0, a.length, gen);
}
public static void
fill(Object[] a, int from, int to,
Generator gen){
for(int i = from; i < to; i++)
a[i] = gen.next();
}
public static void
fill(boolean[] a, BooleanGenerator gen) {
fill(a, 0, a.length, gen);
}
public static void
fill(boolean[] a, int from, int to,
BooleanGenerator gen) {
for(int i = from; i < to; i++)
a[i] = gen.next();
}
public static void
fill(byte[] a, ByteGenerator gen) {
fill(a, 0, a.length, gen);
}
public static void
fill(byte[] a, int from, int to,
ByteGenerator gen) {
for(int i = from; i < to; i++)
a[i] = gen.next();
}
public static void
fill(char[] a, CharGenerator gen) {
fill(a, 0, a.length, gen);
}
public static void
fill(char[] a, int from, int to,
CharGenerator gen) {
for(int i = from; i < to; i++)
a[i] = gen.next();
}
public static void
fill(short[] a, ShortGenerator gen) {
fill(a, 0, a.length, gen);
Chapter 9: Holding Your Objects 423
}
public static void
fill(short[] a, int from, int to,
ShortGenerator gen) {
for(int i = from; i < to; i++)
a[i] = gen.next();
}
public static void
fill(int[] a, IntGenerator gen) {
fill(a, 0, a.length, gen);
}
public static void
fill(int[] a, int from, int to,
IntGenerator gen) {
for(int i = from; i < to; i++)
a[i] = gen.next();
}
public static void
fill(long[] a, LongGenerator gen) {
fill(a, 0, a.length, gen);
}
public static void
fill(long[] a, int from, int to,
LongGenerator gen) {
for(int i = from; i < to; i++)
a[i] = gen.next();
}
public static void
fill(float[] a, FloatGenerator gen) {
fill(a, 0, a.length, gen);
}
public static void
fill(float[] a, int from, int to,
FloatGenerator gen) {
for(int i = from; i < to; i++)
a[i] = gen.next();
}
public static void
fill(double[] a, DoubleGenerator gen) {
fill(a, 0, a.length, gen);
}
424 Thinking in Java www.BruceEckel.com
public static void
fill(double[] a, int from, int to,
DoubleGenerator gen){
for(int i = from; i < to; i++)
a[i] = gen.next();
}
private static Random r = new Random();
public static class RandBooleanGenerator
implements BooleanGenerator {
public boolean next()
return r.nextBoolean();
}
}
public static class RandByteGenerator
implements ByteGenerator {
public byte next()
return (byte)r.nextInt();
}
}
static String ssource =
"ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
"abcdefghijklmnopqrstuvwxyz";
static char[] src = ssource.toCharArray();
public static class RandCharGenerator
implements CharGenerator {
public char next() {
int pos = Math.abs(r.nextInt());
return src[pos % src.length];
}
}
public static class RandStringGenerator
implements Generator {
private int len;
private RandCharGenerator cg =
new RandCharGenerator();
public RandStringGenerator(int length) {
len = length;
}
public Object next() {
char[] buf = new char[len];
for(int i = 0; i < len; i++)
Chapter 9: Holding Your Objects 425
buf[i] = cg.next();
return new String(buf);
}
}
public static class RandShortGenerator
implements ShortGenerator {
public short next()
return (short)r.nextInt();
}
}
public static class RandIntGenerator
implements IntGenerator {
private int mod = 10000;
public RandIntGenerator() {}
public RandIntGenerator(int modulo) {
mod = modulo;
}
public int next()
return r.nextInt() % mod;
}
}
public static class RandLongGenerator
implements LongGenerator {
public long next() { return r.nextLong(); }
}
public static class RandFloatGenerator
implements FloatGenerator {
public float next() { return r.nextFloat(); }
}
public static class RandDoubleGenerator
implements DoubleGenerator {
public double next() {return r.nextDouble();}
}
} ///:~
為了使用產生器(generator)來填補array 內的元素空間，fill() 接受一個
reference，此reference 指向某個適當的generator interface，其中擁有
next()，能夠以某種方式產生正確型別的物件(這和interface 的實作版本
有關)。fill() 只是不斷呼叫next()，直至填滿所欲填滿的範圍為止。於
426 Thinking in Java www.BruceEckel.com
是，你便可以實作適當的interface 而產生任何型式的產生器，並搭配fill()
使用。
隨機產生器(random data generator)在測試上極為有用，所以我寫了一
組inner classes，將所有基本型別產生器的interface 實作出來，同時也實
作了一個String 產生器，用以表現Object 的情況。你可以看到，
RandStringGenerator 使用RandCharGenerator 填入char array，
再將此array 轉換為String。array 的容量由建構式引數決定。
為了使產生的數字不至於過大，RandIntGenerator 會將產生的值對
10,000 取餘數。不過，重載版的建構式讓你可以選用更小的值。
以下程式用來測試整個程式庫，它同時也示範了這個程式庫的使用方式：
//: c09:TestArrays2.java
// Test and demonstrate Arrays2 utilities
import com.bruceeckel.util.*;
public class TestArrays2 {
public static void main(String[] args) {
int size = 6;
// Or get the size from the command line:
if(args.length != 0)
size = Integer.parseInt(args[0]);
boolean[] a1 = new boolean[size];
byte[] a2 = new byte[size];
char[] a3 = new char[size];
short[] a4 = new short[size];
int[] a5 = new int[size];
long[] a6 = new long[size];
float[] a7 = new float[size];
double[] a8 = new double[size];
String[] a9 = new String[size];
Arrays2.fill(a1,
new Arrays2.RandBooleanGenerator());
Arrays2.print(a1);
Arrays2.print("a1 = ", a1);
Arrays2.print(a1, size/3, size/3 + size/3);
Arrays2.fill(a2,
Chapter 9: Holding Your Objects 427
new Arrays2.RandByteGenerator());
Arrays2.print(a2);
Arrays2.print("a2 = ", a2);
Arrays2.print(a2, size/3, size/3 + size/3);
Arrays2.fill(a3,
new Arrays2.RandCharGenerator());
Arrays2.print(a3);
Arrays2.print("a3 = ", a3);
Arrays2.print(a3, size/3, size/3 + size/3);
Arrays2.fill(a4,
new Arrays2.RandShortGenerator());
Arrays2.print(a4);
Arrays2.print("a4 = ", a4);
Arrays2.print(a4, size/3, size/3 + size/3);
Arrays2.fill(a5,
new Arrays2.RandIntGenerator());
Arrays2.print(a5);
Arrays2.print("a5 = ", a5);
Arrays2.print(a5, size/3, size/3 + size/3);
Arrays2.fill(a6,
new Arrays2.RandLongGenerator());
Arrays2.print(a6);
Arrays2.print("a6 = ", a6);
Arrays2.print(a6, size/3, size/3 + size/3);
Arrays2.fill(a7,
new Arrays2.RandFloatGenerator());
Arrays2.print(a7);
Arrays2.print("a7 = ", a7);
Arrays2.print(a7, size/3, size/3 + size/3);
Arrays2.fill(a8,
new Arrays2.RandDoubleGenerator());
Arrays2.print(a8);
Arrays2.print("a8 = ", a8);
Arrays2.print(a8, size/3, size/3 + size/3);
Arrays2.fill(a9,
new Arrays2.RandStringGenerator(7));
Arrays2.print(a9);
Arrays2.print("a9 = ", a9);
Arrays2.print(a9, size/3, size/3 + size/3);
}
} ///:~
428 Thinking in Java www.BruceEckel.com
size 參數有個預設值，但你也可以在命令列(command line)中設定它。
array 的充填(filling)
Java 標準程式庫中的Arrayes 也有個fill()，但是它更為普通，只是將單
一數值(如果面對物件的話，則是將同一個reference)複製到每個位置。
實際用一下Array2.print() 便能輕易體會Arrays.fill() 的行為模式：
//: c09:FillingArrays.java
// Using Arrays.fill()
import com.bruceeckel.util.*;
import java.util.*;
public class FillingArrays {
public static void main(String[] args) {
int size = 6;
// Or get the size from the command line:
if(args.length != 0)
size = Integer.parseInt(args[0]);
boolean[] a1 = new boolean[size];
byte[] a2 = new byte[size];
char[] a3 = new char[size];
short[] a4 = new short[size];
int[] a5 = new int[size];
long[] a6 = new long[size];
float[] a7 = new float[size];
double[] a8 = new double[size];
String[] a9 = new String[size];
Arrays.fill(a1, true);
Arrays2.print("a1 = ", a1);
Arrays.fill(a2, (byte)11);
Arrays2.print("a2 = ", a2);
Arrays.fill(a3, 'x');
Arrays2.print("a3 = ", a3);
Arrays.fill(a4, (short)17);
Arrays2.print("a4 = ", a4);
Arrays.fill(a5, 19);
Arrays2.print("a5 = ", a5);
Arrays.fill(a6, 23);
Chapter 9: Holding Your Objects 429
Arrays2.print("a6 = ", a6);
Arrays.fill(a7, 29);
Arrays2.print("a7 = ", a7);
Arrays.fill(a8, 47);
Arrays2.print("a8 = ", a8);
Arrays.fill(a9, "Hello");
Arrays2.print("a9 = ", a9);
// Manipulating ranges:
Arrays.fill(a9, 3, 5, "World");
Arrays2.print("a9 = ", a9);
}
} ///:~
你可以填滿整個array，或是如最末兩行所展示的那樣，只填充一段範圍。
但如果使用Arrays.fill()，只能給定單一值。Arrays2.fill() 能產生更有
趣的結果。
array 的複製
Java 標準程式庫提供一個名為System.arraycopy() 的static 函式。和
「自己手動利用for 迴圈來執行複製」相比，這個函式提供更快速的array
複製能力。System.arraycopy() 被重載以處理所有型別。以下便是處理
int array 的例子：
//: c09:CopyingArrays.java
// Using System.arraycopy()
import com.bruceeckel.util.*;
import java.util.*;
public class CopyingArrays {
public static void main(String[] args) {
int[] i = new int[25];
int[] j = new int[25];
Arrays.fill(i, 47);
Arrays.fill(j, 99);
Arrays2.print("i = ", i);
Arrays2.print("j = ", j);
System.arraycopy(i, 0, j, 0, i.length);
Arrays2.print("j = ", j);
430 Thinking in Java www.BruceEckel.com
int[] k = new int[10];
Arrays.fill(k, 103);
System.arraycopy(i, 0, k, 0, k.length);
Arrays2.print("k = ", k);
Arrays.fill(k, 103);
System.arraycopy(k, 0, i, 0, k.length);
Arrays2.print("i = ", i);
// Objects:
Integer[] u = new Integer[10];
Integer[] v = new Integer[5];
Arrays.fill(u, new Integer(47));
Arrays.fill(v, new Integer(99));
Arrays2.print("u = ", u);
Arrays2.print("v = ", v);
System.arraycopy(v, 0,
u, u.length/2, v.length);
Arrays2.print("u = ", u);
}
} ///:~
傳入arraycopy() 的引數包括來源端array、來源端複製起點(偏移位
置)、目的端array、目的端接受起點(偏移位置)，以及複製個數。當
然，萬一發生array 越界存取，便會引發異常(exceptions)。
這個例子展示一個事實：privitives array 和objects array 都可被複製。
不過，複製objects array 時僅有references 會被複製，元素(物件)本身
並不會被複製。此即所謂淺層拷貝(shallow copy)，請參考附錄A。
arrays 的比較
Arrays 提供重載版的equals()，藉以比較兩個arrays 是否相等。它能夠
處理Object 和所有基本型別。兩個arrays 必須擁有相同個數的元素，而
且所有對應元素必須兩兩相等(使用元素自己的equals() 來檢驗它們是否
相等。如果元素屬於基本型別，則使用外覆類別的equals() 來進行比
較。如果面對的是int，就使用Integer.equals()。以下便是一例：
//: c09:ComparingArrays.java
// Using Arrays.equals()
Chapter 9: Holding Your Objects 431
import java.util.*;
public class ComparingArrays {
public static void main(String[] args) {
int[] a1 = new int[10];
int[] a2 = new int[10];
Arrays.fill(a1, 47);
Arrays.fill(a2, 47);
System.out.println(Arrays.equals(a1, a2));
a2[3] = 11;
System.out.println(Arrays.equals(a1, a2));
String[] s1 = new String[5];
Arrays.fill(s1, "Hi");
String[] s2 = {"Hi", "Hi", "Hi", "Hi", "Hi"};
System.out.println(Arrays.equals(s1, s2));
}
} ///:~
一開始a1 和a2 完全相等，所以其輸出結果為"true"。接下來有一個元素
被改變了，所以第二個輸出結果為"false"。最後一個情形，s1 的所有元素
都指向同一物件，s2 卻擁有五個不同物件，不過由於array 的相等測試是
依據其內容來決定(透過Object.equals())，所以結果為"true"。
array 元素的比較
Java 1.0 和1.1 的程式庫缺乏演算法式的操作(algorithmic operations)，
連簡單的排序都沒有。標準程式庫應該具備哪些功能，實乃見仁見智，但
上述情況對某些人來說無疑十分困惑。還好Java 2 補救了這個問題，至少
補強了排序能力。
撰寫一份泛型排序碼，面臨的問題是，排序必須依據物件實際型別來進行
比較。當然，為各種不同型別都分別撰寫一份排序用的函式，也是一種解
決辦法，但你應該能夠理解，這種作法無法輕易用於新型別身上。
程式設計的主要目標，是要將「變動的事物和不變的事物隔離開來」。在
這裡，保持不變的，就是泛用排序演算法，會變動的，則是物件的比較
法。所以，如果不希望將物件比較動作寫死於許多不同的排序函式中，我
432 Thinking in Java www.BruceEckel.com
們可以採用callback(回呼)技巧。透過callback，「因勢而異的程式碼」
可被封裝於自己的class 內，而「永不變動的程式碼」則回頭呼叫前者。透
過這個手法，便可讓不同的物件各自表述其不同的比較法，並將該比較法
餵進同一個排序法則中。
Java 2 提供兩種比較機能。第一個是透過所謂natural comparison
method(自然比較法)，藉由實作java.lang.Comparable interface，
使某個class 具有比較能力。上述interface 是個極為簡單的interface，只
有一個函式：compareTo()，接受另一個Object 做為引數：引數小於自
己時回傳負值，二者相等時回傳零值，引數大於自己時回傳正值。
以下就是一個實作了Comparable 的class，並使用Java 標準程式庫中的
Arrays.sort() 示範比較動作。
//: c09:CompType.java
// Implementing Comparable in a class.
import com.bruceeckel.util.*;
import java.util.*;
public class CompType implements Comparable {
int i;
int j;
public CompType(int n1, int n2)
i = n1;
j = n2;
}
public String toString()
return "[i = " + i + ", j = " + j + "]";
}
public int compareTo(Object rv) {
int rvi = ((CompType)rv).i;
return (i < rvi ? -1 : (i == rvi ? 0 : 1));
}
private static Random r = new Random();
private static int randInt() {
return Math.abs(r.nextInt()) % 100;
}
public static Generator generator() {
return new Generator() {
Chapter 9: Holding Your Objects 433
public Object next() {
return new CompType(randInt(),randInt());
}
};
}
public static void main(String[] args) {
CompType[] a = new CompType[10];
Arrays2.fill(a, generator());
Arrays2.print("before sorting, a = ", a);
Arrays.sort(a);
Arrays2.print("after sorting, a = ", a);
}
} ///:~
一旦你定義了比較函式，你便得負責決定你自己的物件與其他物件之間的
比較意義為何。在這個例子中，僅使用i 值來進行比較，j 值被忽略。
static randInt() 會產生介於0 和100 之間的正值，generator() 則透過
匿名的inner class 產生出實作Generator interface 的一個物件(請參考
第8 章)。這於是產生出CompType 物件，並以亂數值加以初始化。
main() 內利用generator 充填CompType array，再加以排序。呼叫
sort() 時，如果CompType 並未實作出Comparable，你便會收到編
譯期錯誤訊息。
現在，假設某人交給你一個class，此class 並未實作Comparable。或者
交給你一個實作有Comparable 的class，但你不喜歡那種實作方式，也
不想讓每個型別都擁有個別的比較函式。那麼你可以使用第二種物件比較
方案，也就是撰寫一個class，令它實作Comparator interface。這個
interface 擁有兩個函式：compare() 和equals()。但除非為了特殊效率
考量，否則不需要實作equals()。因為你所撰寫的所有classes 會自動繼
承Object，而後者已經具備equals()。所以你可以直接使用預設的
Object euqlas()，這樣便能滿足前述interface 的規範。
434 Thinking in Java www.BruceEckel.com
Collections class(本章稍後我將會討論)內含唯一一個Comparator，
可將正常的排列順序顛倒過來。它可輕易被應用於CompType：
//: c09:Reverse.java
// The Collecions.reverseOrder() Comparator.
import com.bruceeckel.util.*;
import java.util.*;
public class Reverse {
public static void main(String[] args) {
CompType[] a = new CompType[10];
Arrays2.fill(a, CompType.generator());
Arrays2.print("before sorting, a = ", a);
Arrays.sort(a, Collections.reverseOrder());
Arrays2.print("after sorting, a = ", a);
}
} ///:~
呼叫Collections.reverseOrder()後你會得到一個reference，指向
Comparator。
第二個例子是，以下的Comparator 會依據CompType 物件的j 值(而
非i 值)來進行比較。
//: c09:ComparatorTest.java
// Implementing a Comparator for a class.
import com.bruceeckel.util.*;
import java.util.*;
class CompTypeComparator implements Comparator {
public int compare(Object o1, Object o2) {
int j1 = ((CompType)o1).j;
int j2 = ((CompType)o2).j;
return (j1 < j2 ? -1 : (j1 == j2 ? 0 : 1));
}
}
public class ComparatorTest {
Chapter 9: Holding Your Objects 435
public static void main(String[] args) {
CompType[] a = new CompType[10];
Arrays2.fill(a, CompType.generator());
Arrays2.print("before sorting, a = ", a);
Arrays.sort(a, new CompTypeComparator());
Arrays2.print("after sorting, a = ", a);
}
} ///:~
compare() 的第一引數小於、等於、或大於第二引數時，必須分別回傳負
整數、零值、正整數。
array 的排序
使用內建的sorting 函式時，你可以針對任何primitives array 進行排序，
也可以針對任何objects array 進行排序( 只要那些物件實作了
Comparable 或擁有相關之Comparator)。這填補了Java 程式庫的一
個大漏洞- 不論你相信與否，Java 1.0 和1.1 竟然完全沒有支援Strings
的排序！以下這個範例會隨機產生String 物件，並加排序：
//: c09:StringSorting.java
// Sorting an array of Strings.
import com.bruceeckel.util.*;
import java.util.*;
public class StringSorting {
public static void main(String[] args) {
String[] sa = new String[30];
Arrays2.fill(sa,
new Arrays2.RandStringGenerator(5));
Arrays2.print("Before sorting: ", sa);
Arrays.sort(sa);
Arrays2.print("After sorting: ", sa);
}
} ///:~
從String 排序演算法的輸出結果中你會注意到，這個演算法乃根據「字典
順序」進行排序。所以它會將所有以大寫字母為首的字詞置於以小寫字母
為首的字詞之前(電話簿通常便是以此種方式排列)。你也可能會想要以
436 Thinking in Java www.BruceEckel.com
不分大小寫的方式排序，為此你可定義一個Comparator class，並覆寫
String Comparable 的預設行為。基於重複運用的理由，這個class 被加
至"util" package 中：
//: com:bruceeckel:util:AlphabeticComparator.java
// Keeping upper and lowercase letters together.
package com.bruceeckel.util;
import java.util.*;
public class AlphabeticComparator
implements Comparator{
public int compare(Object o1, Object o2) {
String s1 = (String)o1;
String s2 = (String)o2;
return s1.toLowerCase().compareTo(
s2.toLowerCase());
}
} ///:~
進行比較之前每個String 都先被轉為小寫。String 內建的compareTo()
提供了我們想要的功能。
以下使用AlphabeticComparator 進行測試：
//: c09:AlphabeticSorting.java
// Keeping upper and lowercase letters together.
import com.bruceeckel.util.*;
import java.util.*;
public class AlphabeticSorting {
public static void main(String[] args) {
String[] sa = new String[30];
Arrays2.fill(sa,
new Arrays2.RandStringGenerator(5));
Arrays2.print("Before sorting: ", sa);
Arrays.sort(sa, new AlphabeticComparator());
Arrays2.print("After sorting: ", sa);
}
} ///:~
Chapter 9: Holding Your Objects 437
Java 標準程式庫的排序演算法，會針對你所排序的型別來進行最佳化。面
對基本型別時用的是Quicksort；面對物件則採用stable merge sort。所以
你不應該浪費時間於其執行效率的改善上面，除非你的效能量測工具指
出，你的排序動作的確是執行效率上的瓶頸。
在已排序的array 中進行搜尋
array 排序完畢後，你可以使用Arrays.binarySearch() 快速搜尋某個元
素。但是千萬別在未經排序的array 身上使用binarySearch()，否則結
果完全無法預測。下面這個例子先使用RandIntGenerator 將數值填入
array，然後產生搜尋目標：
//: c09:ArraySearching.java
// Using Arrays.binarySearch().
import com.bruceeckel.util.*;
import java.util.*;
public class ArraySearching {
public static void main(String[] args) {
int[] a = new int[100];
Arrays2.RandIntGenerator gen =
new Arrays2.RandIntGenerator(1000);
Arrays2.fill(a, gen);
Arrays.sort(a);
Arrays2.print("Sorted array: ", a);
while(true) {
int r = gen.next();
int location = Arrays.binarySearch(a, r);
if(location >= 0) {
System.out.println("Location of " + r +
" is " + location + ", a[" +
location + "] = " + a[location]);
break; // Out of while loop
}
}
}
} ///:~
438 Thinking in Java www.BruceEckel.com
在while 迴圈中，隨機值會被不斷產生出來，做為搜尋目標，直到在
array 中確實找到該值為止。
如果找到了搜尋目標，Arrays.binarySearch() 會回傳一個大於或等於
零的值。反之則回傳一個負值，表示該值應被安插的位置- 亦即如果希望
該值加入array 之後仍能保持array 的排序狀態，該值應該被安插的位置。
這個負值是：
-(insertion point) - 1
其中insertion point 就是第一個大於搜尋值(或說鍵值，key)的元
素的索引值。如果array 之內所有元素都小於搜尋值，insertion
point 即為a.size()。
如果array 內含多個相同元素，上述搜尋動作不保證會搜出其中哪一個元
素。這個演算法設計時並未考量「元素重複」的情況，只不過畢竟還能得
兼。如果你需要的是一個無重複元素的sorted list，請採用稍後即將介紹的
TreeSet，它會自動為你處理所有細節。只有當TreeSet 成為效率瓶頸
時，你才需要以一個手動維護的array 來取代TreeSet。
如果你已經以Comparator 對objects array 排序(注意，primitives
array 不允許以Comparator 排序)，那麼當你執行binarySearch()
時(用的是其重載版本)，就得使用同一個Comparator。例如我們修改
AlphabeticSorting.java 程式，執行搜尋動作：
//: c09:AlphabeticSearch.java
// Searching with a Comparator.
import com.bruceeckel.util.*;
import java.util.*;
public class AlphabeticSearch {
public static void main(String[] args) {
String[] sa = new String[30];
Arrays2.fill(sa,
new Arrays2.RandStringGenerator(5));
AlphabeticComparator comp =
new AlphabeticComparator();
Arrays.sort(sa, comp);
int index =
Chapter 9: Holding Your Objects 439
Arrays.binarySearch(sa, sa[10], comp);
System.out.println("Index = " + index);
}
} ///:~
Comparator 必須被傳入binarySearch() 重載版本，做為第三引數。
上例的搜尋一定會成功，因為搜尋目標是由array 自身取出的。
Array 總結
總結至今所討論的內容，當你持有一大群物件，你的第一(也是最高效
能)的選擇應該是array。如果你想持有一群基本型別數值，也只能選擇
array。本章剩餘篇幅中，我會探討更一般化的情形。在那些情況下，撰寫
程式時你並不知道究竟需要多少物件，因此你需要更複雜的方法來持有它
們。Java 提供一套容器類別程式庫(container classes library)用以解決
這個問題，其基本類型包括：List、Set、Map。你可以運用這些工具來
解決極多問題。
這些容器各自有其特性。例如Set 針對每個值只會儲存一個物件；Map 是
個關聯式array(associative array)，讓你得以將某個物件關聯至另一個
物件。Java 容器會自動調整自己的容量，所以，和array 不同，你可以置
入任意個數的物件，撰寫應用程式時不需擔心容量問題。
容器(containers)簡介
對我而言，容器用於一個嶄新的專案開發上，是最有威力的工具之一，因
為它可以大幅增加你的編程實力。Java 2 容器是針對Java 1.0 和1.1 中頗為
差勁的表現所做的徹底重新設計4。重新設計後的結果，某些事物更嚴謹也
更實用，並且豐富了容器程式庫(containers library)的機能，提供了
linked-list、queue、deques(兩端開口的queue，讀做"decks")。
4 由Sun 公司的Joshua Bloch 操刀。
440 Thinking in Java www.BruceEckel.com
容器程式庫的設計十分困難(大部份程式庫都如此)。在C++ 中，容器類
別以許多不同的classes 呈現。這比過去什麼都沒有的情況當然好多了。但
這種方式並未轉移到Java 身上。我曾經看過一個極端的例子，某個市售容
器庫只有單一一個"container" class，其行為模式既像個線性序列(linear
sequence)又像個關聯式(associative)array。Java 2 容器庫取乎中庸：
你認為一個成熟的容器庫該有的功能它都具備了，但比C++容器類別及其
他容器庫更易學習和運用。這樣的結果似乎有些詭異，但由於它和早先的
Java 程式庫的某些決策不同，因此這種詭異並非偶然，是權衡複雜度之後
的謹慎考量結果。你也許得花點時間才能夠上手，但我想你很快會發現，
自己將快速學成並愛上這些新工具。
Java 2 容器庫所解決的是物件持有問題，並將它區分為兩個不同的概念：
1. Collection：一組各自獨立的元素，通常擁有相同的套用規則：
List 必須以特定次序來持有各元素；Set 無法擁有重複元素- bag
並無如此限制(Java 容器庫未實作有bag，因為Lists 已提供足夠
功能)。
2. Map：一群成對的key-value 物件(譯註：由「鍵值/實值」成對構
成的物件)。乍見之下它似乎應該是一個由"pair" 物件組成的
Collection，但是當你試著以這種方法實現時，整個設計會變得極
為笨拙。使其成為一個獨立概念反倒更清楚些。另一方面，如果能
夠產生Collection 來表示Map 的內容，將會極為便利，因此
Map 可以回傳一個由key(鍵值)形成的Set，或是一個由value
(實值)形成的Collection，或是一個內含key-value pairs 的
Set。Maps 就和array 一樣，無需加入新概念，便可輕易擴展成多
維形式：只要讓Map 的實值(values)又是個Map 即可，後者的
實值(values)還可以再是Maps…依此類推。
我首先探討容器的一般性質，然後再深入研究其細節，最後我們看看為什
麼需要某些容器的特別版本，以及它們的選擇方式。
Chapter 9: Holding Your Objects 441
容器的列印
和array 不同的是，無需任何額外處理，便能巧妙印出容器內容。以下便
是一例，此例同時為你介紹基本的容器類型：
//: c09:PrintingContainers.java
// Containers print themselves automatically.
import java.util.*;
public class PrintingContainers {
static Collection fill(Collection c) {
c.add("dog");
c.add("dog");
c.add("cat");
return c;
}
static Map fill(Map m) {
m.put("dog", "Bosco");
m.put("dog", "Spot");
m.put("cat", "Rags");
return m;
}
public static void main(String[] args) {
System.out.println(fill(new ArrayList()));
System.out.println(fill(new HashSet()));
System.out.println(fill(new HashMap()));
}
} ///:~
一如先前所述，在Java 容器庫中有兩個基本分類。其間的區別主要在於容
器內每個位置所儲存的元素個數。屬於Collection 類型者，其內的每個位
置僅持有一個元素(Collection 這個名稱可能會造成若干誤會，因為整個
Java 容器庫往往又被稱為"collection")。這一類型包括有：List，以特定
次序儲存一組元素；Set，元素不得重複。ArrayList 是一種List，而
HashSet 則是一種Set。add() 可將元素加入任何一種Collection。
Map 所持有的則是key-value pairs，像個小型資料庫。上述實例運用了
Map 中的一種：HashMap。如果你擁有某個Map，它將美國州名關聯至
442 Thinking in Java www.BruceEckel.com
其首府名稱，而你想知道俄亥俄州的首府名稱，那麼，搜尋方式就像對
array 進行索引動作一樣。所以Maps 也被稱為關聯式(associative)
arrays。欲將元素加至Map，可使用put()，它接收key 和value 做為引
數。上例只示範元素的加入方式，但沒有在加入之後執行搜尋動作。稍後
會說明搜尋方式。
fill() 的重載版本可用來充填Collections 和Maps。如果你檢視輸出結
果，你會發現，預設的列印功能(由各容器本身的toString() 提供)所產
生的結果極具可讀性，所以我們不必像面對array 那樣地對列印提供額外
支援：
[dog, dog, cat]
[cat, dog]
{cat=Rags, dog=Spot}
Collection 的列印結果以方括號括住，每個元素之間以逗號相隔。Map
的列印結果則以大括號括住，key 和value 之間以等號相接，key 在左側，
value 在右側。
你馬上可以觀察到不同容器的基本行為。List 會以元素安插次序來放置元
素，不會重新排列或編修。Set 不接受重複元素，它會使用自己內部的一
個排列(ordering)機制。如果你只關心某個物件是否存在，而不關心它
們的出現順序，那麼你應該使用List。Map 也不接受重複元素，重複與否
乃以鍵值(key)判斷。Map 也擁有自己的內部排列(ordering)機制，
它一點也不在意你安插元素時的次序。
容器的充填
雖然容器的列印問題已獲解決，但是容器的充填動作卻和先前討論的
java.util.Arrays 一樣不足。和Arrays 一樣，有個相應的Collections
class，含有一些static 函式，其中之一便稱為fill()。它只是將同一個
object reference 複製到容器的每個位置上，而且只對List 有效，無法作用
於Sets 或Maps：
Chapter 9: Holding Your Objects 443
//: c09:FillingLists.java
// The Collections.fill() method.
import java.util.*;
public class FillingLists {
public static void main(String[] args) {
List list = new ArrayList();
for(int i = 0; i < 10; i++)
list.add("");
Collections.fill(list, "Hello");
System.out.println(list);
}
} ///:~
這個函式只能替換掉原先已存在於List 中的元素，無法加入新元素。這使
它顯得更是沒有用處。
為了撰寫更有趣的例子，這裡我提供一個用來進行補強的Collection2 程
式庫(是的，com.bruceeckel.util 之中有些東西純粹是為了更方便)，
其中的fill() 會利用generator(自動產生器)來加入元素，並允許你指定
想要加入的元素個數。先前所定義的Generator interface 同樣能用於
Collections 身上，但Map 就得有自己的generator interface，因為每
次呼叫next() 都得產生成對的物件才行(其一為key，另一為value)。
以下便是Pair class：
//: com:bruceeckel:util:Pair.java
package com.bruceeckel.util;
public class Pair {
public Object key, value;
Pair(Object k, Object v) {
key = k;
value = v;
}
} ///:~
下面是Pair 的generator interface：
444 Thinking in Java www.BruceEckel.com
//: com:bruceeckel:util:MapGenerator.java
package com.bruceeckel.util;
public interface MapGenerator {
Pair next();
} ///:~
有了這些classes，我們便可以發展一套處理容器類別的公用程式：
//: com:bruceeckel:util:Collections2.java
// To fill any type of container
// using a generator object.
package com.bruceeckel.util;
import java.util.*;
public class Collections2 {
// Fill an array using a generator:
public static void
fill(Collection c, Generator gen, int count) {
for(int i = 0; i < count; i++)
c.add(gen.next());
}
public static void
fill(Map m, MapGenerator gen, int count) {
for(int i = 0; i < count; i++) {
Pair p = gen.next();
m.put(p.key, p.value);
}
}
public static class RandStringPairGenerator
implements MapGenerator {
private Arrays2.RandStringGenerator gen;
public RandStringPairGenerator(int len) {
gen = new Arrays2.RandStringGenerator(len);
}
public Pair next() {
return new Pair(gen.next(), gen.next());
}
}
// Default object so you don't have
// to create your own:
public static RandStringPairGenerator rsp =
Chapter 9: Holding Your Objects 445
new RandStringPairGenerator(10);
public static class StringPairGenerator
implements MapGenerator {
private int index = -1;
private String[][] d;
public StringPairGenerator(String[][] data) {
d = data;
}
public Pair next() {
// Force the index to wrap:
index = (index + 1) % d.length;
return new Pair(d[index][0], d[index][1]);
}
public StringPairGenerator reset()
index = -1;
return this;
}
}
// Use a predefined dataset:
public static StringPairGenerator geography =
new StringPairGenerator(
CountryCapitals.pairs);
// Produce a sequence from a 2D array:
public static class StringGenerator
implements Generator {
private String[][] d;
private int position;
private int index = -1;
public
StringGenerator(String[][] data, int pos) {
d = data;
position = pos;
}
public Object next() {
// Force the index to wrap:
index = (index + 1) % d.length;
return d[index][position];
}
public StringGenerator reset()
index = -1;
return this;
446 Thinking in Java www.BruceEckel.com
}
}
// Use a predefined dataset:
public static StringGenerator countries =
new StringGenerator(CountryCapitals.pairs,0);
public static StringGenerator capitals =
new StringGenerator(CountryCapitals.pairs,1);
} ///:~
兩個版本的fill() 都接受一個「決定容器元素個數」的引數。此外我為
Map 提供兩個自動產生器：(1) RandStringPairGenerator，它會產生
任意個數的、成對的、隨機的Strings，字串長度由建構式引數決定；(2)
StringPairGenerator，它能夠根據外界給予的二維String array，產生
成對的Strings。StringGenerator 也接收二維String array，但它產生
的是單一元素而非一個Pairs。static rsp, geography, countries,
capitals 等物件各自提供了預製的產生器，後三者使用的是世界各國的名
稱和首都。請注意，如果你嘗試產生更多成對資訊，超過了可用資料，產
生器會自動回繞到啟始點。而當你將這些成對資訊置入Map 時，重覆的內
容會被自動略去。
以下便是預先定義好的資料集，其中含有各個國家的名稱和其首都。此份
資料以較小字型顯示，以節省空間：
//: com:bruceeckel:util:CountryCapitals.java
package com.bruceeckel.util;
public class CountryCapitals {
public static final String[][] pairs = {
// Africa
{"ALGERIA","Algiers"}, {"ANGOLA","Luanda"},
{"BENIN","Porto-Novo"}, {"BOTSWANA","Gaberone"},
{"BURKINA FASO","Ouagadougou"}, {"BURUNDI","Bujumbura"},
{"CAMEROON","Yaounde"}, {"CAPE VERDE","Praia"},
{"CENTRAL AFRICAN REPUBLIC","Bangui"},
{"CHAD","N'djamena"}, {"COMOROS","Moroni"},
{"CONGO","Brazzaville"}, {"DJIBOUTI","Dijibouti"},
{"EGYPT","Cairo"}, {"EQUATORIAL GUINEA","Malabo"},
{"ERITREA","Asmara"}, {"ETHIOPIA","Addis Ababa"},
{"GABON","Libreville"}, {"THE GAMBIA","Banjul"},
{"GHANA","Accra"}, {"GUINEA","Conakry"},
{"GUINEA","-"}, {"BISSAU","Bissau"},
{"CETE D'IVOIR (IVORY COAST)","Yamoussoukro"},
{"KENYA","Nairobi"}, {"LESOTHO","Maseru"},
{"LIBERIA","Monrovia"}, {"LIBYA","Tripoli"},
Chapter 9: Holding Your Objects 447
{"MADAGASCAR","Antananarivo"}, {"MALAWI","Lilongwe"},
{"MALI","Bamako"}, {"MAURITANIA","Nouakchott"},
{"MAURITIUS","Port Louis"}, {"MOROCCO","Rabat"},
{"MOZAMBIQUE","Maputo"}, {"NAMIBIA","Windhoek"},
{"NIGER","Niamey"}, {"NIGERIA","Abuja"},
{"RWANDA","Kigali"}, {"SAO TOME E PRINCIPE","Sao Tome"},
{"SENEGAL","Dakar"}, {"SEYCHELLES","Victoria"},
{"SIERRA LEONE","Freetown"}, {"SOMALIA","Mogadishu"},
{"SOUTH AFRICA","Pretoria/Cape Town"}, {"SUDAN","Khartoum"},
{"SWAZILAND","Mbabane"}, {"TANZANIA","Dodoma"},
{"TOGO","Lome"}, {"TUNISIA","Tunis"},
{"UGANDA","Kampala"},
{"DEMOCRATIC REPUBLIC OF THE CONGO (ZAIRE)","Kinshasa"},
{"ZAMBIA","Lusaka"}, {"ZIMBABWE","Harare"},
// Asia
{"AFGHANISTAN","Kabul"}, {"BAHRAIN","Manama"},
{"BANGLADESH","Dhaka"}, {"BHUTAN","Thimphu"},
{"BRUNEI","Bandar Seri Begawan"}, {"CAMBODIA","Phnom Penh"},
{"CHINA","Beijing"}, {"CYPRUS","Nicosia"},
{"INDIA","New Delhi"}, {"INDONESIA","Jakarta"},
{"IRAN","Tehran"}, {"IRAQ","Baghdad"},
{"ISRAEL","Jerusalem"}, {"JAPAN","Tokyo"},
{"JORDAN","Amman"}, {"KUWAIT","Kuwait City"},
{"LAOS","Vientiane"}, {"LEBANON","Beirut"},
{"MALAYSIA","Kuala Lumpur"}, {"THE MALDIVES","Male"},
{"MONGOLIA","Ulan Bator"}, {"MYANMAR (BURMA)","Rangoon"},
{"NEPAL","Katmandu"}, {"NORTH KOREA","P'yongyang"},
{"OMAN","Muscat"}, {"PAKISTAN","Islamabad"},
{"PHILIPPINES","Manila"}, {"QATAR","Doha"},
{"SAUDI ARABIA","Riyadh"}, {"SINGAPORE","Singapore"},
{"SOUTH KOREA","Seoul"}, {"SRI LANKA","Colombo"},
{"SYRIA","Damascus"}, {"TAIWAN (REPUBLIC OF CHINA)","Taipei"},
{"THAILAND","Bangkok"}, {"TURKEY","Ankara"},
{"UNITED ARAB EMIRATES","Abu Dhabi"}, {"VIETNAM","Hanoi"},
{"YEMEN","Sana'a"},
// Australia and Oceania
{"AUSTRALIA","Canberra"}, {"FIJI","Suva"},
{"KIRIBATI","Bairiki"},
{"MARSHALL ISLANDS","Dalap-Uliga-Darrit"},
{"MICRONESIA","Palikir"}, {"NAURU","Yaren"},
{"NEW ZEALAND","Wellington"}, {"PALAU","Koror"},
{"PAPUA NEW GUINEA","Port Moresby"},
{"SOLOMON ISLANDS","Honaira"}, {"TONGA","Nuku'alofa"},
{"TUVALU","Fongafale"}, {"VANUATU","< Port-Vila"},
{"WESTERN SAMOA","Apia"},
// Eastern Europe and former USSR
{"ARMENIA","Yerevan"}, {"AZERBAIJAN","Baku"},
{"BELARUS (BYELORUSSIA)","Minsk"}, {"GEORGIA","Tbilisi"},
{"KAZAKSTAN","Almaty"}, {"KYRGYZSTAN","Alma-Ata"},
{"MOLDOVA","Chisinau"}, {"RUSSIA","Moscow"},
{"TAJIKISTAN","Dushanbe"}, {"TURKMENISTAN","Ashkabad"},
{"UKRAINE","Kyiv"}, {"UZBEKISTAN","Tashkent"},
448 Thinking in Java www.BruceEckel.com
// Europe
{"ALBANIA","Tirana"}, {"ANDORRA","Andorra la Vella"},
{"AUSTRIA","Vienna"}, {"BELGIUM","Brussels"},
{"BOSNIA","-"}, {"HERZEGOVINA","Sarajevo"},
{"CROATIA","Zagreb"}, {"CZECH REPUBLIC","Prague"},
{"DENMARK","Copenhagen"}, {"ESTONIA","Tallinn"},
{"FINLAND","Helsinki"}, {"FRANCE","Paris"},
{"GERMANY","Berlin"}, {"GREECE","Athens"},
{"HUNGARY","Budapest"}, {"ICELAND","Reykjavik"},
{"IRELAND","Dublin"}, {"ITALY","Rome"},
{"LATVIA","Riga"}, {"LIECHTENSTEIN","Vaduz"},
{"LITHUANIA","Vilnius"}, {"LUXEMBOURG","Luxembourg"},
{"MACEDONIA","Skopje"}, {"MALTA","Valletta"},
{"MONACO","Monaco"}, {"MONTENEGRO","Podgorica"},
{"THE NETHERLANDS","Amsterdam"}, {"NORWAY","Oslo"},
{"POLAND","Warsaw"}, {"PORTUGAL","Lisbon"},
{"ROMANIA","Bucharest"}, {"SAN MARINO","San Marino"},
{"SERBIA","Belgrade"}, {"SLOVAKIA","Bratislava"},
{"SLOVENIA","Ljujiana"}, {"SPAIN","Madrid"},
{"SWEDEN","Stockholm"}, {"SWITZERLAND","Berne"},
{"UNITED KINGDOM","London"}, {"VATICAN CITY","---"},
// North and Central America
{"ANTIGUA AND BARBUDA","Saint John's"}, {"BAHAMAS","Nassau"},
{"BARBADOS","Bridgetown"}, {"BELIZE","Belmopan"},
{"CANADA","Ottawa"}, {"COSTA RICA","San Jose"},
{"CUBA","Havana"}, {"DOMINICA","Roseau"},
{"DOMINICAN REPUBLIC","Santo Domingo"},
{"EL SALVADOR","San Salvador"}, {"GRENADA","Saint George's"},
{"GUATEMALA","Guatemala City"}, {"HAITI","Port-au-Prince"},
{"HONDURAS","Tegucigalpa"}, {"JAMAICA","Kingston"},
{"MEXICO","Mexico City"}, {"NICARAGUA","Managua"},
{"PANAMA","Panama City"}, {"ST. KITTS","-"},
{"NEVIS","Basseterre"}, {"ST. LUCIA","Castries"},
{"ST. VINCENT AND THE GRENADINES","Kingstown"},
{"UNITED STATES OF AMERICA","Washington, D.C."},
// South America
{"ARGENTINA","Buenos Aires"},
{"BOLIVIA","Sucre (legal)/La Paz(administrative)"},
{"BRAZIL","Brasilia"}, {"CHILE","Santiago"},
{"COLOMBIA","Bogota"}, {"ECUADOR","Quito"},
{"GUYANA","Georgetown"}, {"PARAGUAY","Asuncion"},
{"PERU","Lima"}, {"SURINAME","Paramaribo"},
{"TRINIDAD AND TOBAGO","Port of Spain"},
{"URUGUAY","Montevideo"}, {"VENEZUELA","Caracas"},
};
} ///:~
Chapter 9: Holding Your Objects 449
這些都只不過是二維的String array5。下面是個簡單測試程式，示範如何
使用fill() 和自動產生器：
//: c09:FillTest.java
import com.bruceeckel.util.*;
import java.util.*;
public class FillTest {
static Generator sg =
new Arrays2.RandStringGenerator(7);
public static void main(String[] args) {
List list = new ArrayList();
Collections2.fill(list, sg, 25);
System.out.println(list + "\n");
List list2 = new ArrayList();
Collections2.fill(list2,
Collections2.capitals, 25);
System.out.println(list2 + "\n");
Set set = new HashSet();
Collections2.fill(set, sg, 25);
System.out.println(set + "\n");
Map m = new HashMap();
Collections2.fill(m, Collections2.rsp, 25);
System.out.println(m + "\n");
Map m2 = new HashMap();
Collections2.fill(m2,
Collections2.geography, 25);
System.out.println(m2);
}
} ///:~
有了上述工具，你可以將各種有趣資料填入各個容器內，藉以輕鬆測試不
同的容器。
5 這些資料是在Internet 上找到，再以Python 程式(請參考www.Python.org)加以處
理。
450 Thinking in Java www.BruceEckel.com
容器的缺點：元素型別未定
Java 容器的缺點是，一旦你將物件置於容器內，你便損失了他的型別資
訊。這是因為當初撰寫容器類別的那些人，並不知道你置於容器內的元素
型別可能為何，而且讓容器僅僅儲存某種特定型別，會使容器無法成為通
用工具。容器所持有的其實是一個個reference 指向Object(Object 是所
有Java classes 的根源)，進而才能儲存任意型別。當然這不包括基本型
別，因為基本型別並不繼承自任何classes。這是很棒的解決方法，但是：
1. 由於你將object reference 置入容器時已捨棄(割除)型別資訊，所
以容器對於其所容納的元素的型別，沒有任何限制。這麼說好了，
即使你只打算讓你的容器儲存「貓」，其他人仍然可以輕易將
「狗」置入這個容器內。
2. 由於型別資訊已失，所以容器唯一知道的事情就是，它所持有的乃
是指向物件的一些references。使用之前你必須先將元素轉為正確型
別。
往好的一面說，Java 並不至於讓你誤用容器內的物件。如果你將「狗」置
於「貓」容器內，然後企圖將容器內的所有事物都視為「貓」，那麼當你
將「狗」(的reference)自「貓」容器取出並試著將它轉型為「貓」時，
便會得到執行期異常。
下面這個例子使用最基本、最常被使用的容器：ArrayList。初學者可以
將ArrayList 想像成一種「會自動擴增容量的array」。ArrayList 的使
用方式十分簡單：產生ArrayList、利用add() 將物件置入、利用get()
配合索引值將它們取出。這一切就和array 的使用方式完全相同，只不過
少了中括號罷了6。
ArrayList 還有一個size()，讓你得以知道目前的元素個數，如此一來你
才不會不慎超過邊界而引發異常。
6 此處如果有運算子重載(operator overloading)的功能就太好了(譯註：C++有)。
Chapter 9: Holding Your Objects 451
現在，首先，我們設計Cat class 和Dog class：
//: c09:Cat.java
public class Cat {
private int catNumber;
Cat(int i) { catNumber = i; }
void print() {
System.out.println("Cat #" + catNumber);
}
} ///:~
//: c09:Dog.java
public class Dog {
private int dogNumber;
Dog(int i) { dogNumber = i; }
void print() {
System.out.println("Dog #" + dogNumber);
}
} ///:~
將Cats 和Dogs 置入容器內，然後再將它們取出：
//: c09:CatsAndDogs.java
// Simple container example.
import java.util.*;
public class CatsAndDogs {
public static void main(String[] args) {
ArrayList cats = new ArrayList();
for(int i = 0; i < 7; i++)
cats.add(new Cat(i));
// Not a problem to add a dog to cats:
cats.add(new Dog(7));
for(int i = 0; i < cats.size(); i++)
((Cat)cats.get(i)).print();
// Dog is detected only at run-time
}
} ///:~
Cat 和Dog 並不相同，它們除了都是Objects 之外(如果你未曾明確指出
你所繼承的class，便會自動繼承Object)，沒有其他任何共通特性。由
452 Thinking in Java www.BruceEckel.com
於ArrayList 所持有的乃是Objects，所以你不但可以使用ArrayList
的add() 將Cat 物件置於這個容器內，也可以將Dog 物件加入，不會發
生編譯期錯誤乃至執行期錯誤。當你使用ArrayList 的get() 將「你以為
是Cat 物件」的東西取出時，你取得的是一個object reference，它必須先
被轉型為Cat 才能使用。於是你得使用圓括號將整個算式括住，強迫轉型
動作先於Cat print() 之前發生，否則便會發生語法錯誤。而當你試著將
Dog 物件轉型為Cat 時，你會收到一個執行期異常(exception)。
這可不只是個煩惱而已。這種情況可能產生難以查覺的程式臭蟲。如果程
式某處(或多處)將物件置入容器，你會發現，只要程式某處收到一個異
常而它代表「有個不正確的物件被置於容器內」，你就得找出究竟何處進
行了這樣的錯誤置入動作。不過，就好的一面來說，能夠擁有標準程式庫
來協助編程，畢竟是很方便的，姑且不論其中可能的不足和拙劣。
譯註：Java Spec. Request(JSR，Java 規格需求)第014 號，要求Java
容納泛型機制。下筆此刻最新的JDK1.4 已採用"Generic Java" 技術，成了
名副其實的「泛型爪哇」，允許程式員在運用Java 容器時，指定元素型
別。語法非常近似於C++，唯底層實作技術完全不同。
有時候它總是可以運作
事實上，某些情況下，即便沒有轉型至原先的型別，仍然可以運作無誤。
有一種情況尤其特別：編譯器對String class 提供了一些額外支援，使它
可以平滑運作。當編譯器預期收到String object 而卻沒有收到時，它會自
動呼叫toString() 函式，後者定義於Object 之中，可被任何Java
classes 覆寫。這個toString() 能夠產生編譯器想要的String object 並被
用於必要地點。
因此，如果想列印你自己的class objects，只要覆寫其toString() 函式即
可，例如：
//: c09:Mouse.java
// Overriding toString().
public class Mouse {
private int mouseNumber;
Mouse(int i) { mouseNumber = i; }
// Override Object.toString():
Chapter 9: Holding Your Objects 453
public String toString() {
return "This is Mouse #" + mouseNumber;
}
public int getNumber() {
return mouseNumber;
}
} ///:~
//: c09:WorksAnyway.java
// In special cases, things just
// seem to work correctly.
import java.util.*;
class MouseTrap {
static void caughtYa(Object m) {
Mouse mouse = (Mouse)m; // Cast from Object
System.out.println("Mouse: " +
mouse.getNumber());
}
}
public class WorksAnyway {
public static void main(String[] args) {
ArrayList mice = new ArrayList();
for(int i = 0; i < 3; i++)
mice.add(new Mouse(i));
for(int i = 0; i < mice.size(); i++) {
// No cast necessary, automatic
// call to Object.toString():
System.out.println(
"Free mouse: " + mice.get(i));
MouseTrap.caughtYa(mice.get(i));
}
}
} ///:~
你可以看到Mouse 之內覆寫了toString()。在main() 的第二個for 迴
圈裡，你可以看到這行述句：
System.out.println("Free mouse: " + mice.get(i));
454 Thinking in Java www.BruceEckel.com
在'+' 符號之後，編譯器預期見到一個String，但get() 回傳的是一個
Object。為了得到所需的String，編譯器會自動呼叫toString()。不幸
的是這種神奇效果只發生在String 身上；其他型別無福享受。
第二種作法是將轉型動作隱藏於MouseTrap 內。你看，caughtYa() 接
收的並非是個Mouse 而是一個Object，之後才將Object 轉型為
Mouse。這種作法很魯莽，因為接收的是Object，所以任何東西都可被
傳進來。不過，萬一轉型動作失敗(假設你傳入的型別錯誤的話)便會在
執行期發生異常。這雖然不比執行期的檢查好，但仍然足夠穩當。請注
意，使用以下函式時：
MouseTrap.caughtYa(mice.get(i));
並不需要進行任何轉型動作。
製作一個具有型別意識(type-conscious)的
ArrayList
你可能不想就此放棄前述議題。更嚴謹的解決方法就是根據ArrayList
撰寫新的class，使後者能夠只接收你所指定的型別，並且只回傳該型別：
//: c09:MouseList.java
// A type-conscious ArrayList.
import java.util.*;
public class MouseList {
private ArrayList list = new ArrayList();
public void add(Mouse m) {
list.add(m);
}
public Mouse get(int index) {
return (Mouse)list.get(index);
}
public int size() { return list.size(); }
} ///:~
以下便是這個新容器的測試：
//: c09:MouseListTest.java
Chapter 9: Holding Your Objects 455
public class MouseListTest {
public static void main(String[] args) {
MouseList mice = new MouseList();
for(int i = 0; i < 3; i++)
mice.add(new Mouse(i));
for(int i = 0; i < mice.size(); i++)
MouseTrap.caughtYa(mice.get(i));
}
} ///:~
它和前一個例子十分相像，只不過新的MouseList class 擁有一個型別為
ArrayList 的private 成員，至於函式則和ArrayList 一模一樣。但它
並不接收、也不回傳泛化的Objects，而是回傳Mouse 物件。
請注意，如果MouseList 改採「繼承ArrayList 」的方式， 那麼
add(Mouse) 就只會重載既有的add(Object)，而不會對「被加入的物
件」的型別進行限制。於是MouseList 變成ArrayList 的一個代理人
(surrogate)，在轉遞工作之前先執行一些動作(請參考《Thinking in
Patterns with Java》，可自www.BruceEckel.com 下載)。
由於MouseList 只接受Mouse，所以如果程式寫成：
mice.add(new Pigeon());
你會在編譯期獲得錯誤訊息。這種方法雖然從撰碼觀點來看比較麻煩，但
是當你使用了不正確的型別時，能夠立即回報。
請注意，使用get() 時不需要任何轉型動作，因為獲得的永遠是Mouse。
參數化型別(parameterized types)
這類問題並不罕見：許多情況下你得依據其他型別來產生新型別；如果能
在編譯期擁有特定的型別資訊，將會非常有用。此即所謂「參數化型別」
(parameterized type)觀念。C++程式語言以所謂templates(模版)
對此直接提供支援。Java 未來版本有可能支援某種參數化型別；目前居於
領先地位的某些技術團隊，已有能力自動產生類似MouseList 之類的
classes。(譯註：目前JDK1.4+JSR14 已能支援「參數化型別」)
456 Thinking in Java www.BruceEckel.com
迭代器(Iterators)
任何容器類別都必須提供某種「物件置入方式」和「物件取出方式」。畢
竟容器的主要職責所在便是：儲存(持有)物件。在ArrayList 中，
add() 是插入物件的方式，get() 是取出物件的方式。ArrayList 極具彈
性，你可以在任意時間選擇任何一個物件，並且可以一次使用多個不同的
索引來選擇多個元素。
但是如果你開始想以較高層次的方式來思考，便會發現一個缺點：你得知
道容器的確切類型為何，才能加以運用。一開始這可能不是壞事，但如果
你一開始採用ArrayList，後來發現改用LinkedList 做為容器更具效
率，那麼又該如何？或者假設你想要撰寫一段泛型(generic)程式碼，這
段程式碼不知道也不在意它所使用的容器類型究竟為何，如此一來它就可
被用於不同類型的容器身上，不需要每次重新撰寫一份。
所謂「迭代器(iterator)」，可被用來達成這種概念。迭代器是個物件，
其職責便是走訪以及選擇序列(sequence)中的一連串物件。客端程式員
不需要知道或在意該序列的底層究竟如何實作。此外迭代器是所謂的「輕
量級」物件：產生的代價極小。基於這個理由，你常會發現它有一些看似
奇怪的限制，例如某些迭代器只能單向移動。
Java Iterator 便是這樣一個例子，它也具有某種限制。你沒有辦法對它做
太多事情，不過你可以：
1. 呼叫iterator()，要求容器交給你一個Iterator。當你第一次呼叫
Iterator 的next() 時，它將會回傳序列中的第一個元素。
2. 呼叫next() 取得序列中的下一個元素。
3. 呼叫hasNext() 檢查序列中是否還有其他元素。
4. 呼叫remove() 移去迭代器最新(最近)傳回的元素。
Chapter 9: Holding Your Objects 457
就這樣。它是一份簡單的實作品，但極具威力(對Lists 來說，還有一個
更複雜的ListIterator)。為了觀察其運作方式，讓我們重新探討本章先
前的CatsAndDogs.java 程式。在原先版本中，get() 被用來選擇序列內
的元素，以下新版則採用了Iterator：
//: c09:CatsAndDogs2.java
// Simple container with Iterator.
import java.util.*;
public class CatsAndDogs2 {
public static void main(String[] args) {
ArrayList cats = new ArrayList();
for(int i = 0; i < 7; i++)
cats.add(new Cat(i));
Iterator e = cats.iterator();
while(e.hasNext())
((Cat)e.next()).print();
}
} ///:~
你會發現，最後幾行如今改以Iterator 走訪序列內容，而不再使用for 迴
圈。有了Iterator，你不再需要關心容器內實際有多少個元素，是的，
hasNext() 和next() 會為你處理這個問題。
下面是另一個例子，假設我們要撰寫一個通用性的列印函式：
//: c09:HamsterMaze.java
// Using an Iterator.
import java.util.*;
class Hamster {
private int hamsterNumber;
Hamster(int i) { hamsterNumber = i; }
public String toString() {
return "This is Hamster #" + hamsterNumber;
}
}
458 Thinking in Java www.BruceEckel.com
class Printer {
static void printAll(Iterator e) {
while(e.hasNext())
System.out.println(e.next());
}
}
public class HamsterMaze {
public static void main(String[] args) {
ArrayList v = new ArrayList();
for(int i = 0; i < 3; i++)
v.add(new Hamster(i));
Printer.printAll(v.iterator());
}
} ///:~
仔細觀察printAll()，請注意，其中並沒有任何和序列類型有關的資訊。
你的手上只有Iterator，面對序列你也只要知道這個Iterator 就好了：
你可以透過它取得下一個物件，你可以知道是否已經到達序列尾端。以這
種方式對待容器，「在其上進行走訪，藉以在每個元素身上執行某個動
作」的想法，相當具有威力，而且在本書中到處可見。
上述這個例子甚至更為一般化，因為它會暗自使用Object.toString()。
是的，println() 被重載以適用Object 和任何基本型別，而在每一種情形
下，String 都會被自動產生- 由於呼叫了合適的toString() 之故。
雖然沒有必要，但你也可以手動完成轉型，效果和呼叫toString() 相同：
System.out.println((String)e.next());
一般而言，你會想要進行一些動作，而不只是呼叫Object 函式而已。所
以你還是會碰到型別轉換的問題。你得假設你已經取得某個特定型別的序
列的Iterator，並將你所獲得的物件轉型至該型別。如果轉型錯誤，會收
到執行期異常。
Chapter 9: Holding Your Objects 459
非預期的遞迴(Unintended recursion)
由於Java 標準容器都繼承自Object(和其他所有classes 一樣)，所以它
們也具備了toString()。這個函式可被覆寫以產生自定的String 表示
式。在這個String 表示式中， 可含括其所持有的物件。例如在
ArrayList 中，其toString() 會走訪ArrayList 的每一個元素並呼叫其
toString()。假設你想要印出你的class 的位址，只要參考this 就好了
(C++程式員更會傾向於這個方法)：
//: c09:InfiniteRecursion.java
// Accidental recursion.
import java.util.*;
public class InfiniteRecursion {
public String toString() {
return " InfiniteRecursion address: "
+ this + "\n";
}
public static void main(String[] args) {
ArrayList v = new ArrayList();
for(int i = 0; i < 10; i++)
v.add(new InfiniteRecursion());
System.out.println(v);
}
} ///:~
但如果你只是產生一個InfiniteRecursion 物件，然後列印它，你會收到
無止盡的一連串異常回報。如果你將InfiniteRecursion 物件置於
ArrayList 中，並印出該ArrayList，也會發生同樣的問題。問題出在哪
裡？在於Strings 的自動型別轉換。當你寫下這樣的程式：
"InfiniteRecursion address: " + this
編譯器看到String 之後緊跟著一個'+' 號，而後緊接著一個non-
String，編譯器便試著將this 轉換為String。它會呼叫toString() 來進
行轉換，而這個動作會引發遞迴呼叫。
如果你想在這個例子中印出物件的位址，解決方法就是呼叫Object 的
toString()。是的，就是如此。
460 Thinking in Java www.BruceEckel.com
所以，請不要使用this，請改用super.toString()。注意，只有當你直
接繼承Object 或你的parent classes 都不曾覆寫toString() 時，這個作
法才管用。
容器分類學(Container taxonomy)
視程式編寫時的需要，Collections 和Maps 可被各種不同的方式實作出
來。以下這張Java 2 容器分類圖對於你的認知應該很有幫助：
Iterator Collection Map
Produces
ListIterator
SortedMap
Produces
List Set
Produces
AbstractMap
AbstractCollection
AbstractSet AbstractList
SortedSet
HashMap TreeMap
Hashtable
(Legacy)
HashSet TreeSet
WeakHashMap
ArrayList AbstractSequentialList Vector
(Legacy)
Stack
(Legacy)
LinkedList
Collections
Arrays
Utilities
Comparable Comparator
乍見之下此圖可能令人不知所措。但你必然還是會發現到，實際上只有三
種容器組件：Map、List、Set。而且每一種只有2~3 個實作物。一旦你
了解這一點，這些容器就不會那麼令人望而怯步了。
Chapter 9: Holding Your Objects 461
短虛線方塊代表interfaces，長虛線方塊代表abstract classes，實線方
塊則是一般(具象)的classes。虛線箭頭表示「實作出某個interface」
的class，或代表「僅部份實作出某interface」的某個abstract class。
實線箭頭表示某個class 可產生「箭頭所指的那個class」的物件，例如所
有Collection 都可以產生Iterator，而List 可以產生ListIterator
(也可以產生一般的Iterator，因為List 繼承自Collection)。
和「物件持有」相關的interfaces 包括Collection、List、Set、Map。
理想情況下你所撰寫的程式大多只會和這些interfaces 溝通，而且只有在
產生它們的時候才會指定確切類型。所以你可以透過下列方式產生List：
List x = new LinkedList();
當然，你也可以令x 為一個LinkedList(而不是一個泛化的List)，並
讓x 帶有明確的型別資訊。使用interface 的美好之處在於，如果你想要
改用另一種實作物，只要在產生物件的地點加以改變即可，像這樣：
List x = new ArrayList();
程式碼的其餘部份仍然可以維持不變(這種泛型性質的某一部份可由迭代
器達成目的)。
在類別階層架構中，你會發現有些classes 的名稱以"Abstract" 為首。乍
看之下它們令人困惑。事實上它們只是一些簡單工具，局部實作出某個
interface 罷了。例如，假設你想要製作自己的Set，你可能不會從Set 下
手實作出所有函式，你可能會繼承AbstractSet，因而得以花費最小力氣
來製作新class。不過Java 容器庫提供的功能基本上可以滿足你的所有需
求。所以，以我所設定的目標而言，你可以省略所有以"Abstract" 為首的
classes。
因此，當你觀察這張分類圖時，只要關心最頂端的interfaces，以及所有
concrete classes(實線方塊)即可。通常你會產生那些concrete class 物
件，並將它向上轉型至相應的interface，然後在程式碼的其他地方使用
那個interface。此外，撰寫新碼時你無需考慮舊有的元素。因此容器分
類圖可被大幅簡化為：
462 Thinking in Java www.BruceEckel.com
Iterator Collection Map
ListIterator
List Set Produces
HashMap TreeMap
HashSet TreeSet
WeakHashMap
ArrayList LinkedList
Produces Produces
Collections
Arrays
Utilities
Comparable Comparator
請注意，這張分類圖只含括一般用途會用到的interfaces 和classes，以及
本章關注的元素。
下面便是一個實例， 將String 物件填入Collection ( 此處為
ArrayList)之中，然後印出每個元素：
//: c09:SimpleCollection.java
// A simple example using Java 2 Collections.
import java.util.*;
public class SimpleCollection {
public static void main(String[] args) {
// Upcast because we just want to
// work with Collection features
Collection c = new ArrayList();
for(int i = 0; i < 10; i++)
c.add(Integer.toString(i));
Iterator it = c.iterator();
while(it.hasNext())
System.out.println(it.next());
}
} ///:~
Chapter 9: Holding Your Objects 463
main() 第一行產生一個ArrayList 物件，並向上轉型至Collection。由
於這個例子只使用Collection 的成員，所以繼承自Collection 的任何
class 的物件都可有效運作。不過最常被用到的一種Collection 還是
ArrayList。
add() 一如其名，會將新元素置入Collection。然而說明文件中很謹慎地
說了：add()「保證容器一定含入被指定的元素」。這其實說的是Set，因
為Set 只有在元素不重複的情況下才會加入新元素。使用ArrayList 或其
他類型的List 時，add() 一律意味「將元素置入」，因為Lists 並不在乎
元素是否重複。
所有Collections 都會透過其iterator() 產生一個Iterator。上述例子
會產生一個Iterator 並以之走訪Collection，印出每一個元素。
Collection 的機能
下表顯示你能夠對Collection 做的所有動作(不包括因繼承Object 而自
動具備的函式)。因此Set 和List 也都具備了同樣的功能(List 還具備
其他功能)。Map 並不繼承自Collection，所以應該被個別看待。
boolean add(Object) 確保容器將持有「引數所代表的物
件」。如果它沒能將引數加入，就回
傳false。(這是個可有可無的函
式，本章稍後解釋)
boolean
addAll(Collection)
將引數中的所有元素都加入容器內。
只要加入了任一元素，就回傳true
(也是可有可無的，"optional")
void clear( ) 移除(remove)容器內的所有元素。
(可有可無的，"optional")
boolean
contains(Object)
如果容器內含引數所代表的物件，就
回傳true。
boolean
containsAll(Collection)
如果容器內含引數所含的所有元素，
就回傳true。
464 Thinking in Java www.BruceEckel.com
boolean isEmpty( ) 如果容器內未含任何元素，回傳
true。
Iterator iterator( ) 回傳一個Iterator，你可以使用這個
Iterator 來走訪容器。
boolean
remove(Object)
如果引數值位於容器內，便移除該元
素(的其中之一)。如果確實發生移
除動作，回傳true。(可有可無的，
"optional")
boolean
removeAll(Collection)
移除引數容器中的所有元素。如果發
生移除動作，就回傳true。(可有可
無的，"optional")
boolean
retainAll(Collection)
只保留引數容器內的元素- 採用集合
理論中的intersection(交集)。如果
確實發生更動，回傳true。(可有可
無的，"optional")
int size( ) 回傳容器中的元素個數。
Object[] toArray( ) 回傳一個array，內含容器的所有元
素。
Object[]
toArray(Object[] a)
回傳一個array，內含容器的所有元
素。array 的元素型別和引數a 的元
素型別相同，非單純之Object(你
得自行將array 轉為正確型別)。
請注意，這裡並未提供隨機存取所需的get() 函式，因為Collection 涵蓋
Set，而Set 會維護它自己的內部排列(這就使得隨機存取不具意義)。
因此如果你想檢視Collection 內的所有元素，得使用迭代器才行；這也是
唯一可用來取回元素的方法。
以下示範上述所有函式。再次我要說，這些函式都可作用於繼承自
Collection 的所有classes 身上，而ArrayList 則被用來做為一種「最小
公約數」：
//: c09:Collection1.java
// Things you can do with all Collections.
Chapter 9: Holding Your Objects 465
import java.util.*;
import com.bruceeckel.util.*;
public class Collection1 {
public static void main(String[] args) {
Collection c = new ArrayList();
Collections2.fill(c,
Collections2.countries, 10);
c.add("ten");
c.add("eleven");
System.out.println(c);
// Make an array from the List:
Object[] array = c.toArray();
// Make a String array from the List:
String[] str =
(String[])c.toArray(new String[1]);
// Find max and min elements; this means
// different things depending on the way
// the Comparable interface is implemented:
System.out.println("Collections.max(c) = " +
Collections.max(c));
System.out.println("Collections.min(c) = " +
Collections.min(c));
// Add a Collection to another Collection
Collection c2 = new ArrayList();
Collections2.fill(c2,
Collections2.countries, 10);
c.addAll(c2);
System.out.println(c);
c.remove(CountryCapitals.pairs[0][0]);
System.out.println(c);
c.remove(CountryCapitals.pairs[1][0]);
System.out.println(c);
// Remove all components that are in the
// argument collection:
c.removeAll(c2);
System.out.println(c);
c.addAll(c2);
System.out.println(c);
// Is an element in this Collection?
String val = CountryCapitals.pairs[3][0];
466 Thinking in Java www.BruceEckel.com
System.out.println(
"c.contains(" + val + ") = "
+ c.contains(val));
// Is a Collection in this Collection?
System.out.println(
"c.containsAll(c2) = "+ c.containsAll(c2));
Collection c3 = ((List)c).subList(3, 5);
// Keep all the elements that are in both
// c2 and c3 (an intersection of sets):
c2.retainAll(c3);
System.out.println(c);
// Throw away all the elements
// in c2 that also appear in c3:
c2.removeAll(c3);
System.out.println("c.isEmpty() = " +
c.isEmpty());
c = new ArrayList();
Collections2.fill(c,
Collections2.countries, 10);
System.out.println(c);
c.clear(); // Remove all elements
System.out.println("after c.clear():");
System.out.println(c);
}
} ///:~
這個程式產生一些ArrayLists 來儲存不同組的資料，並將它向上轉型至
Collection 物件。所以很明顯，除了Collection interface 之外不會用到
其他東西。main() 只是以簡單的練習來測試Collection 中的所有函式。
以下數節說明List、Set、Map 的各式各樣實作，並指出哪一種是你的預
設選擇(表格中帶有星號者)。請注意，老舊的(Java2 以前的)classes
如Vector、Stack、Hashtable 都未在此處討論，因為任何情況下你最
好還是使用Java 2 容器。
Chapter 9: Holding Your Objects 467
List 的機能
基本的List 極易使用，就和你目前所見的ArrayList 使用方式一樣。雖
然大多數時候你大概只會以add() 置入元素，以get() 一次取出一個元
素、以iterator() 獲得一個指向序列的Iterator，但還有一組函式可能派
上用場。
此外，實際上有兩類List：功能一般的ArrayList，優點在於可隨機存取
其中元素；功能較強的LinkedList(並非為了快速隨機存取而設計，具
備一組更通用的函式)。
List
(interface)
次序(order)是List 最重要的特性；它保證以
某種特定次序來維護元素。List 為Collection
加入了一些函式，使它得以在List 內進行安插
和移除動作(建議你只在LinkedList 上這麼
做)。List 會產生ListIterator，透過它你可
以從兩個方向來對List 進行走訪，也可以在
List 之內進行元素的安插和移除。
ArrayList* 以array 實作完成的List。允許快速隨機存取，
但是當元素的安插或移除發生於List 中央位置
時，效率便很差。面對ArrayList，你應該只
拿ListIterator 來進行向後或向前走訪動作，
而不應該拿它來進行元素安插和移除動作，因為
後者所花的代價遠較LinkedList 高昂。
LinkedList 提供最佳循序存取，以及成本低廉的「List 中
央位置元素安插和移除」。隨機存取動作則相對
緩慢(如果想進行隨機存取，請改用
ArrayList)。它還具備addFirst()、
addLast()、getFirst()、getLast()、
removeFirst()、removeLast()(這些函式
並未定義於任何一個interface 或base classes
中)，使其可被拿來當做stack、queue、或
deque。
下例中的每個函式都涵蓋了不同類型的動作，包括：所有List 都可執行的
動作(basicTest())、透過Iterator 走訪(iterMotion())、透過
468 Thinking in Java www.BruceEckel.com
Iterator 更動( iterManipulation() ) 、觀察List 更動後的結果
(testVisual())、以及僅可用於LinkedLists 的一些操作。
//: c09:List1.java
// Things you can do with Lists.
import java.util.*;
import com.bruceeckel.util.*;
public class List1 {
public static List fill(List a) {
Collections2.countries.reset();
Collections2.fill(a,
Collections2.countries, 10);
return a;
}
static boolean b;
static Object o;
static int i;
static Iterator it;
static ListIterator lit;
public static void basicTest(List a) {
a.add(1, "x"); // Add at location 1
a.add("x"); // Add at end
// Add a collection:
a.addAll(fill(new ArrayList()));
// Add a collection starting at location 3:
a.addAll(3, fill(new ArrayList()));
b = a.contains("1"); // Is it in there?
// Is the entire collection in there?
b = a.containsAll(fill(new ArrayList()));
// Lists allow random access, which is cheap
// for ArrayList, expensive for LinkedList:
o = a.get(1); // Get object at location 1
i = a.indexOf("1"); // Tell index of object
b = a.isEmpty(); // Any elements inside?
it = a.iterator(); // Ordinary Iterator
lit = a.listIterator(); // ListIterator
lit = a.listIterator(3); // Start at loc 3
i = a.lastIndexOf("1"); // Last match
a.remove(1); // Remove location 1
Chapter 9: Holding Your Objects 469
a.remove("3"); // Remove this object
a.set(1, "y"); // Set location 1 to "y"
// Keep everything that's in the argument
// (the intersection of the two sets):
a.retainAll(fill(new ArrayList()));
// Remove everything that's in the argument:
a.removeAll(fill(new ArrayList()));
i = a.size(); // How big is it?
a.clear(); // Remove all elements
}
public static void iterMotion(List a) {
ListIterator it = a.listIterator();
b = it.hasNext();
b = it.hasPrevious();
o = it.next();
i = it.nextIndex();
o = it.previous();
i = it.previousIndex();
}
public static void iterManipulation(List a) {
ListIterator it = a.listIterator();
it.add("47");
// Must move to an element after add():
it.next();
// Remove the element that was just produced:
it.remove();
// Must move to an element after remove():
it.next();
// Change the element that was just produced:
it.set("47");
}
public static void testVisual(List a) {
System.out.println(a);
List b = new ArrayList();
fill(b);
System.out.print("b = ");
System.out.println(b);
a.addAll(b);
a.addAll(fill(new ArrayList()));
System.out.println(a);
// Insert, remove, and replace elements
470 Thinking in Java www.BruceEckel.com
// using a ListIterator:
ListIterator x = a.listIterator(a.size()/2);
x.add("one");
System.out.println(a);
System.out.println(x.next());
x.remove();
System.out.println(x.next());
x.set("47");
System.out.println(a);
// Traverse the list backwards:
x = a.listIterator(a.size());
while(x.hasPrevious())
System.out.print(x.previous() + " ");
System.out.println();
System.out.println("testVisual finished");
}
// There are some things that only
// LinkedLists can do:
public static void testLinkedList() {
LinkedList ll = new LinkedList();
fill(ll);
System.out.println(ll);
// Treat it like a stack, pushing:
ll.addFirst("one");
ll.addFirst("two");
System.out.println(ll);
// Like "peeking" at the top of a stack:
System.out.println(ll.getFirst());
// Like popping a stack:
System.out.println(ll.removeFirst());
System.out.println(ll.removeFirst());
// Treat it like a queue, pulling elements
// off the tail end:
System.out.println(ll.removeLast());
// With the above operations, it's a dequeue!
System.out.println(ll);
}
public static void main(String[] args) {
// Make and fill a new list each time:
basicTest(fill(new LinkedList()));
basicTest(fill(new ArrayList()));
Chapter 9: Holding Your Objects 471
iterMotion(fill(new LinkedList()));
iterMotion(fill(new ArrayList()));
iterManipulation(fill(new LinkedList()));
iterManipulation(fill(new ArrayList()));
testVisual(fill(new LinkedList()));
testLinkedList();
}
} ///:~
在basicTest() 和iterMotion() 中，所有呼叫動作只是用來示範正確的
語法；收到回傳值後並不使用之。某些情況下甚至不接收回傳值，因為通
常不用它。使用這些函式前，你應該檢閱java.sun.com 的線上文件，仔細
看看其使用方式。
根據LinkedList 製作一個stack
stack(堆疊)有時候被稱為一種「後進先出(last-in, first-out，LIFO)」
容器。也就是說，被你最後推入(push)stack 內元素，便是你從stack 最
先取出(pop)的元素。和Java 的所有其他容器一樣，你所推入和取出的
通通都是Objects，所以你必須對取出的物件進行轉型，除非你只想使用
Object 的功能。
LinkedList 擁有一些函式，可直接實作出stack，所以你可以直接運用
LinkedList 而無需重新設計一個stack class。不過這樣一個stack class
有時候能夠把事情說得更清楚一些，所以還是有其價值：
//: c09:StackL.java
// Making a stack from a LinkedList.
import java.util.*;
import com.bruceeckel.util.*;
public class StackL {
private LinkedList list = new LinkedList();
public void push(Object v) {
list.addFirst(v);
}
public Object top() { return list.getFirst(); }
public Object pop()
return list.removeFirst();
}
472 Thinking in Java www.BruceEckel.com
public static void main(String[] args) {
StackL stack = new StackL();
for(int i = 0; i < 10; i++)
stack.push(Collections2.countries.next());
System.out.println(stack.top());
System.out.println(stack.top());
System.out.println(stack.pop());
System.out.println(stack.pop());
System.out.println(stack.pop());
}
} ///:~
如果你只是需要stack 的行為，此處不需繼承，因為繼承會使產生出來的
class 具有「LinkedList 的其餘所有函式」。稍後你會看到，這正是Java
1.0 程式庫設計者在Stack 上所犯的嚴重錯誤。
根據LinkedList 製作一個queue
queue 是一種「先進先出(first-in, first-out，FIFO)」容器。也就是說，
你將物件於某端置入，於另一端取出。因此元素的置入次序恰恰就是其被
取出的次序。LinkedList 擁有一些函式可直接支援queue，你可以把它們
應用於Queue class 之中：
//: c09:Queue.java
// Making a queue from a LinkedList.
import java.util.*;
public class Queue {
private LinkedList list = new LinkedList();
public void put(Object v) { list.addFirst(v); }
public Object get()
return list.removeLast();
}
public boolean isEmpty()
return list.isEmpty();
}
public static void main(String[] args) {
Queue queue = new Queue();
for(int i = 0; i < 10; i++)
queue.put(Integer.toString(i));
Chapter 9: Holding Your Objects 473
while(!queue.isEmpty())
System.out.println(queue.get());
}
} ///:~
你也可以利用LinkedList 輕易製作出一個deque ( 雙邊開口的
queue)。它就像一個queue，只不過兩端都可置入和移除元素。
Set 的機能
Set 擁有和Collection 一模一樣的interfaces，所以它不像上述兩種
Lists 一樣地有額外機能。Set 就是一個Collection，只不過其行為不同
罷了(這是繼承和多型的理想運用方式：展現不同行為)。Set 拒絕持有
重複的元素實值(value)。如何制定所謂的元素「實值」，情況頗為複
雜，稍後你便會看到。
Set
(interface)
加至Set 內的每個元素都必須獨一無二，不與其他
元素重複；Set 不允許持有重複元素。每個元素都
必須定義equals() 以判斷所謂的獨一性。Set 具
有和Collection 一模一樣的interface。Set
interface 並不保證以任何特定次序來維護其元素。
HashSet* 一種把搜尋時間看得很重要的Sets。所有元素都
必須定義hashCode()。
TreeSet 底層結構為tree 的一種有序的(ordered)Set。
這麼一來你便可以自Set 中萃取出一個帶次序性的
序列(ordered sequence)。
以下程式並不示範Set 的所有機能，因為Set interface 和Collection 相
同，已在先前範例中練習過了。這個範例所示範的是Set 獨有的行為：
//: c09:Set1.java
// Things you can do with Sets.
import java.util.*;
import com.bruceeckel.util.*;
474 Thinking in Java www.BruceEckel.com
public class Set1 {
static Collections2.StringGenerator gen =
Collections2.countries;
public static void testVisual(Set a) {
Collections2.fill(a, gen.reset(), 10);
Collections2.fill(a, gen.reset(), 10);
Collections2.fill(a, gen.reset(), 10);
System.out.println(a); // No duplicates!
// Add another set to this one:
a.addAll(a);
a.add("one");
a.add("one");
a.add("one");
System.out.println(a);
// Look something up:
System.out.println("a.contains(\"one\"): " +
a.contains("one"));
}
public static void main(String[] args) {
System.out.println("HashSet");
testVisual(new HashSet());
System.out.println("TreeSet");
testVisual(new TreeSet());
}
} ///:~
這個程式接受重複元素值，但是當你列印Set 的內容，你會發現針對每一
個值，Set 僅接受一份。
當你執行這個程式，你會注意到，HashSet 所維護的次序和TreeSet 不
相同。這是因為兩者以不同的方式來儲存元素，使它們稍後還能找到該元
素。TreeSet 會讓各元素保持排序(sorted)狀態，HashSet 則使用極適
合快速搜尋的所謂hashing 函式。開發自己的型別(types)時請務必記
住， Set 需要某種方式以維護其元素次序， 這意味你必須實作
Comparable interface，並定義compareTo()。以下便是一例：
//: c09:Set2.java
// Putting your own type in a Set.
import java.util.*;
Chapter 9: Holding Your Objects 475
class MyType implements Comparable {
private int i;
public MyType(int n) { i = n; }
public boolean equals(Object o) {
return
(o instanceof MyType)
&& (i == ((MyType)o).i);
}
public int hashCode() { return i; }
public String toString() { return i + " "; }
public int compareTo(Object o) {
int i2 = ((MyType)o).i;
return (i2 < i ? -1 : (i2 == i ? 0 : 1));
}
}
public class Set2 {
public static Set fill(Set a, int size) {
for(int i = 0; i < size; i++)
a.add(new MyType(i));
return a;
}
public static void test(Set a) {
fill(a, 10);
fill(a, 10); // Try to add duplicates
fill(a, 10);
a.addAll(fill(new TreeSet(), 10));
System.out.println(a);
}
public static void main(String[] args) {
test(new HashSet());
test(new TreeSet());
}
} ///:~
本章稍後會介紹equals() 和hashCode() 的定義方式。使用HashSet
和TreeSet 時，你都得為你的class 定義equals()，但只有當你的class
將被置於HashSet 時，才一定得定義hashCode()(很有可能如此，因
為HashSet 往往是你選擇Set 實作對象時的第一選擇)。不過，為了保
476 Thinking in Java www.BruceEckel.com
持良好的程式設計風格， 當你覆寫equals() ， 你應該一併覆寫
hashCode()。本章稍後會完整探討這個過程。
請注意我並未在compareTo() 中使用簡單明瞭的型式：return i-i2。這
種寫法是常見的錯誤，因為只有當i 和i2 都是無正負號(unsigned，如
果Java 有關鍵字unsigned 的話)的ints，這種寫法才正確。面對Java
之中帶正負號的int 會出錯。原因是帶正負號的int，其容量不足以表示兩
個同型數值的相減結果。如果i 是個夠大的正整數，j 是個夠大的負整數，
那麼i-j 的結果便會造成溢位，並回傳負值，這便導致了錯誤。
SortedSet
如果你有一個SortedSet(TreeSet 是唯一一份實作)，將保證其中元素
處於排序狀態，並提供SortedSet interface 內規劃的以下函式：
Comparator comparator()：：：：產生一個「被這個Set 所使用」的
Comparator。或是回傳null，代表以自然方式排序。
Object first()：：：：產生最低元素(lowest element)。
Object last()：：：：產生最高元素(highest element)。
SortedSet subSet(fromElement, toElement)：：：：產生Set 子集，
範圍從fromElement(含)到toElement(不含)。
SortedSet headSet(toElement)：：：：產生Set 子集，其中元素皆小於
toElement。
SortedSet tailSet(fromElement)：：：：產生Set 子集，其中元素皆大
於或等於fromElement。
Map 的機能
ArrayList 讓你得以使用數字來選擇一大群物件中的某一個。所以就某種
意義來說，它將數字和物件產生關聯。如果你想要根據其他選擇條件，在
一連串物件中進行挑選，又該如何？stack 便是一例：它的選擇條件是「最
晚被推進stack 的那一個」。把「在序列中挑選」的概念發揮到極致的便
是所謂的map，或稱為dictionary(字典)、associative array(關聯式
Chapter 9: Holding Your Objects 477
陣列)。觀念上它就是一個ArrayList，但是並不以數字來搜尋元素，而
是以另一個物件來進行搜尋！這在程式中往往是一種重要過程。
上述觀念在Java 中以Map interface 落實。put(Object key, Object
value ) 會將value 加入，並將它關聯至key(這就是你將用以做為搜尋依
據的東西)。get(Object key) 會傳回key 所對應的value。你也可以使
用containsKey() 和containsValue() 來檢查Map 內是否含有某個
key 或某個value。
Java 標準程式庫有兩個不同類型的Maps：HashMap 和TreeMap。二
者具有相同的interface(因為它們都實作了Map)，但效率表現卻不相
同。如果你知道在執行get() 時必須進行哪些動作，你就會發現，「在
ArrayList 中搜尋key」這個動作的速度似乎不快。而這正是HashMap
提高速度的地方。它不會緩慢地逐一搜尋某個key，而會使用一種被稱為
「hash code(雜湊碼)」的特殊值。hash code 是一種「將物件內的某些
資訊轉換為幾乎獨一無二」的int，用以代表那個物件。所有Java 物件都
可以產生hash code，而且hashCode() 是根源類別Object 具備的函
式。HashMap 會運用物件的hashCode()，並利用它來快速找到key。
這種作法能夠帶來巨幅的效率提升7。
Map
(interface)
維護key-value 的關聯性，使你可以使用key
來搜尋value。
HashMap* 基於hash table(雜湊表)完成的一個實作品。
可用它來取代Hashtable(譯註：Java 2 之前
的一種容器)。可在常數時間內安插元素，或
找出一組key-value pair。透過其建構式，使用
者可調整效能表現，因為它允許你設定
capacity(容量)和load factor(負載因子)
7如果這樣的加速結果仍然無法符合你對效能的要求，你便應該撰寫自己的Map，並針對你
的特定型別進行訂製，以避免因轉型而造成的延遲，並藉以加速表格搜尋。為了達到更高效
能，你可以參考Donald Knuth 所著的《The Art of Computer Programming, Volume 3:
Sorting and Searching, Second Edition》，以array 來替換滿載的bucket lists(譯註：這
是hash table 中實際用來儲存元素的一種結構，請參考資料結構專書中對於hash table 的介
紹)。運用array 能夠獲得兩個好處：可針對磁碟空間的特性進行最佳化，並可省下「產生
個別資料」和「進行垃圾回收」的大部份時間。
478 Thinking in Java www.BruceEckel.com
TreeMap 基於紅黑樹(red-black tree)完成的一個實作
品。當你檢視其中的key 或key-value pairs
時，會以排序形式出現(前後次序由
Comparable 或Comparator 決定，稍後介
紹)。TreeMap 的特色便是讓你得以排序形
式得到結果。TreeMap 是唯一具有
subMap() 的一個Map，這個函式讓你得以回
傳tree 中的部份組成。
有時候，你也會需要知道hashing 動作的執行細節，稍後我會加以探討。
以下範例用到了Collection2.fill()，以及先前定義的測試資料集：
//: c09:Map1.java
// Things you can do with Maps.
import java.util.*;
import com.bruceeckel.util.*;
public class Map1 {
static Collections2.StringPairGenerator geo =
Collections2.geography;
static Collections2.RandStringPairGenerator
rsp = Collections2.rsp;
// Producing a Set of the keys:
public static void printKeys(Map m) {
System.out.print("Size = " + m.size() +", ");
System.out.print("Keys: ");
System.out.println(m.keySet());
}
// Producing a Collection of the values:
public static void printValues(Map m) {
System.out.print("Values: ");
System.out.println(m.values());
}
public static void test(Map m) {
Collections2.fill(m, geo, 25);
// Map has 'Set' behavior for keys:
Collections2.fill(m, geo.reset(), 25);
printKeys(m);
Chapter 9: Holding Your Objects 479
printValues(m);
System.out.println(m);
String key = CountryCapitals.pairs[4][0];
String value = CountryCapitals.pairs[4][1];
System.out.println("m.containsKey(\"" + key +
"\"): " + m.containsKey(key));
System.out.println("m.get(\"" + key + "\"): "
+ m.get(key));
System.out.println("m.containsValue(\""
+ value + "\"): " +
m.containsValue(value));
Map m2 = new TreeMap();
Collections2.fill(m2, rsp, 25);
m.putAll(m2);
printKeys(m);
key = m.keySet().iterator().next().toString();
System.out.println("First key in map: "+key);
m.remove(key);
printKeys(m);
m.clear();
System.out.println("m.isEmpty(): "
+ m.isEmpty());
Collections2.fill(m, geo.reset(), 25);
// Operations on the Set change the Map:
m.keySet().removeAll(m.keySet());
System.out.println("m.isEmpty(): "
+ m.isEmpty());
}
public static void main(String[] args) {
System.out.println("Testing HashMap");
test(new HashMap());
System.out.println("Testing TreeMap");
test(new TreeMap());
}
} ///:~
printKeys() 和printValues() 不單只是有用的公用函式，它們同時也示
範如何將Map 的內容生成一個Collection。keySet() 會將Map 內的
keys 生成一個Set。values() 的行為類似，會產生一個Collection，包
含Map 內的所有values。請注意，keys 肯定是獨一無二的，但values 卻
480 Thinking in Java www.BruceEckel.com
允許重複。由於這些Collections 的背後支撐是Map ， 所以對
Collection 所做的更動都會反映在相應的那個Map 中。
程式的其餘部份示範了Map 的每一種操作，並測試各種類型的Map。
為了示範HashMap 的使用方式， 請設想有個程式， 它想要檢查
Math.random() 所產生的隨機亂數是否夠亂。理想情況下它應該產生一
組完美的亂數分佈，為了檢驗此事，你得產生許多亂數，並且計算落在不
同區間內的亂數個數。HashMap 恰可解決這個問題，因為它能夠將物件
關聯至物件。本例之中，value 物件內含由Math.random() 產生的數
字，以及該數字的出現次數：
//: c09:Statistics.java
// Simple demonstration of HashMap.
import java.util.*;
class Counter
int i = 1;
public String toString()
return Integer.toString(i);
}
}
class Statistics {
public static void main(String[] args) {
HashMap hm = new HashMap();
for(int i = 0; i < 10000; i++) {
// Produce a number between 0 and 20:
Integer r =
new Integer((int)(Math.random() * 20));
if(hm.containsKey(r))
((Counter)hm.get(r)).i++;
else
hm.put(r, new Counter());
}
System.out.println(hm);
}
} ///:~
Chapter 9: Holding Your Objects 481
main() 之中每次產生一個亂數，就以Integer 物件加以包裝，這才使得
object reference 可被用於HashMap 中(是的，你無法將基本型別數值
置入容器內，只有object reference 才行)。containsKey() 會檢查key
是否已在容器之內(也就是說此數字是否已經產生過了)。如果已在容器
內，就使用get() 取出該key 相關聯的value - 本例是個Counter 物
件。Counter 物件內的i 值會被加一，代表該亂數值又被產生了一次。
如果未能找到key，就呼叫put()將新的key-value pair 置於HashMap
內。由於Counter 在新誕生的時候會自動將變數i 初始化為1，這便表示
該亂數值首次出現。
只要將HashMap 印出，便可顯示其中內容。HashMap 的toString()
會走訪容器內的所有key-value pairs，並呼叫它們的toString() 。
Integer.toString() 已經預先定義好了，另外你也看到了Counter 的
toString()。某次執行後的輸出結果如下(為了版面考量，我加了一些斷
行符號)：
{19=526, 18=533, 17=460, 16=513, 15=521, 14=495,
13=512, 12=483, 11=488, 10=487, 9=514, 8=523,
7=497, 6=487, 5=480, 4=489, 3=509, 2=503, 1=475,
0=505}
你可能會猜想class Counter 的必要性，看起來它似乎連外覆類別
Integer 的功能都不具備。為什麼不使用int 或Integer 呢？呃，你不能
使用int，因為所有容器都只能持有Object reference。對你來說，了解容
器的特性之後，外覆類別才會稍具意義，因為你無法將基本型別數值置入
容器內。不過，使用Java 的外覆類別時，你只能在初始化時設定其值，而
後讀取其值。換句話說你沒有辦法在產生外覆類別的物件之後改變其值。
這個特性使Integer 外覆類別立即被判出局，所以我們得撰寫新的class
來滿足我們的需求。
482 Thinking in Java www.BruceEckel.com
SortedMap
如果你採用SortedMap(TreeMap 是唯一可用的一份實作)，保證會
對元素的鍵值(keys)進行排序，因而允許SortedMap 提供一些額外機
能：
Comparator comparator()：：：：產生一個被此Map 所使用的
Comparator。或回傳null，表示將以自然方式進行排序。
Object firstKey()：：：：產生最低的(lowest)key。
Object lastKey()：：：：產生最高的(highest)key。
SortedMap subMap(fromKey, toKey): 產生此Map 的一個子
集，範圍從fromKey(含)到toKey(不含)。
SortedMap headMap(toKey)：：：：產生此Map 的一個子集，其內各
元素的key 皆小於toKey。
SortedMap tailMap(fromKey)：：：：產生此Map 的一個子集，其內
各元素的key 皆大於或等於fromKey。
Hashing 和hash codes
上個例子中，標準程式庫提供的一個class (Integer )被用來做為
HashMap 的key。這很適合，因為它具備所有必要性質，使它做為key
時可以運作正確。但是當你以自己撰寫的class 做為key 時，會碰上一個
HashMaps 的常見問題。舉個例子， 假設有個氣象預測系統， 以
Groundhog(土撥鼠)物件對Prediction(預報)進行比對。解決方法
似乎很簡單： 撰寫兩個classes 並使用Groundhog 做為key ， 以
Prediction 做為value：
//: c09:SpringDetector.java
// Looks plausible, but doesn't work.
import java.util.*;
class Groundhog {
int ghNumber;
Groundhog(int n) { ghNumber = n; }
}
Chapter 9: Holding Your Objects 483
class Prediction {
boolean shadow = Math.random() > 0.5;
public String toString() {
if(shadow)
return "Six more weeks of Winter!";
else
return "Early Spring!";
}
}
public class SpringDetector {
public static void main(String[] args) {
HashMap hm = new HashMap();
for(int i = 0; i < 10; i++)
hm.put(new Groundhog(i), new Prediction());
System.out.println("hm = " + hm + "\n");
System.out.println(
"Looking up prediction for Groundhog #3:");
Groundhog gh = new Groundhog(3);
if(hm.containsKey(gh))
System.out.println((Prediction)hm.get(gh));
else
System.out.println("Key not found: " + gh);
}
} ///:~
每個Groundhog 都被賦予一個編號，所以如果你想要在HashMap 中
搜尋Prediction ， 只要說「給我那個和Groundhog #3 相關的
Prediction 」。Prediction class 內含一個boolean 值和一個
toString()，前者利用Math.random() 完成初始化，後者為你解釋結
果。main() 將Groundhogs 和其相應的Predictions 置入HashMap
內。程式會將HashMap 的內容印出，所以你可以觀察它是否的確被置入
一些內容。然後，編號3 那個Groundhog 被用來做為key，用以搜尋對
應的預報內容(你可以看到，它一定在Map 之中)。
看起來似乎很簡單，結果卻不正確。問題出在Groundhog 乃繼承自共通
的根類別Object(如果你未指定base class，任何classes 都會自動繼承自
Object 。因此所有class 最終都繼承自Object ) 。Object 的
484 Thinking in Java www.BruceEckel.com
hashCode() 會被用來產生每個物件的hash code，而且在預設情況下它
直接使用其物件的記憶體位址。因此第一個Groundhog(3) 所產生的
hash code 並不會和我們用來搜尋的第二個Groundhog(3) 的hash code
相等。
你可能會認為，只要以適當的hashCode() 加以覆寫(override)就好
了。但只是這麼做還不行，除非你也覆寫同屬於Object 的equals()。當
HashMap 試著判斷你所給定的key 是否等於表格中的某個key 時，便會
透過這個函式來判斷。同樣地，預設的Object.equals() 只會比較物件的
記憶體位址，所以兩個Groundhog(3) 並不相同。
因此，如果你在HashMap 中使用你自己撰寫的classes 做為key，你一
定得同時覆寫hashCode() 和equals()，像這樣：
//: c09:SpringDetector2.java
// A class that's used as a key in a HashMap
// must override hashCode() and equals().
import java.util.*;
class Groundhog2 {
int ghNumber;
Groundhog2(int n) { ghNumber = n; }
public int hashCode() { return ghNumber; }
public boolean equals(Object o) {
return (o instanceof Groundhog2)
&& (ghNumber == ((Groundhog2)o).ghNumber);
}
}
public class SpringDetector2 {
public static void main(String[] args) {
HashMap hm = new HashMap();
for(int i = 0; i < 10; i++)
hm.put(new Groundhog2(i),new Prediction());
System.out.println("hm = " + hm + "\n");
System.out.println(
"Looking up prediction for groundhog #3:");
Groundhog2 gh = new Groundhog2(3);
if(hm.containsKey(gh))
Chapter 9: Holding Your Objects 485
System.out.println((Prediction)hm.get(gh));
}
} ///:~
請注意，這個程式使用了前例的Prediction class，所以你得先行編譯
SpringDetector.java，否則在你試著編譯SpringDetector2.java 時
會收到編譯錯誤訊息。
Groundhog2.hashCode() 會回傳其編號以資識別。本例之中程式員必
須保證，沒有任何兩個Groundhog 物件具有相同的編號。hashCode()
不見得一定要回傳這獨一無二的編號(本章稍後你會更明白)，但是
equals() 一定要能夠精準判斷兩個物件是否相等。
即使equals() 只是檢查引數是否為Groundhog2 實體(以關鍵字
instanceof 進行檢查，詳見第12 章)，instanceof 實際上還會暗中進行
第二個檢查，也就是檢查該物件是否為null，因為instanceof 會在其左
方引數為null 時回傳false。假設此物件的型別正確而且不是null，那麼
便會依據實際的ghNumbers 進行比較。這時候，執行這個程式便可以看
到正確的輸出結果。
當你撰寫用於HashSet 的class 時，你同樣得留意發生於HashMap 身
上的相同問題。
認識hashCode()
上例只是正確解決問題的第一步。它說明了如果你不覆寫你所使用的key
的hashCode() 和equals()，那麼任何在其底層運用hashed 機制的資料
結構(HashSet 或HashMap)都將無法正確處理你所提供的key。如果
想妥善解決這個問題，你得了解hashed 資料結構的運作方式才行。
首先，讓我們思考hashing 背後的動機：透過某個物件搜尋另一個物件。
但是你也可以使用TreeSet 或TreeMap 來達到同樣的目的呀。你甚至可
以實作自己的Map。為了達到這個目的，必須提供Map.entrySet() 來
產生一組Map.Entry 物件。MPair 會被定義為新的Map.Entry 型別。
486 Thinking in Java www.BruceEckel.com
由於我們想將它置於TreeSet 內，所以它得實作equals()，而且得是
Comparable 才行：
//: c09:MPair.java
// A Map implemented with ArrayLists.
import java.util.*;
public class MPair
implements Map.Entry, Comparable {
Object key, value;
MPair(Object k, Object v) {
key = k;
value = v;
}
public Object getKey() { return key; }
public Object getValue() { return value; }
public Object setValue(Object v){
Object result = value;
value = v;
return result;
}
public boolean equals(Object o) {
return key.equals(((MPair)o).key);
}
public int compareTo(Object rv) {
return ((Comparable)key).compareTo(
((MPair)rv).key);
}
} ///:~
注意，比較的對象只是keys，所以重複的values 完全可以被接受。
以下例子使用一對ArrayLists 實作出一個Map：
//: c09:SlowMap.java
// A Map implemented with ArrayLists.
import java.util.*;
import com.bruceeckel.util.*;
public class SlowMap extends AbstractMap {
private ArrayList
Chapter 9: Holding Your Objects 487
keys = new ArrayList(),
values = new ArrayList();
public Object put(Object key, Object value) {
Object result = get(key);
if(!keys.contains(key)) {
keys.add(key);
values.add(value);
} else
values.set(keys.indexOf(key), value);
return result;
}
public Object get(Object key) {
if(!keys.contains(key))
return null;
return values.get(keys.indexOf(key));
}
public Set entrySet() {
Set entries = new HashSet();
Iterator
ki = keys.iterator(),
vi = values.iterator();
while(ki.hasNext())
entries.add(new MPair(ki.next(), vi.next()));
return entries;
}
public static void main(String[] args) {
SlowMap m = new SlowMap();
Collections2.fill(m,
Collections2.geography, 25);
System.out.println(m);
}
} ///:~
put() 很單純地只是將keys 和values 置於對應的ArrayLists 中。main()
會載入SlowMap，然後列印出來以顯示其運作。
這個例子告訴我們，撰寫新型的Map 並不多麼難。但是一如其名稱所
示，SlowMap 執行的並不快，所以如果你有其他替代方案，大概不會用
它。問題出在key 的搜尋上：由於不具任何順序，所以只得採用最簡單的
線性搜尋，而這種搜尋方式正是最慢的一種。
488 Thinking in Java www.BruceEckel.com
hashing 的目的完全是為了速度：hashing 讓搜尋動作得以快速進行。由於
key 的搜尋是速度瓶頸所在，如果我們先將key 排序，然後再使用
Collecctions.binarySearch() 執行搜尋，可能是這個問題的解法之一
(本章最後有個練習，便是讓你完成這個解法)。
hashing 採取更進一步的解法：你只要將key 儲存於「某處」，它便可以
快速找到它。當你閱讀至本書此處，你知道，用來儲存一群元素的結構
中，速度最快的當屬array，所以array 被用來表現key 的資訊(請注意我
說的是「key 的資訊」而非key 本身)。同樣地，既然你已經進行到本書
這一章，你應該已經明白，array 一經配置便無法改變容量大小，於是便引
發了問題：我們想在Map 中儲存任意數量的values，但如果key 的數目
受限於array 的容量，該當如何？
答案是，array 並不儲存key。我們可以從key 物件得出一個數字，用來做
為array 的索引。這個數字即為hashCode()(計算機術語稱此為hash
function)所產生的hash code。hashCode() 定義於Object 內，而且應
該由你的class 加以覆寫。為了解決因array 容量不變而引發的問題，多個
keys 可能會得出同一個索引值。也就是說可能會有「碰撞」(collisions)
發生。由於這樣，array 的容量已無關緊要，因為每個key 物件都會被儲存
於array 的某處。
於是，搜尋某個value 的過程，會從計算其hash code 開始，然後使用此
hash code 做為array 的索引。如果你能夠保證不發生碰撞(當你只有固定
個數的values 時，這種情形便有可能)，那就等於擁有一個「完美的
hashing function」，但這畢竟只是特例。其他時候，碰撞是透過所謂「外
部鏈結」(external chaining)來解決：array 並不直接指向某個value，
而是指向一串values。這些values 以線性方式透過equals() 進行搜尋。
當然這種搜尋緩慢許多，但如果hash function 夠好，同一個slot 上只會有
少數幾個values(譯註：每個索引值代表(指向)一個slot)。所以，無
需搜尋整個list，你就可以快速跳到正確的slot，然後只要在少數幾個
values 之間進行比較，就可以找到搜尋目標。這種作法快多了，這也正是
HashMap 之所以快速的原因。
Chapter 9: Holding Your Objects 489
知道hashing 的基本運作原則後，讓我們實作一個簡單的hashed Map：
//: c09:SimpleHashMap.java
// A demonstration hashed Map.
import java.util.*;
import com.bruceeckel.util.*;
public class SimpleHashMap extends AbstractMap {
// Choose a prime number for the hash table
// size, to achieve a uniform distribution:
private final static int SZ = 997;
private LinkedList[] bucket= new LinkedList[SZ];
public Object put(Object key, Object value) {
Object result = null;
int index = key.hashCode() % SZ;
if(index < 0) index = -index;
if(bucket[index] == null)
bucket[index] = new LinkedList();
LinkedList pairs = bucket[index];
MPair pair = new MPair(key, value);
ListIterator it = pairs.listIterator();
boolean found = false;
while(it.hasNext()) {
Object iPair = it.next();
if(iPair.equals(pair)) {
result = ((MPair)iPair).getValue();
it.set(pair); // Replace old with new
found = true;
break;
}
}
if(!found)
bucket[index].add(pair);
return result;
}
public Object get(Object key) {
int index = key.hashCode() % SZ;
if(index < 0) index = -index;
if(bucket[index] == null) return null;
LinkedList pairs = bucket[index];
MPair match = new MPair(key, null);
490 Thinking in Java www.BruceEckel.com
ListIterator it = pairs.listIterator();
while(it.hasNext()) {
Object iPair = it.next();
if(iPair.equals(match))
return ((MPair)iPair).getValue();
}
return null;
}
public Set entrySet() {
Set entries = new HashSet();
for(int i = 0; i < bucket.length; i++) {
if(bucket[i] == null) continue;
Iterator it = bucket[i].iterator();
while(it.hasNext())
entries.add(it.next());
}
return entries;
}
public static void main(String[] args) {
SimpleHashMap m = new SimpleHashMap();
Collections2.fill(m,
Collections2.geography, 25);
System.out.println(m);
}
} ///:~
由於hash table 中的"slots" 往往被稱為buckets，所以用來表示實際table
的那個array 便被我命名為bucket。為了得到平均分佈，buckets 的個數
通常是個質數。請注意，它是個LinkedList array，它能夠自動解決碰撞
問題- 每個新加入的物件都會被直接置於list 尾端。
當指定的key 已在list 之中，put() 便回傳該key 所關聯的舊value，反之
則回傳null。程式以result 接收回傳值；result 的初值為null，但如果
在list 中找到指定的key，該key 便會被指派給result。
對put() 和get() 來說，其第一個動作都是呼叫key 的hashCode()，而
其結果會被強迫轉為正數。接著再以此值對array 的容量取餘數，藉以使
其成為bucket array 的索引值。如果計算出來的位置是null，便表示沒
有任何元素被"hash to" 該位置上，於是便產生一個新的LinkedList，儲
Chapter 9: Holding Your Objects 491
存此次加入的物件。不過，正常程序下應該走訪整個list，檢查其中是否有
重複的value。如果已經存在，舊value 便被置於result 中，而以新
value 取代舊value。旗標found 會記錄是否找到舊的key-value pair，如
果沒有找到，新的pair 便會被附加到list 尾端。
你可以在get() 中看到和put() 相似的碼，但更為簡單。先是計算
bucket array 的索引值，如果LinkedList 已經存在的話，就進行搜尋，
找出符合者。
entrySet() 必須尋找、走訪所有list，並將所有元素置於所產生的Set
內。一旦完成，便可將測試用的values 填入Map 之中，並將它們印出。
HashMap 的效能因子
為了探討這個問題，先得介紹幾個必要的術語：
Capacity：容量，表格中的buckets 數量。
Initial capacity：最初容量，表格建立之初的buckets 數量。
HashMap 和HashSet：各有建構式，允許你指定最初容量。
Size：大小，表格內目前所有的條目(entries)。
Load factor：負載因子，size/capacity(大小/容量)。負載因子為
0 者，表示一個空表格，0.5 是一個半滿表格，依此類推。一個輕負載
表格出現碰撞(collisions)的機會比較低，比較適合安插和搜尋(但
是會降低「透過迭代器巡訪」的速度)。HashMap 和HashSet 各
有建構式允許你指定負載因子，那意味當這個負載因子達到了，容器的
容量(buckets 個數)會自動擴充- 大約成倍擴充，並將原有的物件重
新導入新的buckets 內(這稱為rehashing)。
HashMap 預設的負載因子值是0.75(意思是除非表格已塞滿3/4 以上，
否則不會進行rehashing)。這似乎是在時間成本和空間成本上的極佳權衡
結果。較高的負載因子能夠降低表格所需空間，但卻增加搜尋上的時間成
本。這一點很重要，因為大多數時候你都是在進行搜尋(包括get() 和
put())。
492 Thinking in Java www.BruceEckel.com
如果你已經知道自己會將許多條目(entries)儲存於HashMap，那麼產
生HashMap 時請給定夠大的初始容量，如此便能防止因為rehashing 而
帶來的額外負擔。
覆寫hashCode()
現在，你已經了解HashMap 函式牽涉了哪些東西，撰寫hashCode()
的種種議題對你會更具意義。
首先，你無法控制buckets array 的索引值的產生。這個索引值和特定的
HashMap 物件的容量有關，而容量和容器的負載情形、負載因子都有關
係。你的hashCode() 所產生的值會被進一步處理以產生bucket 索引
(在SimpleHashMap 中，其計算方式只是對bucket array 的元素個數
取餘數)。
設計hashCode() 時最重要的因素就是：不論hashCode() 何時被呼
叫，針對同一個物件，每次被呼叫都應該產生相同的值。如果某個物件被
put() 置入HashMap 時透過hashCode() 獲得一個值，get() 時卻獲得
另一個值，那麼你將無法取出該物件。所以如果你的hashCode() 和「物
件內可能改變的資料」有關，你必須告訴你的使用者，一旦資料被改變
了，將會因為「產生不同的hashCode()」而得出不同的key。
此外，你或許不會想要根據獨一無二的物件資訊來產生hashCode()，尤
其像this 這樣的值更是個差勁的hashCode()。因為如果這麼做，你就無
法產生一份新的key 並使它和「傳入put() 的原始key-value pair」中的
key 相同。這便是發生於SpringDetector.java 的問題， 因為
hashCode() 的預設實作方法會使用物件的位址。你應該使用物件內某種
有意義的識別資訊。
讓我們以String class 為例。Strings 具有某個特質，那就是當程式具有
多個內容相同的String 物件時，這些String 物件會對應到同一塊位址
(詳見附錄A 對此機制的說明。譯註：此即所謂reference counting)。
所以「兩個new String("hello") 所獲得的實體， 其所產生的
hashCode() 相同」是有道理的。你可以執行以下程式觀察這種現象：
Chapter 9: Holding Your Objects 493
//: c09:StringHashCode.java
public class StringHashCode {
public static void main(String[] args) {
System.out.println("Hello".hashCode());
System.out.println("Hello".hashCode());
}
} ///:~
想讓這個程式正確執行，String 的hashCode() 必須根據String 的內容
來計算才行。
所以，對於一個實用的hashCode() 來說，它必須快速而又有意義。也就
是說它必須能夠依據物件的內容來產生hash code。請記住，此值不見得必
須獨一無二(你應該注重速度更甚於唯一性)但是透過hashCode() 和
equals()，必須能夠完全決定物件的身份。
由於產生bucket 索引值之前hashCode() 會更進一步被處理，所以其值
所處的範圍並不重要，只要是個int 就行。
這裡還有另一個影響因素：好的hashCode() 所產生的值應該均勻分佈。
如果這些數值有密集(cluster)現象，HashMap 或HashSet 的某個部
位的負載就會很重，比不上擁有均勻分佈能力之hashing function 來得快
速。
以下便是依循上述原則所寫成的範例：
//: c09:CountedString.java
// Creating a good hashCode().
import java.util.*;
public class CountedString {
private String s;
private int id = 0;
private static ArrayList created =
new ArrayList();
public CountedString(String str) {
s = str;
created.add(s);
Iterator it = created.iterator();
494 Thinking in Java www.BruceEckel.com
// Id is the total number of instances
// of this string in use by CountedString:
while(it.hasNext())
if(it.next().equals(s))
id++;
}
public String toString() {
return "String: " + s + " id: " + id +
" hashCode(): " + hashCode() + "\n";
}
public int hashCode()
return s.hashCode() * id;
}
public boolean equals(Object o) {
return (o instanceof CountedString)
&& s.equals(((CountedString)o).s)
&& id == ((CountedString)o).id;
}
public static void main(String[] args) {
HashMap m = new HashMap();
CountedString[] cs = new CountedString[10];
for(int i = 0; i < cs.length; i++) {
cs[i] = new CountedString("hi");
m.put(cs[i], new Integer(i));
}
System.out.println(m);
for(int i = 0; i < cs.length; i++) {
System.out.print("Looking up " + cs[i]);
System.out.println(m.get(cs[i]));
}
}
} ///:~
CountedString 內含一個String 以及一個用以表示編號的id。所有
CountedString 物件都內含一模一樣的String。所有Strings 都被儲存
於static ArrayList 內，建構式透過走訪ArrayList 完成元素個數的計
算動作。
Chapter 9: Holding Your Objects 495
hashCode() 和equals() 都是根據兩個資料成員來求結果；如果它們只
根據String 或只根據id，那麼不同的values 就有可能被視為相同(那當
然就不妙了)。
請注意hashCode() 多麼簡單：將String 的hashCode() 乘以id。對
hashCode() 來說，愈小通常代表愈好(而且也愈快)。
main() 產生了許多CountedString 物件，並使用相同的String，藉以
說明「雖然String 的內容相同， 但由於id 不同， 所以產生的
hashCode() 也不相同」。程式會顯示HashMap() 內容，你可以從中觀
察其儲存情形(但不具任何可識別的次序)，然後便是個別搜尋每個
key，藉以說明搜尋機制的確運作無誤。
持有references
java.lang.ref 程式庫含有一組classes，這些classes 為垃圾回收機制提供
更大的彈性。當你擁有許多可能耗盡記憶體的大型物件時，這些classes 格
外有用。有三個classes 繼承自抽象類別Reference：SoftReference,
WeakReference 和PhantomReference。它們都對垃圾回收機制提供
不同層次的間接性- 如果外界只能透過這些Reference 物件才得碰觸物
件的話。
某個物件如果是「可碰觸的(reachable)」，代表程式中的某處可以找到
該物件。這意味你可能擁有stack 上的某個一般性reference，它恰好指向
某個物件；但也可能你擁有一個reference 指向某物件，而該物件擁有一個
reference，指向討論中的這個物件； 這中間可能存在許多中介鏈結
(intermediate links)。如果物件是可碰觸的，垃圾回收器就不能加以釋
放(回收)，因為它仍然被程式所用。如果某個物件不可碰觸，你的程式
便無法使用它，那麼垃圾回收器便可安全地將它回收。
當你希望繼續持有某個reference(它所指的物件是你希望碰觸的)，但你
也允許垃圾回收器將它釋放(回收)，這時候你應該使用Reference 物
件。於是你得以繼續使用該物件，而一旦記憶體即將耗盡，你也允許它被
釋放。
496 Thinking in Java www.BruceEckel.com
以Reference 物件做為你和一般reference 之間的中介，便可達到上述目
的。注意，不能再有其他一般reference 指向那個物件(那是一個未被包裝
(wrapped)於Reference 物件內的物件)。如果垃圾回收器發現某個物
件可透過一般reference 被碰觸，就不會釋放該物件。
一共有三種References 。依照SoftReference, WeakReference,
PhantomReference 的次序，每一個都弱於後者，並且分別對應於不同
等級的可碰觸能力。Soft references 乃是為了實作出與記憶體極端相依的
快取裝置(memory-sensitive cache)而設計，Weak references 是為了實
作所謂標準映射(canonicalizing mapping)而設計(於是物件實體可同時
被使用於程式多處以節省儲存空間)，它並不會妨礙物件的keys(或
values)被重新宣告。Phantom references 是為了以一種比Java 終止機制
(finalization mechanism)更具彈性的方式來對"pre-mortem" 清理動作
進行排程(scheduling)。
使用SoftReferences 和WeakReferences 時，你可以選擇是否要將它
們置於一個ReferenceQueue 中(這是一種用於premortem 清理動作的
工具)。但當你使用PhantomReferences 時，你只能將它們建於一個
ReferenceQueue 內。下面是一個簡單的例子：
//: c09:References.java
// Demonstrates Reference objects
import java.lang.ref.*;
class VeryBig {
static final int SZ = 10000;
double[] d = new double[SZ];
String ident;
public VeryBig(String id) { ident = id; }
public String toString() { return ident; }
public void finalize() {
System.out.println("Finalizing " + ident);
}
}
public class References {
static ReferenceQueue rq= new ReferenceQueue();
public static void checkQueue() {
Object inq = rq.poll();
Chapter 9: Holding Your Objects 497
if(inq != null)
System.out.println("In queue: " +
(VeryBig)((Reference)inq).get());
}
public static void main(String[] args) {
int size = 10;
// Or, choose size via the command line:
if(args.length > 0)
size = Integer.parseInt(args[0]);
SoftReference[] sa =
new SoftReference[size];
for(int i = 0; i < sa.length; i++) {
sa[i] = new SoftReference(
new VeryBig("Soft " + i), rq);
System.out.println("Just created: " +
(VeryBig)sa[i].get());
checkQueue();
}
WeakReference[] wa =
new WeakReference[size];
for(int i = 0; i < wa.length; i++) {
wa[i] = new WeakReference(
new VeryBig("Weak " + i), rq);
System.out.println("Just created: " +
(VeryBig)wa[i].get());
checkQueue();
}
SoftReference s = new SoftReference(
new VeryBig("Soft"));
WeakReference w = new WeakReference(
new VeryBig("Weak"));
System.gc();
PhantomReference[] pa =
new PhantomReference[size];
for(int i = 0; i < pa.length; i++) {
pa[i] = new PhantomReference(
new VeryBig("Phantom " + i), rq);
System.out.println("Just created: " +
(VeryBig)pa[i].get());
checkQueue();
}
}
} ///:~
498 Thinking in Java www.BruceEckel.com
一旦執行這個程式(建議你將輸出結果導至"more" 工具程式，這麼一來就
可以一頁一頁地觀看輸出結果)，你會看到物件已被垃圾回收器回收- 即
使你仍可透過Reference 物件加以存取(如果要取得實際的object
reference，可使用get())。你也會看到ReferenceQueue 總是產生
「內含一個null 物件」的Reference。為了善用此一機制，你可以繼承
你感興趣的某個Reference class，並為你的這個新的Reference 型別加
入更多有用的函式。
WeakHashMap
容器庫中有一個特殊的Map， 其所持有的乃是weak references ：
WeakHashMap。這個class 被設計用來產生所謂的canonicalized
mappings(譯註：見前一小節)。在這樣一個mapping 中，由於每個
value 只存在單一實體，因而節省了儲存空間。一旦程式需要某個value，
便在mapping 中搜尋既有的物件，並使用找到的那個物件(而非重新再造
一個)。mapping 可能會在初始化的時候便產生所含之值，但更有可能在
必要的時候才產生。
由於這是一種節省儲存空間的技巧，所以WeakHashMap 能夠方便地讓
垃圾回收器自動清理key 和value 。你不需要對你打算置入
WeakHashMap 內的key 和value 做什麼特殊動作。一旦key 不再被使
用，便會觸發清理動作，如下所示：
//: c09:CanonicalMapping.java
// Demonstrates WeakHashMap.
import java.util.*;
import java.lang.ref.*;
class Key {
String ident;
public Key(String id) { ident = id; }
public String toString() { return ident; }
public int hashCode()
return ident.hashCode();
}
Chapter 9: Holding Your Objects 499
public boolean equals(Object r) {
return (r instanceof Key)
&& ident.equals(((Key)r).ident);
}
public void finalize() {
System.out.println("Finalizing Key "+ ident);
}
}
class Value {
String ident;
public Value(String id) { ident = id; }
public String toString() { return ident; }
public void finalize() {
System.out.println("Finalizing Value "+ident);
}
}
public class CanonicalMapping {
public static void main(String[] args) {
int size = 1000;
// Or, choose size via the command line:
if(args.length > 0)
size = Integer.parseInt(args[0]);
Key[] keys = new Key[size];
WeakHashMap whm = new WeakHashMap();
for(int i = 0; i < size; i++) {
Key k = new Key(Integer.toString(i));
Value v = new Value(Integer.toString(i));
if(i % 3 == 0)
keys[i] = k; // Save as "real" references
whm.put(k, v);
}
System.gc();
}
} ///:~
正如本章先前所討論的，Key class 必須具備hashCode() 和equals()，
因為它被用來做為一個hashed 資料結構中的key。
500 Thinking in Java www.BruceEckel.com
當你執行這個程式，你會發現，垃圾回收器每經三個keys 便略過一個，因
為指向該key 的一般性reference 已經被置於keys array 內，因此這些物
件不會被垃圾回收器回收。
再論Iterators(迭代器)
現在我們可以說明Iterator 的實際威力了：它能夠將序列走訪能力和序列
底層結構隔離開來。下例中的class PrintData 會使用Iterator 來走訪序
列，並呼叫每個物件的toString()。這裡會產生兩個不同型態的容器：
ArrayList 和HashMap，分別擁有Mouse 物件和Hamster 物件(本
章先前已定義過這兩個classes)。由於Iterator 會將容器的底層結構隱
藏起來，所以PrintData 不知道也不在乎Iterator 來自哪一種容器：
//: c09:Iterators2.java
// Revisiting Iterators.
import java.util.*;
class PrintData {
static void print(Iterator e) {
while(e.hasNext())
System.out.println(e.next());
}
}
class Iterators2 {
public static void main(String[] args) {
ArrayList v = new ArrayList();
for(int i = 0; i < 5; i++)
v.add(new Mouse(i));
HashMap m = new HashMap();
for(int i = 0; i < 5; i++)
m.put(new Integer(i), new Hamster(i));
System.out.println("ArrayList");
PrintData.print(v.iterator());
System.out.println("HashMap");
PrintData.print(m.entrySet().iterator());
}
Chapter 9: Holding Your Objects 501
} ///:~
對HashMap 而言，entrySet() 會產生一個Set，內含Map.entry 物
件。後者含有每個元素的key 和value，所以你會看到兩者皆被印出。
請注意，PrintData.print() 善用了「容器內的物件皆隸屬Object」這個
特性，使System.out.println() 自動呼叫toString()。面對你自己的問
題時，很可能你得假設Iterator 所走訪的乃是某個特定型別的容器。例如
你可能得假設，容器內的所有東西都是「擁有draw() 函式」的Shape。
然後你就必須將Iterator.next() 回傳的Object 向下轉型至Shape。
選擇一份適當的實作品
Choosing an implementation
現在，你應該已經了解，實際上只有三種容器組件：Map, List, Set，而
且每個interface 都只有二至三種實作品。當你需要使用某個interface 所提
供的功能時，該如何選擇呢？
欲了解這個問題的答案，你必須先認識清楚，不同的實作有其不同的特
性、優點和缺點。你依舊可以看到Hashtable, Vector, Stack 的特性，
它們都是舊的容器，所以先前撰寫的程式碼不會無從運作。如果你不打算
使用新的(Java 2 提供的)容器，它們的確是最好的。
其他容器間的差別，取決於其背後提供支援的結構- 亦即實際用以實作出
「我們所欲使用之interface」的資料結構。舉個例子，ArrayList 和
LinkedList 都實作了List interface，所以不論使用何者，程式都會產生
相同結果。
502 Thinking in Java www.BruceEckel.com
然而ArrayList 的底層以array 完成，LinkedList 則是以一般的雙向串
列(double-linked list)完成，其內每個物件除了資料本身外，還有兩個
references，分別指向前一個元素和後一個元素。因此如果你可能在list 中
央進行許多安插或移除動作，LinkedList 比較適當(此外LinkedList
還具備一些由AbstractSequentialList 建構出來的額外功能)。如果並
非如此，那麼ArrayList 通常比較快。
再舉一個例子。Set 可被實作為TreeSet 或HashSet。TreeSet 的底層
是TreeMap，被設計用來產生一個始終依序排列的集合。不過如果你的
Set 之中有大量物件，那麼TreeSet 的安插效率便會變得緩慢。當你撰寫
一個會用到Set 的程式時，應該先考慮使用HashSet，只有在「保持集合
內各元素的排序狀態」極為重要時，才選擇TreeSet。
在各種Lists 之間抉擇
如果想知道各種Lists 之間的差異，最方便的辦法就是來一次效能測試。
以下程式碼會建立一個inner base class，做為測試框架，然後產生一個由
匿名inner classes 組成的array，每一個inner class 用於一種測試。每一
個inner class 都會被test() 呼叫。這個作法讓你得以輕鬆增加新型式的測
試，或移除某種測試。
//: c09:ListPerformance.java
// Demonstrates performance differences in Lists.
import java.util.*;
import com.bruceeckel.util.*;
public class ListPerformance {
private abstract static class Tester {
String name;
int size; // Test quantity
Tester(String name, int size)
this.name = name;
this.size = size;
}
abstract void test(List a, int reps);
}
Chapter 9: Holding Your Objects 503
private static Tester[] tests = {
new Tester("get", 300)
void test(List a, int reps) {
for(int i = 0; i < reps; i++) {
for(int j = 0; j < a.size(); j++)
a.get(j);
}
}
},
new Tester("iteration", 300)
void test(List a, int reps) {
for(int i = 0; i < reps; i++) {
Iterator it = a.iterator();
while(it.hasNext())
it.next();
}
}
},
new Tester("insert", 5000)
void test(List a, int reps) {
int half = a.size()/2;
String s = "test";
ListIterator it = a.listIterator(half);
for(int i = 0; i < size * 10; i++)
it.add(s);
}
},
new Tester("remove", 5000)
void test(List a, int reps) {
ListIterator it = a.listIterator(3);
while(it.hasNext()) {
it.next();
it.remove();
}
}
},
};
public static void test(List a, int reps) {
// A trick to print out the class name:
System.out.println("Testing " +
a.getClass().getName());
504 Thinking in Java www.BruceEckel.com
for(int i = 0; i < tests.length; i++) {
Collections2.fill(a,
Collections2.countries.reset(),
tests[i].size);
System.out.print(tests[i].name);
long t1 = System.currentTimeMillis();
tests[i].test(a, reps);
long t2 = System.currentTimeMillis();
System.out.println(": " + (t2 - t1));
}
}
public static void testArray(int reps) {
System.out.println("Testing array as List");
// Can only do first two tests on an array:
for(int i = 0; i < 2; i++) {
String[] sa = new String[tests[i].size];
Arrays2.fill(sa,
Collections2.countries.reset());
List a = Arrays.asList(sa);
System.out.print(tests[i].name);
long t1 = System.currentTimeMillis();
tests[i].test(a, reps);
long t2 = System.currentTimeMillis();
System.out.println(": " + (t2 - t1));
}
}
public static void main(String[] args) {
int reps = 50000;
// Or, choose the number of repetitions
// via the command line:
if(args.length > 0)
reps = Integer.parseInt(args[0]);
System.out.println(reps + " repetitions");
testArray(reps);
test(new ArrayList(), reps);
test(new LinkedList(), reps);
test(new Vector(), reps);
}
} ///:~
Chapter 9: Holding Your Objects 505
inner class Tester 被宣告為abstract，做為各種測試的base class。它內
含一個String(用以在測試開始時列印出來)、一個size 參數(用以表
示測試的元素個數或測試動作的重複次數)、一個建構式(用以初始化各
個資料成員)、一個abstract test()(用以執行實際測試工作)。所有不
同類型的測試動作都被集中置於tests array 內。程式會將各個繼承自
Tester 的匿名inner classes 設為此一array 的初始值。如果想增加或移除
測試動作，只要將inner class 的定義加至此array 內，或是自array 中移
除，其餘所有必要動作便會自動進行。
為了比較array 和容器(主要是ArrayList)的存取，這裡有個特殊測試
動作，會利用Arrays.asList() 將array 包裝為一個List。請注意，在此
情形下只有前兩個測試可以執行，因為我們無法對array 執行安插或移除
(元素)的動作。
test() 接到它將處理的List 之後，首先為後者充填元素，然後記錄tests
array 內每個測試動作的執行時間。記錄所得會因機器設備的不同而有差
異。這些結果只是為了比較不同容器的執行效能的相對差異。以下便是某
次執行的結果：
容器型別取得
Get
迭代
Iteration
安插
Insert
移除
Remove
array 1430 3850 na na
ArrayList 3070 12200 500 46850
LinkedList 16320 9110 110 60
Vector 4890 16250 550 46850
一如預期，array 在隨機搜尋和迭代動作上都比其他容器快。你可以看到，
隨機存取動作( get() ) 對ArrayLists 而言代價並不高， 但對
LinkedList 來說卻是代價高昂。奇怪的是LinkedList 的迭代速度比
ArrayList 快，這有點違反直覺。另一方面，list 中心處的安插和移除動
作，LinkedList 比ArrayList 快多了，尤其是移除動作。Vector 通常
不像ArrayList 那麼快，因此應該避免使用；它存在於容器庫中只不過是
為了兼容老舊程式碼；它能夠在上述程式中運作，完全是因為它在Java2
506 Thinking in Java www.BruceEckel.com
中被轉換為List。最好的作法可能是以ArrayList 做為你的預設選擇，當
你發現效能問題出於「在list 中心處進行過多的安插和移除動作」，才轉
而使用LinkedList。當然，如果你所處理的是固定數量的一組元素，請
使用array。
在各種Sets 之間抉擇
你可以依據Set 的大小，選擇使用TreeSet 或HashSet(但如果你需要
產生一個經過排序的序列，請使用TreeSet)。以下測試程式說明了其間
的取捨權衡：
//: c09:SetPerformance.java
import java.util.*;
import com.bruceeckel.util.*;
public class SetPerformance {
private abstract static class Tester {
String name;
Tester(String name) { this.name = name; }
abstract void test(Set s, int size, int reps);
}
private static Tester[] tests = {
new Tester("add")
void test(Set s, int size, int reps) {
for(int i = 0; i < reps; i++) {
s.clear();
Collections2.fill(s,
Collections2.countries.reset(),size);
}
}
},
new Tester("contains")
void test(Set s, int size, int reps) {
for(int i = 0; i < reps; i++)
for(int j = 0; j < size; j++)
s.contains(Integer.toString(j));
} },
new Tester("iteration")
Chapter 9: Holding Your Objects 507
void test(Set s, int size, int reps) {
for(int i = 0; i < reps * 10; i++) {
Iterator it = s.iterator();
while(it.hasNext())
it.next();
}
}
},
};
public static void
test(Set s, int size, int reps) {
System.out.println("Testing " +
s.getClass().getName() + " size " + size);
Collections2.fill(s,
Collections2.countries.reset(), size);
for(int i = 0; i < tests.length; i++) {
System.out.print(tests[i].name);
long t1 = System.currentTimeMillis();
tests[i].test(s, size, reps);
long t2 = System.currentTimeMillis();
System.out.println(": " +
((double)(t2 - t1)/(double)size));
}
}
public static void main(String[] args) {
int reps = 50000;
// Or, choose the number of repetitions
// via the command line:
if(args.length > 0)
reps = Integer.parseInt(args[0]);
// Small:
test(new TreeSet(), 10, reps);
test(new HashSet(), 10, reps);
// Medium:
test(new TreeSet(), 100, reps);
test(new HashSet(), 100, reps);
// Large:
test(new TreeSet(), 1000, reps);
test(new HashSet(), 1000, reps);
}
} ///:~
508 Thinking in Java www.BruceEckel.com
下表列出某次執行的結果。注意，執行結果會隨著硬體設備以及你所使用
的Java 虛擬機器(JVM)而有不同。你應該自己執行一下這個測試程式。
型別測試大小Add Contains Iteration
10 138.0 115.0 187.0
TreeSet 100 189.5 151.1 206.5
1000 150.6 177.4 40.04
10 55.0 82.0 192.0
HashSet 100 45.6 90.0 202.2
1000 36.14 106.5 39.39
對所有動作而言，HashSet 的效能通常都優於TreeSet(尤其是最重要
的兩個動作：安插和搜尋)。TreeSet 存在的唯一理由是：它能夠維護其
內元素的排序狀態。所以，只有在你需要這個性質時你才應該使用它。
在各種Maps 之間抉擇
Maps 的大小深深影響其效能表現。以下測試程式說明了取捨權衡：
//: c09:MapPerformance.java
// Demonstrates performance differences in Maps.
import java.util.*;
import com.bruceeckel.util.*;
public class MapPerformance {
private abstract static class Tester {
String name;
Tester(String name) { this.name = name; }
abstract void test(Map m, int size, int reps);
}
private static Tester[] tests = {
new Tester("put")
void test(Map m, int size, int reps) {
for(int i = 0; i < reps; i++) {
m.clear();
Collections2.fill(m,
Chapter 9: Holding Your Objects 509
Collections2.geography.reset(), size);
}
}
},
new Tester("get")
void test(Map m, int size, int reps) {
for(int i = 0; i < reps; i++)
for(int j = 0; j < size; j++)
m.get(Integer.toString(j));
}
},
new Tester("iteration")
void test(Map m, int size, int reps) {
for(int i = 0; i < reps * 10; i++) {
Iterator it = m.entrySet().iterator();
while(it.hasNext())
it.next();
}
}
},
};
public static void
test(Map m, int size, int reps) {
System.out.println("Testing " +
m.getClass().getName() + " size " + size);
Collections2.fill(m,
Collections2.geography.reset(), size);
for(int i = 0; i < tests.length; i++) {
System.out.print(tests[i].name);
long t1 = System.currentTimeMillis();
tests[i].test(m, size, reps);
long t2 = System.currentTimeMillis();
System.out.println(": " +
((double)(t2 - t1)/(double)size));
}
}
public static void main(String[] args) {
int reps = 50000;
// Or, choose the number of repetitions
// via the command line:
if(args.length > 0)
510 Thinking in Java www.BruceEckel.com
reps = Integer.parseInt(args[0]);
// Small:
test(new TreeMap(), 10, reps);
test(new HashMap(), 10, reps);
test(new Hashtable(), 10, reps);
// Medium:
test(new TreeMap(), 100, reps);
test(new HashMap(), 100, reps);
test(new Hashtable(), 100, reps);
// Large:
test(new TreeMap(), 1000, reps);
test(new HashMap(), 1000, reps);
test(new Hashtable(), 1000, reps);
}
} ///:~
由於Map 的大小是重要影響因素，你可以看到，這份測試所量測出來的
時間，除以測試大小，會使每次量測呈現常態化(normalized)。以下是
一組結果(你的結果可能有所不同)。
型別測試
大小
Put Get Iteration
10 143.0 110.0 186.0
TreeMap 100 201.1 188.4 280.1
1000 222.8 205.2 40.7
10 66.0 83.0 197.0
HashMap 100 80.7 135.7 278.5
1000 48.2 105.7 41.4
10 61.0 93.0 302.0
Hashtable 100 90.6 143.3 329.0
1000 54.1 110.95 47.3
一如你所預期，Hashtable 的效率大致上和HashMap 相同(你也看到
了，HashMap 一般來說稍微快些。的確，HashMap 是Hashtable 的
替代品)。TreeMap 通常比HashMap 慢，那麼何必使用它呢？因為你
可以不把它當做Map，而把它當做一種產生有序串列(ordered list)的手
Chapter 9: Holding Your Objects 511
法。tree 特性使得它總是保有某種次序，但不見得有什麼特定排序。一旦
你將元素置入TreeMap，便可以呼叫keySet() 取得一份以Set 為觀點
的keys，然後可以呼叫toArray() 產生這些keys 所組成的array。接下來
便可使用static Array.binarySearch()(稍後討論)於排序狀態下的
array 內進行快速搜尋。當然，如果基於某種理由，你只想執行這樣的動
作，那麼就不適合採用HashMap，因為HashMap 被設計用於快速搜
尋。你可以輕易透過單一物件的生成， 利用TreeMap 產生一個
HashMap。結論是，當你使用Map，應該優先選擇HashMap；只有當
你的Map 必須持續保持排序狀態，才需要動用TreeMap。
Lists 的排序和搜尋
對Lists 進行排序和搜尋的那些公用函式(utilities)，和用於objects
array 身上的一樣，具有相同的名稱和標記式(signatures)。只不過這些
static 函式隸屬於Collections 而非Arrays。以下是個例子，修改自
ArraySearch.java：
//: c09:ListSortSearch.java
// Sorting and searching Lists with 'Collections.'
import com.bruceeckel.util.*;
import java.util.*;
public class ListSortSearch {
public static void main(String[] args) {
List list = new ArrayList();
Collections2.fill(list,
Collections2.capitals, 25);
System.out.println(list + "\n");
Collections.shuffle(list);
System.out.println("After shuffling: "+list);
Collections.sort(list);
System.out.println(list + "\n");
Object key = list.get(12);
int index =
Collections.binarySearch(list, key);
System.out.println("Location of " + key +
512 Thinking in Java www.BruceEckel.com
" is " + index + ", list.get(" +
index + ") = " + list.get(index));
AlphabeticComparator comp =
new AlphabeticComparator();
Collections.sort(list, comp);
System.out.println(list + "\n");
key = list.get(12);
index =
Collections.binarySearch(list, key, comp);
System.out.println("Location of " + key +
" is " + index + ", list.get(" +
index + ") = " + list.get(index));
}
} ///:~
這些函式的使用方式，和應用於Arrays 身上的一樣。只不過你現在用的
是一個List 而非一個array 。和array 的情況相同， 如果你使用
Comparator 來進行排序，你就得使用同樣的Comparator 來進行
binarySearch()。
這個程式同時也示範了Collections 中的shuffle()，它能以隨機方式改
變List 的次序(order)。
公用函式(Utilities)
Collections class 提供了一些有用的工具：
enumeration(Collection) 為引數產生一個舊式的
Enumeration。
max(Collection)
min(Collection)
找出(並傳回)引數中的最大或
最小元素- 採用Collection 內
含之物件的自然比較法
(natural comparison)。
max(Collection, Comparator)
min(Collection, Comparator)
使用Comparator，回傳
Collection 內的最大或最小元
素。
reverse( ) 將所有元素反轉於適當位置。
Chapter 9: Holding Your Objects 513
copy(List dest, List src) 將src 中的元素複製到dest。
fill(List list, Object o) 以o 取代list 內的所有元素。
nCopies(int n, Object o) 回傳一個「大小為n、內容不再
更動」的List，其中所有
reference 皆指向o。
請注意，min() 和max() 都能處理Collection 物件，但不能處理List。
所以你不需要擔心Collection 是否應該先經過排序。一如先前所說，只有
在執行binarySearch() 之前，你才需要先對List 或array 做sort() 動
作。
讓Collection 或Map 無法被更改
通常，撰寫唯讀版本的Collection 或Map，可能為你帶來許多便利。
Collections class 允許你只要將原來的容器傳入某個函式中便可得到一份
唯讀版本。這個函式共有四種變形：分別用於Collection(如果你並不想
將Collection 視為更特定的型別的話)、List、Set、Map。以下例子示
範建構各種型別之唯讀版本的正確方式：
//: c09:ReadOnly.java
// Using the Collections.unmodifiable methods.
import java.util.*;
import com.bruceeckel.util.*;
public class ReadOnly {
static Collections2.StringGenerator gen =
Collections2.countries;
public static void main(String[] args) {
Collection c = new ArrayList();
Collections2.fill(c, gen, 25); // Insert data
c = Collections.unmodifiableCollection(c);
System.out.println(c); // Reading is OK
c.add("one"); // Can't change it
List a = new ArrayList();
Collections2.fill(a, gen.reset(), 25);
514 Thinking in Java www.BruceEckel.com
a = Collections.unmodifiableList(a);
ListIterator lit = a.listIterator();
System.out.println(lit.next()); // Reading OK
lit.add("one"); // Can't change it
Set s = new HashSet();
Collections2.fill(s, gen.reset(), 25);
s = Collections.unmodifiableSet(s);
System.out.println(s); // Reading OK
//! s.add("one"); // Can't change it
Map m = new HashMap();
Collections2.fill(m,
Collections2.geography, 25);
m = Collections.unmodifiableMap(m);
System.out.println(m); // Reading OK
//! m.put("Ralph", "Howdy!");
}
} ///:~
不論哪一種情況，你都必須在你的容器成為唯讀之前，先將有意義的資料
填入。載入資料後， 最好的作法就是以「不會造成變動」之呼叫
(unmodifiable call)所產生的reference 替換掉原有的reference。藉由這
個方式，容器獲得唯讀性質之後，你就不可能「不小心改變其內容」了。
另一方面，這個手法也讓你得以在class 內部將「打算被修改的容器」宣告
為private ， 並利用某個函式傳回「指向該容器」的一個唯讀的
reference。於是你就可以在class 內部改變容器內容，但其他人只能讀取。
針對某個特定型別呼叫一個「不會造成變動」的函式，並不會引起編譯期
檢驗。但是一旦轉換發生，所有「會造成容器內容變動」的method calls
都會引發UnsupportedOperationException。
Collection 或Map 的同步控制
Synchronizing a Collection or Map
關鍵字synchronized 在「多緒」(multithreading)課題中是十分重要
的一環，本書第14 章才會導入這個課題。這裡我要先提醒你，只有
Chapter 9: Holding Your Objects 515
Collection class 才具備「自動同步控制整個容器」的機制。其語法和
「不會造成變動的」(unmodifiable)函式類似：
//: c09:Synchronization.java
// Using the Collections.synchronized methods.
import java.util.*;
public class Synchronization {
public static void main(String[] args) {
Collection c =
Collections.synchronizedCollection(
new ArrayList());
List list = Collections.synchronizedList(
new ArrayList());
Set s = Collections.synchronizedSet(
new HashSet());
Map m = Collections.synchronizedMap(
new HashMap());
}
} ///:~
此例將新產生的容器立刻傳入適當的"synchronized" 函式中；透過這種方
式，就不會意外產生不同步的版本。
Fail fast(當機立斷判出局)
Java 容器還有一個機制，可以防止多個行程(processes)修改同一個容器
的內容。如果你正在走訪某個容器，另一個行程卻要進行元素的安插、刪
除、修改等動作，便會發生問題：或許你已經走過了那個物件、或許你還
沒有、或許在你呼叫size() 之後容器的大小縮減了…太多太多不幸的情
況。Java 容器庫有一個所謂的fail-fast 機制：它會搜尋「因你的行程而做
的任何改變」之外的所有容器變化。如果它偵測到其他行程也在修改同一
個容器，就會立刻產生一個ConcurrentModifictionException。此即
所謂"fail-fast" - 它並不會試著於稍後才以更複雜的演算法來偵測問題。
516 Thinking in Java www.BruceEckel.com
很容易就可以觀察到fail-fast 機制的運作。你唯一需要做的就是產生一個
迭代器，然後將某些東西加到迭代器所指的那個Collection 中，像這樣：
//: c09:FailFast.java
// Demonstrates the "fail fast" behavior.
import java.util.*;
public class FailFast {
public static void main(String[] args) {
Collection c = new ArrayList();
Iterator it = c.iterator();
c.add("An object");
// Causes an exception:
String s = (String)it.next();
}
} ///:~
這樣便會引發異常，因為在向容器取得迭代器之後，某些東西又被置入容
器內。程式中有兩個地方都有可能修改到同一個容器，並因而產生不確定
狀態。引發的那個異常便是通知你說，你應該修改你的程式- 本例之中你
得在加入所有元素之後，才取迭代器。
請注意，當你運用get() 來存取List 的元素時，無法從此類監看動作中得
到好處。
未獲支援的操作(Unsupported operations)
透過Arrays.asList()，我們可以將array 轉換為List：
//: c09:Unsupported.java
// Sometimes methods defined in the
// Collection interfaces don't work!
import java.util.*;
public class Unsupported {
private static String[] s = {
"one", "two", "three", "four", "five",
"six", "seven", "eight", "nine", "ten",
Chapter 9: Holding Your Objects 517
};
static List a = Arrays.asList(s);
static List a2 = a.subList(3, 6);
public static void main(String[] args) {
System.out.println(a);
System.out.println(a2);
System.out.println(
"a.contains(" + s[0] + ") = " +
a.contains(s[0]));
System.out.println(
"a.containsAll(a2) = " +
a.containsAll(a2));
System.out.println("a.isEmpty() = " +
a.isEmpty());
System.out.println(
"a.indexOf(" + s[5] + ") = " +
a.indexOf(s[5]));
// Traverse backwards:
ListIterator lit = a.listIterator(a.size());
while(lit.hasPrevious())
System.out.print(lit.previous() + " ");
System.out.println();
// Set the elements to different values:
for(int i = 0; i < a.size(); i++)
a.set(i, "47");
System.out.println(a);
// Compiles, but won't run:
lit.add("X"); // Unsupported operation
a.clear(); // Unsupported
a.add("eleven"); // Unsupported
a.addAll(a2); // Unsupported
a.retainAll(a2); // Unsupported
a.remove(s[0]); // Unsupported
a.removeAll(a2); // Unsupported
}
} ///:~
你會發現，Collection 和List interfaces 之中，只有一部份被確確實實地
實作出來。如果你呼叫了其他函式， 便會引發令人討厭的異常
UnsupportedOperationException。下一章你會學到各種異常，這裡
518 Thinking in Java www.BruceEckel.com
長話短說：Collection(或Java 容器庫內的其他某些interfaces)內含所
謂「可有可無的(optional)」函式，它們有可能在實作該interface 的具
象類別中獲得支援，但也可能不會。如果你呼叫未獲支援的函式，會引發
UnsupportedOperationException，表示編程有問題。
『什麼?!』你一定難以置信：『interfaces 和base classes 的整個重點不就
是在於保證這些函式一定會執行某種有意義的動作嗎？上述說法破壞了這
個承諾，使得呼叫某些函式時不僅不會執行有意義的行為，甚至會中斷整
個程式的執行！型別的安全性簡直被棄若鄙屣！』
情況其實沒有那麼糟糕。使用Collection、List、Set、Map 時，編譯器
會嚴格限制你只能呼叫interface 內的函式，所以和Smalltalk 並不一樣
(在Smalltalk 中你可以呼叫任何物件的任何函式，而且只有當你執行你的
程式時，你才會知道你的呼叫是否做了些什麼動作)。此外，大多數接受
Collection 做為引數的函式，都只會讀取其內容，而Collection 的所有
"read" 函式都不是「可有可無的」。
這個方法能防止設計過程中的intefaces 數量大增。其他容器庫似乎都提供
了過多令人混淆的interfaces 來描述主架構的各種變形，因而變得難以學
習。由於每個人都可能發明新的interface ， 所以甚至不可能找出
interfaces 的所有特例。「未獲支援的操作」達成了Java 容器庫的一個
重要目標：容器必須易學易用；這些「未獲支援的動作」是一種「可以稍
晚再學習」的特殊個案。然而，為了讓這種作法成立：
1. UnsupportedOperationException 必須是個很少出現的事件
(event)。也就是說對大多數classes 而言，所有操作都應該能夠
運行才是。只有在特殊情況下才可以不支援某項操作。Java 容器庫
亦然，因為99%的時間裡頭，你可能使用的classes(ArrayList、
LinkedList、HashSet、HashMap，以及其他具象實作類別)
都支援所有操作。如果你想要產生新的Collection，但不想為
Collection interface 中的所有函式都提供定義，卻想讓它和既有程
式庫整合，這樣的設計便可為你提供一扇「後門」。
Chapter 9: Holding Your Objects 519
2. 當某個操作不被支援，實作時(而非等到產品出貨給顧客後)就出
現UnsupportedOperationException，應該是個很合乎道理的
結果。畢竟它代表的是編程上的錯誤：你使用了不正確的實作物
(implementation)。事實不見得如此，而這也正是此一設計的實
驗性質發揮作用的地方。只有隨著時間過去，我們才會知道它的功
效如何。
上例中的Arrays.asList() 會產生一個「以固定容量的array 為基底」的
List。因此對它而言，僅支援那些「永遠不會改變array 容量」的操作，是
很合理的。如果有個新的interface 用來表示不同種類的行為(或許名為
"FixedSizeList")，那麼便會打開複雜度的大門。很快地，在你試著使用
程式庫時，你會不知道從何著手。
一個接受Collection 或List 或Set 或Map 為引數的函式，其說明文件
應該指出哪些可有可無的函式一定得被實作出來。例如，排序需要用到
set() 和Iterator.set()，卻不需要add() 和remove()。
Java 1.0/1.1 的容器
很不幸的是，許多老舊程式碼使用Java 1.0/1.1 容器，甚至新的程式碼有時
候也會使用那些classes。所以雖然撰寫新程式時你不該再使用舊容器，但
你還是得了解它們才行。舊容器的功能極為有限，並沒有太多需要說明的
地方。它們已經是過去式了，所以我盡力克制自己不要去強調一些設計上
令人厭惡的決定。
Vector 和Enumeration
在Java 1.0/1.1 中，Vector 是唯一可以自行擴增容量的序列，所以它被大
量運用。但是其缺點多到難以於此詳列(請參考本書第一版- 附於本書光
520 Thinking in Java www.BruceEckel.com
碟，也可自www.BruceEckel.com 免費下載)。基本上你可以把它想像是
個「函式名稱又長又不好用」的ArrayList。在Java 2 容器庫中，
Vector 已經過調整，符合Collection 規格和List 規格。因此以下例子
可以成功使用Collection2.fill()。然而這其實是走上了一條不正確的道
路，因為這可能會誤導某些人以為Vector 變得更好了。其實它被Java 2
含括進來只不過是為了支援老舊的(Java 2 以前的)程式碼罷了。
Java 1.0/1.1 版的迭代器取名為"enumeration"(列舉)，而不使用先前大
家早已熟悉的術語。Enumeration interface 比Iterator 小，只有兩個
函式，名稱頗長。一個是boolean hashMoreElements()，它會在「容
器內部尚有元素」時回傳true，另一個是Object nextElement()，它會
在「容器內部尚有元素」時回傳下一個元素(如果沒有元素了，就擲出異
常)。
Enumeration 只是個interface(介面)，而不是個implementation(實
作物)。甚至即使新程式庫有時候也會運用舊的Enumeration - 這令人
十分遺憾，但通常不會造成傷害。雖說能夠的話最好使用Iterator，但你
也得有心理準備，程式庫可能會回傳給你一個Enumeration。
此外，你可以透過Collections.enumeration() 為任意一個Collection
產生一個Enumeration，一如下例所示：
//: c09:Enumerations.java
// Java 1.0/1.1 Vector and Enumeration.
import java.util.*;
import com.bruceeckel.util.*;
class Enumerations {
public static void main(String[] args) {
Vector v = new Vector();
Collections2.fill(
v, Collections2.countries, 100);
Enumeration e = v.elements();
while(e.hasMoreElements())
System.out.println(e.nextElement());
// Produce an Enumeration from a Collection:
e = Collections.enumeration(new ArrayList());
Chapter 9: Holding Your Objects 521
}
} ///:~
Java 1.0/1.1 的Vector 只有個addElement()，但fill() 會使用add()，
那是Vector 被轉為List 時所帶入的。你可以呼叫elements() 產生一個
Enumeration，然後便可用它來執行前向迭代(forward iteration)。
程式的最後一行產生一個ArrayList ， 並使用enumeration() 將
ArrayList Iterator 轉換成一個Enumeration。因此如果你的舊程式需
要Enumeration，你還是可以使用新式容器。
Hashtable
一如你在本章效能評比相關篇幅中所見，Hashtable 和HashMap 極為
相似， 甚至連函式名稱都相像。因此在新程式中， 沒有理由使用
Hashtable 來取代HashMap。
Stack
stack 的觀念先前已經和LinkedList 一起介紹過了。Java 1.0/1.1 的奇怪
表現是，竟然不以Vector 做為Stack 的基底，反而讓Stack 繼承
Vector。因此Stack 擁有Vector 的所有特性和行為，以及Stack 自己
的額外行為。實在很難猜測這究竟是設計者明確認知下的有用作法，或只
是一個幼稚的設計。
以下是Stack 的簡單運用實例，將String array 的每一行都推入stack：
//: c09:Stacks.java
// Demonstration of Stack Class.
import java.util.*;
public class Stacks {
static String[] months =
"January", "February", "March", "April",
"May", "June", "July", "August", "September",
"October", "November", "December" };
public static void main(String[] args) {
522 Thinking in Java www.BruceEckel.com
Stack stk = new Stack();
for(int i = 0; i < months.length; i++)
stk.push(months[i] + " ");
System.out.println("stk = " + stk);
// Treating a stack as a Vector:
stk.addElement("The last line");
System.out.println(
"element 5 = " + stk.elementAt(5));
System.out.println("popping elements:");
while(!stk.empty())
System.out.println(stk.pop());
}
} ///:~
months array 中的每一行都會經由push() 被置於Stack 內，並於稍後
以pop() 將它們自stack 頂端取出。為了特別強調，我在Stack 物件身上
執行Vector 的動作，這沒問題，因為，稍早所說的繼承關係使得「Stack
是一個Vector」，因此所有可執行於Vector 身上的操作，都可以執行於
Stack 身上，例如elementAt()。
一如先前所說，當你想要stack 的行為時，你應該使用LinkedList。
BitSet
如果想要高效率地儲存大量「開/關」資訊，BitSet 是很好的選擇。不過
它的效率僅僅表現於空間。如果你需要高效率的存取時間，BitSet 會比原
生的(語言支援的)array 稍慢一些。
此外，BitSet 的最小空間是long：64 bits。這意味如果你所儲存的內容
比較小，例如8 bits，那麼BitSet 就會浪費一些空間。因此如果空間對你
是個問題，你最好撰寫自己的class 或直接採用array 來儲存開關旗標
(on-off flags)。
一個正常的容器會隨著元素的加入而擴增其大小，BitSet 也是。以下示範
BitSet 的運作方式：
//: c09:Bits.java
// Demonstration of BitSet.
import java.util.*;
Chapter 9: Holding Your Objects 523
public class Bits {
static void printBitSet(BitSet b) {
System.out.println("bits: " + b);
String bbits = new String();
for(int j = 0; j < b.size() ; j++)
bbits += (b.get(j) ? "1" : "0");
System.out.println("bit pattern: " + bbits);
}
public static void main(String[] args) {
Random rand = new Random();
// Take the LSB of nextInt():
byte bt = (byte)rand.nextInt();
BitSet bb = new BitSet();
for(int i = 7; i >=0; i--)
if(((1 << i) & bt) != 0)
bb.set(i);
else
bb.clear(i);
System.out.println("byte value: " + bt);
printBitSet(bb);
short st = (short)rand.nextInt();
BitSet bs = new BitSet();
for(int i = 15; i >=0; i--)
if(((1 << i) & st) != 0)
bs.set(i);
else
bs.clear(i);
System.out.println("short value: " + st);
printBitSet(bs);
int it = rand.nextInt();
BitSet bi = new BitSet();
for(int i = 31; i >=0; i--)
if(((1 << i) & it) != 0)
bi.set(i);
else
bi.clear(i);
System.out.println("int value: " + it);
printBitSet(bi);
524 Thinking in Java www.BruceEckel.com
// Test bitsets >= 64 bits:
BitSet b127 = new BitSet();
b127.set(127);
System.out.println("set bit 127: " + b127);
BitSet b255 = new BitSet(65);
b255.set(255);
System.out.println("set bit 255: " + b255);
BitSet b1023 = new BitSet(512);
b1023.set(1023);
b1023.set(1024);
System.out.println("set bit 1023: " + b1023);
}
} ///:~
這個程式使用亂數產生器來產生隨機的byte、short、int，每一個都被轉
換為對應於BitSet 的bit 表示式。這麼做完全沒有問題，因為BitSet 是
64 bits，所以不會有任何一個數造成BitSet 擴增大小。隨後程式產生了一
個512 bits 的BitSet。建構式會配置比bits 數更大一倍的空間，不過你也
可以將編號#1024(或更大)的bit 設為true(譯註：意指BitSet 會自動
擴展)。
摘要
讓我們檢閱Java 標準程式庫提供的各種容器：
1. array「將數值索引關聯至物件」。它持有型別已知的物件，所以搜
尋物件時並不需要對搜尋結果做轉型動作。array 可以是多維度的，
而且可以持有基本型別(primitives types)。不過array 的容量在
誕生之後便無法改變。
2. Collection 持有的是單一元素，Map 則持有相關聯的成對元素。
3. 和array 一樣，List 也將數值索引關聯至物件。你可以將array 和
Lists 想像成一種有序的容器(ordered container)。當你加入元
素，List 會自動調整大小。但是List 只能持有Object reference，
Chapter 9: Holding Your Objects 525
無法持有基本型別(primitives types)。而且每當你自容器取出
Object reference，都得對結果進行轉型，才能拿來使用。
4. 如果你需要大量隨機存取，請使用ArrayList。如果你會在list 的
中心處進行大量的安插或移除動作，請使用LinkedList。
5. queues、deques、stacks 的行為乃是透過LinkedList 提供。
6. Map 是一種將物件(而非數值索引)關聯至其他物件的機制。
HashMap 的設計思考著重於速度，TreeMap 則著重於如何讓
key 保持排序狀態，因此不像HashMap 那麼快。
7. Set 不接受重複元素。HashSets 提供最快的搜尋速度，TreeSets
則使元素保持排序狀態。
8. 沒有必要在新程式中使用老舊的Vector、Hashtable、Stack。
容器是你每天都會用到的工具。它可以讓你的程式更簡單、更具威力、也
更有效率。
練習
某些經過挑選的題目，其解答置於《The Thinking in Java Annotated Solution Guide》電子文件中。
僅需小額費用便可自www.BruceEckel.com.網站取得。
1. 產生一個double array ， 並充填元素( 使用fill() 並搭配
RandDoubleGenerator)。請印出結果。
2. 撰寫一個Gerbil(沙鼠)class，令它具備int gerbilNumber，
並在建構式中加以初始化(和本章的Mouse 範例類似)。讓它擁
有一個hop()，其功能是印出自己的編號以及「自己正在跳躍
(hopping)」的訊息。請產生一個ArrayList 並將多個Gerbil
物件加於其內，然後使用get() 走訪這個List，並呼叫每個
Gerbil 的hop()。
526 Thinking in Java www.BruceEckel.com
3. 修改練習2，改使用Iterator 來走訪List(當呼叫hop() 時)。
4. 使用練習2 的Gerbil class，並將它改置於Map 內。將Gerbil 的
名稱當做String(並視為key)，令它關聯至你置於表格內的
Gerbil(視為value)。取得keySet() 的Iterator，並利用它來
走訪Map、搜尋每個key 所對應的Gerbil，以及印出key、讓每
個Gerbil 執行hop()。
5. 產生一個List(請嘗試使用ArrayList 和LinkedList)，並利用
Collections2.countries 充填內容。對此list 排序並列印，然後
將Collections.shuffle() 反覆套用於此list 身上，每次都列印內
容，藉以觀察shuffle() 每次是怎樣地將list 內容打亂。
6. 證明除了Mouse 之外，你無法將任何東西加入MouseList 內。
7. 修改MouseList.java， 使它繼承ArrayList 而非使用複合
(composition)手法。闡述這個作法的問題所在。
8. 修正CatsAndDogs.java 的問題：撰寫一個Cats 容器(使用
ArrayList)，令它只能接受、取出Cat 物件。
9. 撰寫一個容器，將String array 封裝於內，並且只能安插或取出
Strings，因此使用時沒有轉型的問題。如果安插元素時內部array
的空間不足，這個容器應該自動調整大小。面對你這個容器和用以
儲存Strings 的ArrayList 容器，請在main() 之中比較兩者的
效能。
10. 重複練習9，但將容器改成儲存int，並比較你的容器和儲存
Integer 物件之ArrayList 的效能- 包括對容器內的每個物件執
行累加(incrementing)動作。
11. 使用com.bruceeckel.util 的公用程式，產生各種primitives
array 和String array，然後以適合的產生器(generator)充填每
個array，再以適當的print() 將每個array 內容印出。
Chapter 9: Holding Your Objects 527
12. 撰寫一個產生器(generator)，使它產生你最喜歡的電影中的各個
角色名稱(你可以選「白雪公主」或「星際大戰」)，並在用完所
有名稱時從頭再來一遍。使用com.bruceeckel.util 中的公用程
式將這些角色名稱分別填入array、ArrayList、LinkedList、以
及兩種Set 內。然後印出每個容器的內容。
13. 撰寫一個class，內含兩個String 物件，並實作Comparable 使
得比較動作只與第一個String 有關。使用geography 產生器，
將你這個class 的物件充填至array 和ArrayList 內。請展示排序
運作無誤。接下來，製作一個Comparator，令它在比較動作中
只在乎第二個String，並請展示排序運作無誤。同時，請使用你的
這個Comparator 執行二分搜尋(binary search)。
14. 修改練習13，依字母次序進行排序。
15. 使用Arrays2.RandStringGenerator 來充填TreeSet，並使用
字母次序來排序。印出TreeSet 的內容以檢驗排序是否正確。
16. 產生一個ArrayList 和一個LinkedList，並使用自動產生器
Collection2.capitals 來充填內容。使用一般的Iterator 印出這
兩個容器的內容，然後使用ListIterator 將其中一個list 安插到另
一個list 中，安插在任何你希望的位置。現在，在第一個list 的尾
端執行安插動作，並且往回(backward)移動。
17. 撰寫一個函式，使用Iterator 來走訪Collection 並印出容器內每
個物件的hashCode()。將物件填入各種不同型別的Collections
內，並將你的函式套用在每個容器身上。
18. 修正InfiniteRecursion.java 中的問題。
19. 撰寫一個class，然後以其物件為初值產生一個array。再根據這個
array 充填一個List。使用subList() 產生上述List 的一個子集，
並使用removeAll() 將該子集自List 中移除。
528 Thinking in Java www.BruceEckel.com
20. 修改第7 章的練習6，改用ArrayList 來持有Rodents，並改用
Iterator 來走訪Rodents 序列。請千萬記得，ArrayList 僅能持
有Objects，所以在存取個別Rodents 時，你得搭配轉型動作。
21. 模仿Queue.java 範例，撰寫一個Deque class 並測試之。
22. 在Statistics.java 中使用TreeMap，並將「測試HashMap 和
TreeMap 效能差異」的程式碼加入該程式。
23. 產生一個Map 和一個Set，內含所有以'A' 為首的國家名稱。
24. 使用Collections2.countries，將同一份資料多次填入Set 內，
然後檢查Set 面對重複資料是否只儲存一份。請在兩種Set 上進行
嘗試。
25. 以Statistics.java 做為開始，撰寫一個程式，可反覆執行測試，
並檢查是否有哪個數字的出現頻率高於其他數字。
26. 使用Count 物件的HashSet 來重寫Statistics.java(你得修改
Counter 俾使它能夠用於HashSet)。哪一種作法看起來比較好
呢？
27. 修改練習13 中的class，使它能夠搭配HashSets 使用，也可以做
為HashMaps 的key。
28. 模仿SlowMap.java，撰寫一個SlowSet。
29. 將Map1.java 中的測試動作套用於SlowMap 身上，檢查它是否
運作正確。如果SlowMap 的運作不正確，請加以修正。
30. 為SlowMap 實作出Map interface 的剩餘部份。
31. 修改MapPerformance.java 以含括SlowMap 中的測試。
32. 修改SlowMap 的內容，使它不再使用兩個ArrayLists，而是持
有唯一一個以MPair 物件組成的ArrayList。驗證修改過的版本
是否正確運作。使用MapPerformance.java 來測試新Map 的
速度。現在，修改put()，使它在每一筆成對資料置入後進行
Chapter 9: Holding Your Objects 529
sort()。修改get()，改用Collections.binarySearch() 來搜尋
key。比較新舊版本的效能。
33. 為CountedString 新增一筆char 資料，並同樣於建構式中加以
初始化。修改hashCode() 和equals()，使它們將這個char 納
入考量。
34. 修改SimpleHashMap，使它得以記錄碰撞的發生。將相同資料
重複加入兩次，於是你便可以看到碰撞發生。
35. 修改SimpleHashMap ， 使它得以記錄碰撞發生時所謂的
「probes」個數。這個數字的意思是，當我們走訪LinkedList，
得在Iterators 上呼叫多少次next() 才能找到想要搜尋的元素。
36. 實作SimpleHashMap 的clear() 和remove()。
37. 為SimpleHashMap 實作Map interface 的剩餘部份。
38. 將private rehash() 加至SimpleHashMap 中，並在負載因子
超過0.75 時呼叫它。一旦決定rehashing，將buckets 個數乘以
2，然後找出最鄰近而大於該值的質數，做為新的buckets 個數。
39. 模仿SimpleHashMap.java，撰寫SimpleHashSet 並加測
試。
40. 修改SimpleHashMap，以ArrayLists 取代LinkedList。修
改MapPerformance.java 以比較上述兩者效能。
41. 使用JDK 的HTML 文件(可自java.sun.com 下載)，找出
HashMap class。現在，產生一個HashMap，充填元素，決定
負載參數。測試此一Map 的搜尋速度。然後產生一個新的
HashMap，給予較大的初始容量，並將舊Map 複製過去。以此
方式來增加速度。請在新Map 身上再次執行搜尋測試。
530 Thinking in Java www.BruceEckel.com
42. 找出第8 章的GreenhouseControls.java 範例，其中含有三個
檔案。在Controller.java 中，class EventSet 不過是個容器，
請改以LinkedList 取代EventSet。這不僅僅只是將EventSet
換成LinkedList 就好了，你還需要使用Iterator 來走訪所有事
件。
43. 挑戰題：撰寫自己的hashed map class，使它專門為某個特定的
key 型別(例如String)量身打造。不要繼承Map，而是重複其
函式，讓put() 和get() 都只接受String 物件(而非Objects)
做為key。任何與key 相關的東西都不應該再使用泛式型別，而應
該改用Strings，以避免向上轉型和向下轉型帶來的成本。你的目
標是寫出最快產品。請修改MapPerformace.java，用以測試你
這份實作品和HashMap 兩者之間的效能比較。
44. 挑戰題：在Java 源碼庫中找出List 原始碼。將其程式碼複製一
份，並撰寫一個名為intList 的特殊版本。intList 僅持有ints。
思考一下，如果我們要為每一個基本型別都製作一份特殊版本的
List，需要做些什麼事？如果你要製作一個linked list class，有能
力容納所有基本型別，又需要做些什麼事？如果Java 提供參數化
型別(parameterized types)，便是為此問題提供了一種自動化機
制(當然還有其他好處)。
1013
A: 物件的傳遞(Passing)和
回傳(Returning)
如今，當你傳遞某個物件時，你應該已經相當接受一個事
實：你傳遞的其實是個reference。
在許多程式語言中，你可以使用該語言的一般方式來傳遞物件。大多數時
候一切都會十分正常。但似乎總會有些時候你得進行一些不尋常的動作，
事情突然間變得有點複雜(以C++ 來說，變得極為複雜)。Java 也不例
外。重要的是，你必須了解傳遞物件並加以操作時，究竟會發生什麼樣的
事。這份附錄將提供一些看法。
如果你先前曾經習慣於某種極具威力的程式語言，那麼，本附錄的另一個
提問方式就是：「Java 有指標嗎？」。某些人宣稱，指標不僅難用，而且
危險，因此是不好的東西；而由於Java 是所有美德與光明之所在，並可卸
下世俗的編程包袱，所以它不可能含有指標那種東西。然而比較精確的說
法是，Java 有指標。是的，Java 之中除了基本型別，每個物件識別名稱都
是指標。但它們的作用是受限的，不僅受編譯器的保護，也受執行期系統
(runtime system)的保護。或者換句話說，Java 有指標，但沒有「指標
運算」。這些正是我之前稱為"references" 的東西，你可以將它們想像為
「安全的指標」，就像小學裡的安全剪刀一樣。不過這種指標有時候效率
不彰，而且令人感到厭煩。
1014 Thinking in Java www.BruceEckel.com
reference 的傳遞
當你將reference 傳入函式，reference 仍然會指向原先所指的同一物件。
以下這個簡單實驗便說明了這一點：
//: appendixa:PassReferences.java
// Passing references around.
public class PassReferences {
static void f(PassReferences h) {
System.out.println("h inside f(): " + h);
}
public static void main(String[] args) {
PassReferences p = new PassReferences();
System.out.println("p inside main(): " + p);
f(p);
}
} ///:~
上述的列印指令中會自動呼叫toString()，而PassReferences 直接繼
承自Object，並未重新定義(覆寫)toString()。因此喚起的是Object
的toString()。此版本會印出物件的class 名稱，以及物件(注意，不是
reference，是實際物件)所在的記憶體位址。輸出結果如下：
p inside main(): PassReferences@1653748
h inside f(): PassReferences@1653748
你可以看到，p 和h 指向同一個物件。將引數傳入函式時，這種傳遞方式
(譯註：pass by reference)的效率遠勝於複製一個新的物件(譯註：
pass by value)。但是這個現象引領我們討論另一個重要議題。
別名(Aliasing)
別名(aliasing)代表的意思是，多個references 被繫結至同一個物件，就
像前例那樣。當某人對該物件進行塗寫動作時，別名就會引發問題。如果
其他reference 的擁有者並不預期該物件值會改變，他們便會對此結果感到
意外。下面這個簡單例子可說明這一點：
Appendix A: Passing & Returning Objects 1015
//: appendixa:Alias1.java
// Aliasing two references to one object.
public class Alias1 {
int i;
Alias1(int ii) { i = ii; }
public static void main(String[] args) {
Alias1 x = new Alias1(7);
Alias1 y = x; // Assign the reference
System.out.println("x: " + x.i);
System.out.println("y: " + y.i);
System.out.println("Incrementing x");
x.i++;
System.out.println("x: " + x.i);
System.out.println("y: " + y.i);
}
} ///:~
以下這一行：
Alias1 y = x; // Assign the reference
產生了新的Alias1 reference，卻未被賦予一個以new 產生的新物件，而
是令它等同於一個原已存在的reference。所以reference x 的內容(也就
是物件x 的位址)被指派給y。因此x 和y 都指向同一個物件。當x 的i
值在以下述句中遞增時：
x.i++;
y 的i 值同受影響。從輸出結果可以觀察出這一點：
x: 7
y: 7
Incrementing x
x: 8
y: 8
一個好的解法就是：不要這麼做；是的，不要在同一個範圍(scope)中產
生一個以上的reference 別名。這會使你的程式碼更容易被理解和除錯。不
過，當你將reference 當做引數(這是Java 的運作方式)，便會自動產生
1016 Thinking in Java www.BruceEckel.com
別名，因為被產生出來的區域性的(local)reference 可以修改外界物件
(此物件在mothed 範圍之外被產生出來)。以下即是一例：
//: appendixa:Alias2.java
// Method calls implicitly alias their
// arguments.
public class Alias2 {
int i;
Alias2(int ii) { i = ii; }
static void f(Alias2 reference) {
reference.i++;
}
public static void main(String[] args) {
Alias2 x = new Alias2(7);
System.out.println("x: " + x.i);
System.out.println("Calling f(x)");
f(x);
System.out.println("x: " + x.i);
}
} ///:~
下面是輸出結果：
x: 7
Calling f(x)
x: 8
這個函式改變了引數內容，也就是外界物件的內容。當這種情況發生，你
得決定這樣的結果對你是否有實質意義- 這是你預期的行為嗎？
一般來說，呼叫一個函式是為了獲得其回傳值，或是為了對呼叫者(某物
件)的狀態進行改變(所謂函式就是：「發送訊息給某物件」的方法)。
通常，呼叫函式很少是為了處理其引數- 該種行為被稱為「為了副作用而
呼叫函式」。因此當你撰寫「會修改引數內容」的函式時，必須清楚告訴
你的使用者，並對該函式的運用以及它可能引發意外的行為提出警告。由
於這些令人困惑的特性及缺點，你最好避免更改引數值。
Appendix A: Passing & Returning Objects 1017
如果你需要在函式被呼叫期間修改引數，而你又不希望修改到外界物件，
那麼你應該在你的函式中製作一份複本以保護外界物件。這正是本附錄的
重點。
製作一個區域性副本(local copies)
讓我做個複習。Java 傳遞的引數皆以reference 形式傳遞。也就是說，當
你傳遞物件時，實際上傳遞的只是指向「存在於函式之外的某個物件」的
reference。所以如果你以該reference 進行任何修改動作，都會修改到外界
物件。此外：
. 引數傳遞過程中會自動產生別名(alias)。
. 沒有區域物件(local objects)，只有區域性的(local)references。
. references 受範圍(scope)的限制，物件則否。
. 物件的壽命從來不是Java 的討論議題(譯註：因為有垃圾回收機制)。
. 沒有任何語言層次上的支援可以防止物件被修改。也就是說沒有任何語言
層次上的支援可以防止別名(alias)造成的負面效應。
如果你只是要讀取物件中的資訊，而不是要加以修改，那麼reference 是最
有效率的一種引數傳遞方式。這很好，而且Java 所賦予的pass by
reference 預設方式也是最有效率的。不過有時候你可能需要將物件視如
「區域物件」一般地對待，這樣你所做的任何更動就只會影響區域內的這
個副本，不會波及外界那個本尊。許多程式語言支援「在函式內自動產生
外界物件副本」的能力1。Java 並不如此，但它允許你獲得這種效果。
1在C 語言中，通常你處理極小的資料，所以預設採用pass-by-value(傳值)。C++ 亦依循
此種形式，但對物件而言pass-by-value 通常不是最有效率的方式，此外在C++ 中撰寫「支
援pass-by-value」的classes，也是個令人頭痛的問題(譯註：我想作者指的是這個class
必須有copy constructor。雖然預設情況下編譯器會自動給你一個，但那只能做淺層拷貝，
無法進行深層拷貝。另，C++也支援pass by reference，唯其型式與pass-by-value 略有差
異)
1018 Thinking in Java www.BruceEckel.com
Pass by value(傳值)
這帶來一個術語上的問題，而其爭論從來沒有停止過。這裡的術語是pass
by value(傳值)，其意義視你對程式運作的理解程度而定。一般來說其
意義是，你會取得你所傳入的物件的區域副本，但真正的問題在於你對
「你所傳入的物件」是怎麼想的。當我們討論pass by value 的意義時，有
兩個涇渭分明的陣營：
1. Java 以by value(傳值)方式來傳遞所有東西。當你傳遞基本型別
的資料(進入函式)，你會得到該資料的一個副本。當你傳遞
reference(進入函式)，你會獲得該reference 的一個副本。因此，
所有東西其實都是以by value 的方式傳遞。當然，這裡的前提是假
設你知道你所傳遞的是reference(而非物件本身)。但是Java 的
設計早已讓你忘記了你所處理的乃是reference(而非物件本身)。
它的設計希望你將reference 視同物件，因為當你呼叫函式時，它會
自動對reference 進行提領(dereference)動作。
2. 面對基本型別的資料，Java 是以值傳遞(這個毫無爭議)，但面對
物件，Java 是以址傳遞(pass by reference)。這是一種「將
reference 視為物件別名」的世界觀，所以你並不會認為你在傳遞
references，而會認為你傳遞的是物件。由於將物件傳入函式時並不
會獲得該物件的區域性副本，所以物件很明顯地並不是以值傳遞。
在Sun 公司內部，似乎有某些支持此種看法的力量，因為有一個
「被保留但未實作出」的關鍵字byvalue。不過，沒有人知道這個
關鍵字是否(或何時)會出現在世人面前。
將這兩個陣營的聲音都表達出來，並且宣稱「這和你如何看待reference 有
關」之後，我會試著規避這個問題。最後我要說，這其實不是那麼重要，
重要的是你要知道pass by reference 會讓呼叫者傳入的物件在非預期情況
下被修改。
物件的克隆(Cloning objects)
譯註：clone 和copy 的意義都是「複製」。但它們的深層意義並不相同。
為加以區分，我把clone 譯為克隆。克隆之於clone，就像拷貝之於copy
一樣，都是一種外來詞。雖然臺灣不流行說「克隆」，但是這個字眼在大
陸是被普遍接受的 。
Appendix A: Passing & Returning Objects 1019
製作某個物件的區域性副本，最有可能的原因是：你即將修改該物件，但
不希望波及呼叫者手上的那一份本尊物件。如果你打算製作區域性副本，
只要使用clone() 即可，它就是基礎類別Object 中定義為protected 的
那個clone()，你得在「想要進行複製動作」的衍生類別中將它覆寫為
public。例如標準程式庫中的class ArrayList 便覆寫了clone()，所以
我們可以呼叫ArrayList clone() 如下：
//: appendixa:Cloning.java
// The clone() operation works for only a few
// items in the standard Java library.
import java.util.*;
class Int {
private int i;
public Int(int ii) { i = ii; }
public void increment() { i++; }
public String toString()
return Integer.toString(i);
}
}
public class Cloning {
public static void main(String[] args) {
ArrayList v = new ArrayList();
for(int i = 0; i < 10; i++ )
v.add(new Int(i));
System.out.println("v: " + v);
ArrayList v2 = (ArrayList)v.clone();
// Increment all v2's elements:
for(Iterator e = v2.iterator();
e.hasNext(); )
((Int)e.next()).increment();
// See if it changed v's elements:
System.out.println("v: " + v);
}
} ///:~
clone() 會回傳一個Object 物件，你得將它轉型為適當型別。上述範例說
明了ArrayList clone() 並不會自動複製ArrayList 所含的每一個物件，
因此原先的ArrayList 和複製後的ArrayList 都指向同一堆物件(譯
註：所謂一堆物件是指list 中的那些元素)。這種作法常被稱為淺層拷貝
1020 Thinking in Java www.BruceEckel.com
(shallow copy)，因為它只會複製物件的表面。實際的物件不但含有這
個「表面」，還加上所有references 所指向的物件(意指那些元素)，以
及所有那些元素所(可能)指向的物件…。這種關係通常被稱為物件網絡
(web of objects。譯註：見p614)。整個龐雜的物件網絡的複製，就是所
謂的深層拷貝(deep copy)。
你可以在輸出結果中觀察淺層拷貝效應。是的，對v2 做的動作波及了v：
v: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
v: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
不對ArrayList 內的所有物件進行clone()，或許是個合理的假設，因為
不能保證那些物件都「可被克隆」(cloneable)2。
賦予class 克隆能力(cloneability)
即使clone() 定義於「萬物之母」Object 中，但並不是每個class 天生都
具有克隆能力3。這似乎違反「base class 函式永遠可為derived classes 所
用」的直覺概念。是的，Java 的克隆行為便和上述直覺概念背道而馳；如
果你希望某個class 擁有克隆能力，你得特地加上一些程式碼，讓克隆機制
起作用。
2這個字的拼法在字典中是找不著的。但是Java 程式庫的確這麼用它。為了減少混淆，我在
這裡如法炮製。
3你好像可以針對這句話寫個反例，像這樣：
public class Cloneit implements Cloneable {
public static void main (String[] args)
throws CloneNotSupportedException {
Cloneit a = new Cloneit();
Cloneit b = (Cloneit)a.clone();
}
}
不過，這是因為main() 是Cloneit 的一個method，因此擁有「呼叫protected base
class method」clone() 的權限，因而可以正常運作。如果你從另一個class 呼叫之，是無
法正確編譯的。
Appendix A: Passing & Returning Objects 1021
利用protected 玩點把戲
為了不讓你所寫的每個class 預設都有克隆能力，clone() 在base class
Object 中被宣告為protected。這不僅意味單純使用(而非繼承)該
class 的用戶端程式在預設情況下無法使用它，也意味你無法透過base
class reference 來呼叫clone()(雖然在某些情況下這可能滿實用的，例如
以多型方式克隆許多Objects)。這種方式其實是在編譯期讓你知道，你
所處理的物件無法被複製。很奇怪的是， Java 標準程式庫的大多數
classes 都是不可克隆的。因此如果你這麼寫：
Integer x = new Integer(1);
x = x.clone();
會在編譯期收到錯誤訊息，告訴你clone() 不可被取用(因為Integer 並
未覆寫它，所以預設為protected 版本)。
不過，只要是在Object derived class 中(噢，所有classes 都如此)，你
便擁有呼叫Object.clone() 的權限，因為它被宣告為protected 而你是
繼承者。那個clone() 的功能十分有限- 它會對derived class object 進行
位元逐一複製動作(bitwise copy)。因此它扮演著共通的複製行為。你可
以視需要將你的clone() 宣告為public，使它可為外界取用。至此，進行
克隆時有兩個關鍵議題：
• 幾乎總是要呼叫super.clone()。
• 將你的clone() 宣告為public。
你或許會希望在更深層的derived classes 中覆寫clone()，否則你的(現
被宣告為public)clone() 會被喚起而其動作可能不正確(儘管由於
Object.clone() 會進行實際的物件複製，導致還是可能有正確行為)。
protected 計倆只能運作一次，在你「第一次繼承不具克隆能力的class
而又希望讓新class 可被克隆」的時候。你的那個class 的所有derived
classes 都可以使用你的clone()，因為Java 無法在繼承過程中降低函式的
存取權限。也就是說一旦某個class 具備克隆能力，那麼它的所有derived
classes 都可以克隆，除非你使用某種機制關閉克隆能力(稍後介紹)。
1022 Thinking in Java www.BruceEckel.com
Cloneable 介面實作
要讓某個物件得到完整的克隆能力，你得做一件事情：實作出Cloneable
interface。這個介面有點奇怪，因為它是空的！
interface Cloneable {}
之所以要實作這個空的interface，不是因為你打算把你的class 向上轉型
為Cloneable 並呼叫其函式。在這裡，interface 的運用被某些人視為一
種"hack" ， 因為它代表了某種原先意圖以外的東西。Cloneable
interface 的實作被視為一種「融入class 型別系統」的標記。
Cloneable interface 的存在有兩個理由。第一，你可能會取得一個「向上
轉型至基礎型別」的reference，而你不知道能否對它進行克隆。這種情況
下你可以使用關鍵字instanceof(第12 章曾經介紹過)，判斷某個
reference 是否指向可被克隆的物件：
if(myReference instanceof Cloneable) // ...
第二個原因是，克隆能力已被混入整個設計中，然而你也許不希望所有類
型的物件都能夠被克隆。Object.clone() 會檢驗某個class 是否實作出
Cloneable，如果沒有，便會擲出CloneNotSupportedExcpetion 異
常。所以一般而言，提供克隆能力的同時，你一定得實作Cloneable。
(譯註：也有人將這種「內容為空，用來標示具有某種性質」的interface
稱為Marker Interface 設計樣式。Cloneable 和java.io.Serializable
皆屬此類)
成功的克隆
一旦了解clone() 的實作細節後，你便可以撰寫可被克隆的classes，因而
得以為它產生區域副本：
//: appendixa:LocalCopy.java
// Creating local copies with clone().
import java.util.*;
class MyObject implements Cloneable {
Appendix A: Passing & Returning Objects 1023
int i;
MyObject(int ii) { i = ii; }
public Object clone() {
Object o = null;
try {
o = super.clone();
} catch(CloneNotSupportedException e) {
System.err.println("MyObject can't clone");
}
return o;
}
public String toString() {
return Integer.toString(i);
}
}
public class LocalCopy {
static MyObject g(MyObject v) {
// Passing a reference, modifies outside object:
v.i++;
return v;
}
static MyObject f(MyObject v) {
v = (MyObject)v.clone(); // Local copy
v.i++;
return v;
}
public static void main(String[] args) {
MyObject a = new MyObject(11);
MyObject b = g(a);
// Testing reference equivalence,
// not object equivalence:
if(a == b)
System.out.println("a == b");
else
System.out.println("a != b");
System.out.println("a = " + a);
System.out.println("b = " + b);
MyObject c = new MyObject(47);
MyObject d = f(c);
if(c == d)
1024 Thinking in Java www.BruceEckel.com
System.out.println("c == d");
else
System.out.println("c != d");
System.out.println("c = " + c);
System.out.println("d = " + d);
}
} ///:~
首先，clone() 必須是可取用的，所以你得將它宣告為public。其次，
clone() 一開始處你應該呼叫base class clone()；這裡所呼叫的clone()
是Object 所定義的那個版本。由於它被宣告為protected，所以Object
derived classes 可以取用，所以你可以呼叫它。
Object.clone() 會知道物件大小，為它配置足夠的記憶體空間，並將舊物
件的內容複製到新物件中。此即所謂「位元逐一複製(bitwise copy)」，
這也是你通常意識並預期的clone() 行為。但是Object.clone() 執行其
動作之前必須先檢查class 是否為Cloneable，也就是說它是否實作了
Cloneable interface。如果沒有，那麼Object.clone() 便會擲出異常
CloneNotSupportedException，表示無法加以克隆。為此，你應該將
super.clone() 呼叫動作擺到try-catch 區塊中，以便捕捉應該永遠不會
出現的異常(因為你的確實作了Cloneable interface)。
在LocalCopy 中，g() 和f() 說明了兩種引數傳遞方式的差異。g() 採用
by reference 傳遞方式，因此會修改外界物件並回傳指向該外界物件的
reference。f() 則對引數進行克隆，因而切斷了與原物件間的關係；接下來
便可進一步做任何它想要做的動作，甚至將新物件的reference 回傳，也不
會影響原物件。請注意下面這行述句，看起來有點奇怪：
v = (MyObject)v.clone();
這正是產生區域副本之處。為了避免你被這種述句迷惑，請千萬記得，這
種頗為奇怪的程式編寫手法在Java 中非常適當，因為每個物件識別名稱實
際上都是references。所以，reference v 被用來克隆(clone())出其所指
物件的複本， 並回傳一個「指向基礎型別Object 」的reference
(Object.clone() 的確是這麼定義的)，我們必須將該基礎型別再轉型為
適當型別。
Appendix A: Passing & Returning Objects 1025
在main() 中執行上述兩個函式，測試兩種引數傳遞方式所引發的不同效
應。輸出如下：
a == b
a = 12
b = 12
c != d
c = 47
d = 48
千萬注意，Java 的相等性(equivalence)測試並不檢查被比較的兩個物件
內容是否相同。運算子== 和!= 只比較references。如果references 所代
表的位址相同，它們就是指向同一個物件，因而被視為相等。所以==
和!= 運算子所檢查的其實是「兩個references 是否是同一個物件的別名
(alias)」！
Object.clone() 的效應
當Object.clone() 被呼叫，實際上究竟發生什麼動作，致使你在自己的
class 中覆寫clone() 時一定得呼叫super.clone() 呢？根類別(也就是
Object)中的clone() 負責產生正確大小的儲存空間，並進行位元逐一複
製動作，將原始物件的內容複製到新物件的儲存空間。也就是說它不僅僅
只是製作出儲存空間並複製一個Object，它實際上還會計算被複製物的精
確大小，並加以複製。由於上述所有動作都由根類別所定義的clone() 執
行，所以你可以猜測這整個程序一定動用了RTTI 機制，用來判斷被複製
的實際物件。透過這種方式，clone() 便可以產出恰當大小的儲存空間，
並對它進行正確的位元逐一複製動作(bitwise copy)。
不論你打算怎麼做，克隆程序的第一個動作正常來說應該就是呼叫
super.clone()，如此才能製作出一個一模一樣的複製品，做為克隆行為
的基礎。而後你便可以執行其他必要動作，完成整個複製程序。
如果想確切知道所謂「其他的必要動作」究竟是什麼，你得確切知道
Object.clone() 為你做了些什麼事。特別是，它是否自動克隆了物件內含
的所有references？下面這個例子主要便是用來檢驗此點：
1026 Thinking in Java www.BruceEckel.com
//: appendixa:Snake.java
// Tests cloning to see if destination
// of references are also cloned.
public class Snake implements Cloneable {
private Snake next;
private char c;
// Value of i == number of segments
Snake(int i, char x) {
c = x;
if(--i > 0)
next = new Snake(i, (char)(x + 1));
}
void increment() {
c++;
if(next != null)
next.increment();
}
public String toString() {
String s = ":" + c;
if(next != null)
s += next.toString();
return s;
}
public Object clone() {
Object o = null;
try {
o = super.clone();
} catch(CloneNotSupportedException e) {
System.err.println("Snake can't clone");
}
return o;
}
public static void main(String[] args) {
Snake s = new Snake(5, 'a');
System.out.println("s = " + s);
Snake s2 = (Snake)s.clone();
System.out.println("s2 = " + s2);
s.increment();
System.out.println(
"after s.increment, s2 = " + s2);
Appendix A: Passing & Returning Objects 1027
}
} ///:~
Snake 由許多段組成，每一段的型別都是Snake。也就是說它是個單鏈
串列(singly linked list)。每一段都以遞迴方式產生：每遞迴產生一個
Snake，就將建構式的第一引數遞減1，直到遞減至0 為止。為了讓每一
段都有一個獨一無二的識別標籤，其第二引數char 會在每次遞迴建構時
遞增1。
increment() 會遞迴地遞增每個識別標籤值，於是你才能夠觀察其改變。
toString() 會遞迴印出每個識別標籤。輸出結果為：
s = :a:b:c:d:e
s2 = :a:b:c:d:e
after s.increment, s2 = :a:c:d:e:f
這表示Object.clone() 只複製了第一段，也就是說它只做淺層拷貝。如
果你希望複製整條蛇，也就是進行深層拷貝，你得在你所覆寫的clone()
中執行額外動作。
通常你會在「具備克隆能力的class 」的某個derived class 中呼叫
super.clone()，用以確保所有base class 的行為(含Object.clone())
都會發生。只要對你的物件中的每個reference 都呼叫其clone()，便可達
到這個目的；否則這些references 只會成為原物件的別名(alias)。這和
呼叫建構式的方式是一樣的：先呼叫base class 的建構式，然後是下一個
衍生類別的建構式，依此類推，直到最後一層衍生類別。差別只在於
clone() 並非建構式，所以編譯器沒有為它提供一個自動進行機制。你得
設法自行完成。
克隆一個複合物件(composed object)
當你試著對複合物件進行深層拷貝時，會遭遇某個問題。你得假設成員物
件的clone() 會輪番地在其references 上進行深層拷貝，而且不斷遞迴下
去。這是一個承諾，它實際上代表，如果希望深層拷貝起作用，你得在所
1028 Thinking in Java www.BruceEckel.com
有classes 中控制所有程式碼，或至少得有足夠的知識，認識深層拷貝中的
所有相關classes，以便檢驗它們是否都會正確執行自己的深層拷貝。
下面這個範例說明，進行複合物件的深層拷貝時，你得完成哪些動作：
//: appendixa:DeepCopy.java
// Cloning a composed object.
class DepthReading implements Cloneable {
private double depth;
public DepthReading(double depth)
this.depth = depth;
}
public Object clone() {
Object o = null;
try {
o = super.clone();
} catch(CloneNotSupportedException e) {
e.printStackTrace(System.err);
}
return o;
}
}
class TemperatureReading implements Cloneable {
private long time;
private double temperature;
public TemperatureReading(double temperature) {
time = System.currentTimeMillis();
this.temperature = temperature;
}
public Object clone() {
Object o = null;
try {
o = super.clone();
} catch(CloneNotSupportedException e) {
e.printStackTrace(System.err);
}
return o;
}
}
Appendix A: Passing & Returning Objects 1029
class OceanReading implements Cloneable {
private DepthReading depth;
private TemperatureReading temperature;
public OceanReading(double tdata, double ddata){
temperature = new TemperatureReading(tdata);
depth = new DepthReading(ddata);
}
public Object clone() {
OceanReading o = null;
try {
o = (OceanReading)super.clone();
} catch(CloneNotSupportedException e) {
e.printStackTrace(System.err);
}
// Must clone references:
o.depth = (DepthReading)o.depth.clone();
o.temperature =
(TemperatureReading)o.temperature.clone();
return o; // Upcasts back to Object
}
}
public class DeepCopy {
public static void main(String[] args) {
OceanReading reading =
new OceanReading(33.9, 100.5);
// Now clone it:
OceanReading r =
(OceanReading)reading.clone();
}
} ///:~
DepthReading 和TemperatureReader 極類似；兩者都只含基礎類型
資料。因此clone() 十分簡單：呼叫super.clone() 並回傳結果。請注意
這兩個classes 的clone() 一模一樣。
OceanReading 由DepthReading 物件和TemperatureReader 物件
組成。為了進行深層拷貝，其clone() 必須克隆「OceanReading 內的
所有references」。為了完成這個任務，super.clone() 的傳回結果必須
1030 Thinking in Java www.BruceEckel.com
被轉型為OceanReading(這樣你才能夠取用references 的depth 和
temperature)。
對ArrayList 進行深層拷貝
讓我們回頭看看本附錄先前的ArrayList 實例。這一次我讓Int2 class 變
成為「可克隆」(cloneable)，於是可對ArrayList 進行深層拷貝：
//: appendixa:AddingClone.java
// You must go through a few gyrations
// to add cloning to your own class.
import java.util.*;
class Int2 implements Cloneable {
private int i;
public Int2(int ii) { i = ii; }
public void increment() { i++; }
public String toString() {
return Integer.toString(i);
}
public Object clone() {
Object o = null;
try {
o = super.clone();
} catch(CloneNotSupportedException e) {
System.err.println("Int2 can't clone");
}
return o;
}
}
// Once it's cloneable, inheritance
// doesn't remove cloneability:
class Int3 extends Int2 {
private int j; // Automatically duplicated
public Int3(int i) { super(i); }
}
public class AddingClone {
public static void main(String[] args) {
Appendix A: Passing & Returning Objects 1031
Int2 x = new Int2(10);
Int2 x2 = (Int2)x.clone();
x2.increment();
System.out.println(
"x = " + x + ", x2 = " + x2);
// Anything inherited is also cloneable:
Int3 x3 = new Int3(7);
x3 = (Int3)x3.clone();
ArrayList v = new ArrayList();
for(int i = 0; i < 10; i++ )
v.add(new Int2(i));
System.out.println("v: " + v);
ArrayList v2 = (ArrayList)v.clone();
// Now clone each element:
for(int i = 0; i < v.size(); i++)
v2.set(i, ((Int2)v2.get(i)).clone());
// Increment all v2's elements:
for(Iterator e = v2.iterator();
e.hasNext(); )
((Int2)e.next()).increment();
// See if it changed v's elements:
System.out.println("v: " + v);
System.out.println("v2: " + v2);
}
} ///:~
Int3 繼承自Int2，而且加入了新的基礎型成員int j。你可能會以為你得
再覆寫clone() 以確保j 會被複製，但事實並非如此。當Int2 clone() 因
Int3 clone() 而被喚起，它會呼叫Object.clone()，而Object.clone()
會判斷它所處理的是Int3，於是複製Int3 物件中的所有位元。只要你沒
有加入任何需要被克隆的references，呼叫Object.clone() 一次，就可以
完成所有必要複製- 不論clone() 定義點位於階層體系中多深的位置。
你可以看到，對ArrayList 進行深層拷貝需要哪些動作：在ArrayList
被克隆後，你得逐一走訪ArrayList 所指的每一個物件，並逐一克隆。如
果你對HashMap 進行深層拷貝，也需要類似的舉動。
1032 Thinking in Java www.BruceEckel.com
這個例子的其他部份用來顯示克隆結果。一旦物件被克隆，你便可以改變
它而不波及原物件。
透過serialization 進行深層拷貝
當你思考Java object serialization(第11 介紹過)時，你可能會觀察到，
某個物件被次第寫出(serialized)而後再被反向讀回(deserialized)，事
實上就是被克隆了一份。
那麼，為什麼不利用serialization 執行深層拷貝呢？以下這個例子透過執
行時間的計算，對兩種作法進行比較：
//: appendixa:Compete.java
import java.io.*;
class Thing1 implements Serializable {}
class Thing2 implements Serializable {
Thing1 o1 = new Thing1(); // 譯註：複合
}
class Thing3 implements Cloneable {
public Object clone() {
Object o = null;
try {
o = super.clone();
} catch(CloneNotSupportedException e) {
System.err.println("Thing3 can't clone");
}
return o;
}
}
class Thing4 implements Cloneable {
Thing3 o3 = new Thing3(); // 譯註：複合
public Object clone() {
Thing4 o = null;
try {
o = (Thing4)super.clone();
} catch(CloneNotSupportedException e) {
System.err.println("Thing4 can't clone");
Appendix A: Passing & Returning Objects 1033
}
// Clone the field, too:
o.o3 = (Thing3)o3.clone();
return o;
}
}
public class Compete {
static final int SIZE = 5000;
public static void main(String[] args)
throws Exception {
Thing2[] a = new Thing2[SIZE];
for(int i = 0; i < a.length; i++)
a[i] = new Thing2();
Thing4[] b = new Thing4[SIZE];
for(int i = 0; i < b.length; i++)
b[i] = new Thing4();
long t1 = System.currentTimeMillis();
ByteArrayOutputStream buf =
new ByteArrayOutputStream();
ObjectOutputStream o =
new ObjectOutputStream(buf);
for(int i = 0; i < a.length; i++)
o.writeObject(a[i]);
// Now get copies:
ObjectInputStream in =
new ObjectInputStream(
new ByteArrayInputStream(
buf.toByteArray()));
Thing2[] c = new Thing2[SIZE];
for(int i = 0; i < c.length; i++)
c[i] = (Thing2)in.readObject();
long t2 = System.currentTimeMillis();
System.out.println(
"Duplication via serialization: " +
(t2 - t1) + " Milliseconds");
// Now try cloning:
t1 = System.currentTimeMillis();
Thing4[] d = new Thing4[SIZE];
for(int i = 0; i < d.length; i++)
d[i] = (Thing4)b[i].clone();
1034 Thinking in Java www.BruceEckel.com
t2 = System.currentTimeMillis();
System.out.println(
"Duplication via cloning: " +
(t2 - t1) + " Milliseconds");
}
} ///:~
Thing2 和Thing4 都含有成員物件(譯註：也就是說他們都是複合物
件)，所以會進行某種深層拷貝動作。有趣的是，雖然很容易產生
Serializable classes，但複製它們時卻需要更多勞動。而cloning(複
製)雖然一開始需要花費許多力氣設定class，實際的物件複製行動卻簡單
得多。程式執行結果正說明了這一點。以下是程式執行三次的各自結果：
Duplication via serialization: 940 Milliseconds
Duplication via cloning: 50 Milliseconds
Duplication via serialization: 710 Milliseconds
Duplication via cloning: 60 Milliseconds
Duplication via serialization: 770 Milliseconds
Duplication via cloning: 50 Milliseconds
Serialization(次第讀寫)和cloning(克隆)之間有著極大的效率差異。
此外你也應該注意，serialization 所花費的時間似乎變動極大，cloning 則
較為穩定。
將克隆能力加到繼承體系的更下層
當你撰寫新的class 並衍生自Object，Object 在預設情況下不具克隆能力
(下一節便會看到)。如果你不自行為你的class 賦予克隆能力，它便沒有
這份能力。不過你可以在繼承體系的任一層加入克隆能力，那麼該層之下
的每一層就都變成可克隆了，像這樣：
//: appendixa:HorrorFlick.java
// You can insert Cloneability
// at any level of inheritance.
import java.util.*;
class Person {}
Appendix A: Passing & Returning Objects 1035
class Hero extends Person {}
class Scientist extends Person
implements Cloneable {
public Object clone() {
try {
return super.clone();
} catch(CloneNotSupportedException e) {
// this should never happen:
// It's Cloneable already!
throw new InternalError();
}
}
}
class MadScientist extends Scientist {}
public class HorrorFlick {
public static void main(String[] args) {
Person p = new Person();
Hero h = new Hero();
Scientist s = new Scientist();
MadScientist m = new MadScientist();
// p = (Person)p.clone(); // Compile error
// h = (Hero)h.clone(); // Compile error
s = (Scientist)s.clone();
m = (MadScientist)m.clone();
}
} ///:~
加入克隆能力之前，編譯器會阻止你的克隆行為。克隆能力被加至
Scientist 後，Scientist 及其衍生類別便都帶有克隆能力。
為什麼要有這種奇怪的設計？
上述這些看起來像個奇怪的體制，是嗎？是的，它本來就怪。你可能會懷
疑，為什麼要以這種方式進行呢？這種設計背後的意涵又是什麼呢？
最早的Java 是為了用來控制硬體設備，當時絕對沒有考量到Internet。在
類似Java 這樣的一般性程式語言中，讓程式員能夠克隆物件似乎是很合理
1036 Thinking in Java www.BruceEckel.com
的。因此clone() 被放在根類別Object 中，但當時它被宣告為public，
所以你無論怎樣都可以克隆任一個物件。這似乎是最有彈性的方式，但它
最終損害了什麼呢？
唔，當Java 被視為終極的Internet 程式語言時，局勢有所改變。突然間
Java 得考慮安全問題，這些問題和物件的使用有關：你不會希望每個人都
有能力克隆你希望保密的物件吧？所以你看到了，有許多補救措施套用在
原先簡單直覺的架構上：clone() 如今在Object 中成了protected、你
得覆寫clone() 並實作Cloneable、然後你得處理異常。
只有當你呼叫Object clone() 時，Cloneable interface 才有用處。因為
Object clone() 會於執行期檢查你的class 是否實作出Cloneable。不
過，基於一致性考量(而且Cloneable 不過就是個空的interface)，你
無論如何還是應該實作它。
克隆能力(cloneability)的控制
你可能會聯想到，如果要移除克隆能力，只需將clone() 宣告為private
就好了。但這其實行不通，因為你無法在derived class 中降低base class
函式的存取權限。所以事實並非你想像的那麼簡單。人們終究需要控制某
個物件的克隆能力。現實中你可以採取許多不同的態度：
1. 漠不關心。不進行任何克隆相關動作，這意味你的class 無法被克隆
(cloned)，但其derived classes 可以加入克隆能力(如果它想要
的話)。只有當預設的Object.clone() 能夠合理處理你的class 內
的所有資料欄位時，這一點才適用。
2. 支援clone()。實作Cloneable 並覆寫clone()。覆寫clone() 時
應該呼叫super.clone() 並捕捉所有異常(那麼你覆寫的clone()
就不會擲出任何異常)。
Appendix A: Passing & Returning Objects 1037
3. 有條件地支援克隆(cloning)。如果你的class(例如各種容器)持
有的references 指向一些可能(或可能不)具有克隆能力的物件，
那麼你的clone() 應該試著克隆每一個「你所持有的references」
的所指物件，並在它們擲出異常時直接將異常丟回給程式員。舉個
例子，有一種特別的ArrayList 能夠克隆它所持有的所有物件，當
你撰寫此類ArrayList 時，你不知道用戶端程式員可能會把什麼樣
類型的物件放進來，所以你不知道它們是否可被克隆。
4. 不實作Cloneable，但以protected 方式覆寫clone()，使所有欄
位都能被正確複製。透過這種方式，所有繼承自你的這個class 的人
都可以覆寫clone()，並且呼叫super.clone() 獲得正確的拷貝行
為。請注意，你的clone() 可以(並應該)呼叫super.clone()，
即使super.clone() 預期的是個Cloneable 物件(如果不是這
樣，它會擲出異常)。沒有人能夠直接於你所撰寫的class 物件中呼
叫clone()，只能夠透過derived class(如果它想正確運作，得實
作Cloneable 才行)加以呼叫。
5. 嘗試阻止克隆動作：不實作Cloneable，並覆寫clone() 使它擲出
異常。你的這個class 的derived classes 都必須在它們自己的
clone() 中呼叫super.clone()，這個方法才行得通。否則程式員
還是可以規避這個方法。
6. 將你的class 宣告為final，防止克隆動作發生。如果clone() 並未
被你的這個class 的父類別(或祖先類別)覆寫，那就沒辦法這麼
做。如果它在上層類別中被覆寫了，那麼請再次覆寫，並宣告有可
能擲出CloneNotSupportedException。將這個class 宣告為
final 是唯一可以保證「克隆動作不會發生」的作法。此外，在處理
保密性物件或必須控制產出物件的個數時，你應該將所有建構式都
宣告為private，並提供一個(或以上)產出物件的函式。透過這
種方式，這些函式就可以限制產出的物件個數，以及它們的產出條
件。(你可以從www.BruceEckel.com 下載《Thinking in Patterns
with Java》，其中介紹了一個例子：singleton 設計樣式)
1038 Thinking in Java www.BruceEckel.com
下例示範各種方法，用來實作克隆(cloning)機能，或關閉繼承體系下層
的克隆能力：
//: appendixa:CheckCloneable.java
// Checking to see if a reference can be cloned.
// Can't clone this because it doesn't
// override clone():
class Ordinary {}
// Overrides clone, but doesn't implement
// Cloneable:
class WrongClone extends Ordinary {
public Object clone()
throws CloneNotSupportedException {
return super.clone(); // Throws exception
}
}
// Does all the right things for cloning:
class IsCloneable extends Ordinary
implements Cloneable {
public Object clone()
throws CloneNotSupportedException {
return super.clone();
}
}
// Turn off cloning by throwing the exception:
class NoMore extends IsCloneable {
public Object clone()
throws CloneNotSupportedException {
throw new CloneNotSupportedException();
}
}
class TryMore extends NoMore {
public Object clone()
throws CloneNotSupportedException {
// Calls NoMore.clone(), throws exception:
return super.clone();
Appendix A: Passing & Returning Objects 1039
}
}
class BackOn extends NoMore {
private BackOn duplicate(BackOn b) {
// Somehow make a copy of b
// and return that copy. This is a dummy
// copy, just to make the point:
return new BackOn();
}
public Object clone() {
// Doesn't call NoMore.clone():
return duplicate(this);
}
}
// Can't inherit from this, so can't override
// the clone method like in BackOn:
final class ReallyNoMore extends NoMore {}
public class CheckCloneable {
static Ordinary tryToClone(Ordinary ord) {
String id = ord.getClass().getName();
Ordinary x = null;
if(ord instanceof Cloneable) {
try {
System.out.println("Attempting " + id);
x = (Ordinary)((IsCloneable)ord).clone();
System.out.println("Cloned " + id);
} catch(CloneNotSupportedException e) {
System.err.println("Could not clone "+id);
}
}
return x;
}
public static void main(String[] args) {
// Upcasting:
Ordinary[] ord =
new IsCloneable(),
new WrongClone(),
new NoMore(),
1040 Thinking in Java www.BruceEckel.com
new TryMore(),
new BackOn(),
new ReallyNoMore(),
};
Ordinary x = new Ordinary();
// This won't compile, since clone() is
// protected in Object:
//! x = (Ordinary)x.clone();
// tryToClone() checks first to see if
// a class implements Cloneable:
for(int i = 0; i < ord.length; i++)
tryToClone(ord[i]);
}
} ///:~
Ordinary 代表我們在本書中常看到的classes 類型：不支援但也不阻止克
隆。不過如果你取得一個Ordinary object reference，而它被向上轉型
時，你便無法知道它是否可被克隆。
WrongClone 示範錯誤的克隆機制( cloning ) 實作方式。它覆寫
Object.clone()，並將之宣告為public，卻未實作出Cloneable，所以
當super.clone() 被呼叫時(引發對Object.clone() 的呼叫)，便會擲
出CloneNotSupportedException，導致無法進行克隆。
在IsCloneable 中，你可以看到它的克隆動作完全正確：覆寫了clone()
並實作出Cloneable。不過這個clone() 和本例稍後的其他函式都沒有捕
捉CloneNotSupportedException，而是將它傳給呼叫者，因此呼叫者
必須在try-catch 區段中包覆它。通常你應該在自己的clone() 中捕捉
CloneNotSupportedException，而不是將它傳出。本例這種作法純粹
是為了教育意義。
Class NoMore 試圖採用Java 設計者所希望的方式關閉克隆能力：在
derived class clone() 中擲出CloneNotSupportedException 。
TryMore clone() 會適當呼叫super.clone() ( 本例將是
NoMore.clone())，於是擲出異常，阻止克隆發生。
Appendix A: Passing & Returning Objects 1041
如果程式員在覆寫的clone() 中不呼叫super.clone()，會發生什麼事
呢？你可以在BackOn 中看到可能發生的事情。這個class 會使用另一個
函式- duplicate() - 來製作目前物件的副本：在clone() 中呼叫
duplicate() 而不呼叫super.clone()。異常永遠不會被擲出，而新類別
擁有克隆能力。你無法藉由擲出異常的方式來阻止他人製作出擁有克隆能
力的class。唯一能夠達此目的的方法顯示於ReallyNoMore 身上。這個
class 被宣告為final，因此無法被繼承。這意味如果clone() 於final
class 中擲出異常，它將無法因繼承而被衍生類別修改(覆寫)，因而保證
無法克隆。要知道，你無法在繼承體系的任意一層呼叫Object.clone()，
你只能呼叫super.clone()。因此如果你的物件涉及安全性，你應該會希
望將這些物件宣告為final。
你在CheckCloneable 中看到的第一個函式是tryToClone()。它接受任
何Ordinary 物件，並以instanceof 檢查此物件是否可以克隆。如果
是，便將該物件轉型為IsCloneable，然後呼叫其clone() 並將結果轉回
Ordinary，捕捉所有被擲出的異常。請注意，這裡使用執行期辨識機制
(請參考第12 章)印出class 名稱。
main() 會產生不同類型的Ordinary 物件，並將它們向上轉型放入
Ordinary 陣列。之後的前兩行程式碼會產生出一個平常的Ordinary 物
件並嘗試克隆它。不過這段程式碼無法正確編譯，因為clone() 是Object
的protected 函式。程式碼的其餘部份會依序走訪陣列中的元素，並試著
克隆每個物件，最後逐一回報每個物件究竟是克隆成功或失敗。輸出結果
為：
Attempting IsCloneable
Cloned IsCloneable
Attempting NoMore
Could not clone NoMore
Attempting TryMore
Could not clone TryMore
Attempting BackOn
Cloned BackOn
Attempting ReallyNoMore
Could not clone ReallyNoMore
1042 Thinking in Java www.BruceEckel.com
總的來說，如果你希望某個class 可被克隆，你應該：
1. 實作Cloneable interface。
2. 覆寫clone()。
3. 於你的clone() 中呼叫super.clone()。
4. 於你的clone() 中捕捉異常。
這樣可以得到最合宜的結果。
copy 建構式
克隆機制(cloning)的建立似乎是個過於複雜的程序，似乎應該有其他替
代方案。你可能會想到一個方法(尤其如果你曾經是C++ 程式員)，那便
是撰寫一種特殊的建構式，其職責便是進行物件的複製。在C++中，這種
建構式被稱為copy 建構式。這看起來似乎是個明顯的解法，事實上這個方
法行不通。以下即為一例：
//: appendixa:CopyConstructor.java
// A constructor for copying an object of the same
// type, as an attempt to create a local copy.
class FruitQualities {
private int weight;
private int color;
private int firmness;
private int ripeness;
private int smell;
// etc.
FruitQualities() { // Default constructor
// do something meaningful...
}
// Other constructors:
// ...
// Copy constructor:
FruitQualities(FruitQualities f) {
weight = f.weight;
color = f.color;
Appendix A: Passing & Returning Objects 1043
firmness = f.firmness;
ripeness = f.ripeness;
smell = f.smell;
// etc.
}
}
class Seed {
// Members...
Seed() { /* Default constructor */ }
Seed(Seed s) { /* Copy constructor */ }
}
class Fruit {
private FruitQualities fq;
private int seeds;
private Seed[] s;
Fruit(FruitQualities q, int seedCount)
fq = q;
seeds = seedCount;
s = new Seed[seeds];
for(int i = 0; i < seeds; i++)
s[i] = new Seed();
}
// Other constructors:
// ...
// Copy constructor:
Fruit(Fruit f) {
fq = new FruitQualities(f.fq);
seeds = f.seeds;
// Call all Seed copy-constructors:
for(int i = 0; i < seeds; i++)
s[i] = new Seed(f.s[i]);
// Other copy-construction activities...
}
// To allow derived constructors (or other
// methods) to put in different qualities:
protected void addQualities(FruitQualities q) {
fq = q;
}
protected FruitQualities getQualities() {
1044 Thinking in Java www.BruceEckel.com
return fq;
}
}
class Tomato extends Fruit {
Tomato() {
super(new FruitQualities(), 100);
}
Tomato(Tomato t) { // Copy-constructor
super(t); // Upcast for base copy-constructor
// Other copy-construction activities...
}
}
class ZebraQualities extends FruitQualities {
private int stripedness;
ZebraQualities() { // Default constructor
// do something meaningful...
}
ZebraQualities(ZebraQualities z) {
super(z);
stripedness = z.stripedness;
}
}
class GreenZebra extends Tomato {
GreenZebra() {
addQualities(new ZebraQualities());
}
GreenZebra(GreenZebra g) {
super(g); // Calls Tomato(Tomato)
// Restore the right qualities:
addQualities(new ZebraQualities());
}
void evaluate() {
ZebraQualities zq =
(ZebraQualities)getQualities();
// Do something with the qualities
// ...
}
}
Appendix A: Passing & Returning Objects 1045
public class CopyConstructor {
public static void ripen(Tomato t) {
// Use the "copy constructor":
t = new Tomato(t);
System.out.println("In ripen, t is a " +
t.getClass().getName());
}
public static void slice(Fruit f) {
f = new Fruit(f); // Hmmm... will this work?
System.out.println("In slice, f is a " +
f.getClass().getName());
}
public static void main(String[] args) {
Tomato tomato = new Tomato();
ripen(tomato); // OK
slice(tomato); // OOPS!
GreenZebra g = new GreenZebra();
ripen(g); // OOPS!
slice(g); // OOPS!
g.evaluate();
}
} ///:~
乍看之下這似乎有點奇怪。當然，水果擁有一些特性，可是為什麼不直接
將代表這些特性的資料成員放到Fruit class 中呢？有兩個可能原因。第一
個原因是，你可能希望將來能夠很輕易地新增或改變這些特性。請注意，
Fruit 擁有protected addQualities() 俾使derived class 得以那麼做。
(也許你會認為合理的作法是讓Fruit 擁有一個protected 建構式並在其
中接受一個FruitQualities 引數。但因為建構式不會被繼承，所以在第
二層或更下層的classes 中無法運用)。將水果特性擺到另一個class 中，
你就有了比較大的彈性，甚至可以在某個Fruit 物件存活期間改變這些特
性。
將FruitQualities 設計為獨立物件的第二個原因是，如果你想加入新特
性，或是想透過繼承或多型來改變其行為，你就會想要這麼做。請注意，
對GreenZebra 來說(這是一種番茄品種，我已栽培好一陣子，現在長得
極好)，其建構式會呼叫addQualities() 並將ZebraQualities 物件傳
1046 Thinking in Java www.BruceEckel.com
入，後者繼承FruitQualities，可被附於base class 的FruitQualities
reference 中。當然，當GreenZebra 運用FruitQualities 時，它得將
FruitQualities 向下轉型至正確型別(就像evaulate() 那樣)，不過它
總是會知道，正確的型別是ZebraQualties。
你會看到程式裡有個Seed class，Fruit(按定義將帶著它自己的種子)4
則含有一個Seed 陣列。
最後，請注意每個class 都擁有copy 建構式，而每個copy 建構式都必須
負責呼叫base class 和成員物件的copy 建構式，以進行深層拷貝。class
CopyConstructor 測試了copy 建構式：由ripen() 接收一個Tomato
引數，並為它完成一個拷貝建構(copy construction)，複製該物件：
t = new Tomato(t);
slice() 接收更一般化的Fruit 物件，並且也加以複製：
f = new Fruit(f);
main() 以各種不同類型的Fruit 對此進行測試。以下為其輸出結果：
In ripen, t is a Tomato
In slice, f is a Fruit
In ripen, t is a Tomato
In slice, f is a Fruit
這就曝露出問題來了。當slice() 內的拷貝建構動作發生在Tomato 身上
時，其結果不再是個Tomato 而僅僅只是個Fruit。它失去了番茄的特
性。此外，當你傳入的是GreenZebra 時，ripen() 和slice() 會分別將
它轉換成Tomato 和Fruit。因此很不幸地，對我們來說，當我們試著在
Java 裡頭製作出某個物件的區域性副本時，拷貝建構法並不適用。
4 除了可憐的鱷梨(avocado)- 此種水果已經被改良成完完全全的「肥厚」。
Appendix A: Passing & Returning Objects 1047
為什麼適用於C++ 卻不適用於Java？
copy 建構式是C++ 的核心部份，因為它會自動產出物件的區域性副本。
然而上例已經證明此法在Java 行不通。為什麼呢？在Java 裡頭，我們操
作的通通是reference，而在C++ 中你可以擁有reference，也可以直接傳
遞物件。當你以by value 方式傳遞物件，該物件就會被複製，這正是C++
copy 建構式的重要用途之一。這種方式在C++ 裡頭一點問題也沒有。你
應該記住，這種方式在Java 裡頭行不通，所以不要用。
唯讀類別(Read-only classes)
雖然clone() 產生的區域性副本在適當情況下得到了我們想要的結果，但
這卻是「強迫程式員(函式開發者)必須擔起責任以免除別名(alias)帶
來負面效應」的一個例子。如果你正在開發某個程式庫，屬於通用性質且
將廣為人所使用，你無法假設你的物件永遠都能夠在適當的地點被克隆，
這種情況下會發生什麼事呢？或者，更可能的情況是，如果為了效率考量
你希望允許別名現象(aliasing)存在，以避免非必要的物件副本，但你又
不希望沾染別名引發的副作用時，又當如何？
有一個方法，那便是產生所謂「恆常物件(immutable objects)」，此種
物件隸屬於唯讀類別(read-only classes)。你可以在class 子句中不定義
任何「會更動物件內部狀態」的函式。這麼一來即使有別名現象
(aliasing)也不會造成影響，因為你只能讀取其內部狀態。所以即使程式
中有許多地方都對同一個物件進行讀取，也不會構成問題。
舉一個「恆常物件」的例子：Java 標準程式庫中所有基本型別的「包覆類
別(wrapper classes)便是。你可能已經察覺到這一點：如果想將int 儲
存於類似ArrayList 的容器中(它只接收Object references)，你可以
為int 包覆一個標準程式庫提供的Integer class：
//: appendixa:ImmutableInteger.java
// The Integer class cannot be changed.
import java.util.*;
public class ImmutableInteger {
1048 Thinking in Java www.BruceEckel.com
public static void main(String[] args) {
ArrayList v = new ArrayList();
for(int i = 0; i < 10; i++)
v.add(new Integer(i));
// But how do you change the int
// inside the Integer?
}
} ///:~
Integer class(以及所有基本型別的包覆類別)都以一種簡單方式來實作
此種恆常性質：它們不具任何「可讓你修改物件內容」的函式。
如果你的確需要一個物件，不但持有某個基本型別，又可被修改，那麼你
就得自己撰寫。幸好這做起來很簡單：
//: appendixa:MutableInteger.java
// A changeable wrapper class.
import java.util.*;
class IntValue
int n;
IntValue(int x) { n = x; }
public String toString()
return Integer.toString(n);
}
}
public class MutableInteger {
public static void main(String[] args) {
ArrayList v = new ArrayList();
for(int i = 0; i < 10; i++)
v.add(new IntValue(i));
System.out.println(v);
for(int i = 0; i < v.size(); i++)
((IntValue)v.get(i)).n++;
System.out.println(v);
}
} ///:~
Appendix A: Passing & Returning Objects 1049
如果「IntVvalue 預設初值為零」(那就不需要建構式)能被接受，而且
不在意其值是否能被印出(那就不需要toString())，那麼它甚至可以更
簡單些：
class IntValue { int n; }
取出元素並將之轉型使用，會造成一點點不便，但那是ArrayList(而非
IntValue)的事情。
撰寫一個唯讀類別(read-only classes)
你可以撰寫自己的唯讀類別，以下即為一例：
//: appendixa:Immutable1.java
// Objects that cannot be modified
// are immune to aliasing.
public class Immutable1 {
private int data;
public Immutable1(int initVal) {
data = initVal;
}
public int read() { return data; }
public boolean nonzero() { return data != 0; }
public Immutable1 quadruple() {
return new Immutable1(data * 4);
}
static void f(Immutable1 i1) {
Immutable1 quad = i1.quadruple();
System.out.println("i1 = " + i1.read());
System.out.println("quad = " + quad.read());
}
public static void main(String[] args) {
Immutable1 x = new Immutable1(47);
System.out.println("x = " + x.read());
f(x);
System.out.println("x = " + x.read());
}
} ///:~
1050 Thinking in Java www.BruceEckel.com
所有資料都被宣告為private，而且你看不到任何可修改資料的public 函
式。實際上會修改物件的函式只有quadruple()，但它會產出新的
Immutable1 物件，不影響原先那一個。
f() 接收Immutable1 物件，並於其上執行各種動作。main() 的輸出說
明x 值並不會被改變。因此我們可對x 物件進行多次別名動作(aliasing)
而不會造成傷害。因為Immutable1 class 的設計可保護物件不受改變。
恆常性(immutability)的缺點
恆常類別一開始似乎可以提供一種優雅解法。但是當你需要修改該型別的
物件時，你得忍受因產生新物件而造成的額外負擔，以及可能更頻繁的垃
圾回收動作。對某些classes 來說這不是問題。但是對另一些classes 而言
(例如String)，這種代價過於昂貴。
解決方法便是撰寫另一個扮演副手的class，它是可修改的。當你需要大量
的修改動作時，你可以切換到那個可修改的class 上，修改結束後再切換為
不可修改的(恆常的)class。
現在我改變上一個例子，示範新的寫法：
//: appendixa:Immutable2.java
// A companion class for making
// changes to immutable objects.
class Mutable {
private int data;
public Mutable(int initVal) {
data = initVal;
}
public Mutable add(int x)
data += x;
return this;
}
public Mutable multiply(int x) {
data *= x;
return this;
}
Appendix A: Passing & Returning Objects 1051
public Immutable2 makeImmutable2() {
return new Immutable2(data);
}
}
public class Immutable2 {
private int data;
public Immutable2(int initVal) {
data = initVal;
}
public int read() { return data; }
public boolean nonzero() { return data != 0; }
public Immutable2 add(int x)
return new Immutable2(data + x);
}
public Immutable2 multiply(int x) {
return new Immutable2(data * x);
}
public Mutable makeMutable() {
return new Mutable(data);
}
public static Immutable2 modify1(Immutable2 y){
Immutable2 val = y.add(12);
val = val.multiply(3);
val = val.add(11);
val = val.multiply(2);
return val;
}
// This produces the same result:
public static Immutable2 modify2(Immutable2 y){
Mutable m = y.makeMutable();
m.add(12).multiply(3).add(11).multiply(2);
return m.makeImmutable2();
}
public static void main(String[] args) {
Immutable2 i2 = new Immutable2(47);
Immutable2 r1 = modify1(i2);
Immutable2 r2 = modify2(i2);
System.out.println("i2 = " + i2.read());
System.out.println("r1 = " + r1.read());
System.out.println("r2 = " + r2.read());
1052 Thinking in Java www.BruceEckel.com
}
} ///:~
Immutable2 內含的一些函式如add() 和multiply()，一如前述，當需
要修改物件時，便會先產生一個物件副本再修改該副本，用以維持物件的
恆常性。扮演副手角色的class 名為Mutable ，也擁有add() 和
multiply()，但它們會對Mutable 物件進行修改，不會製造出副本。此
外，Mutable 有個函式會運用其資料產生一個Immutable2 物件，反之
亦然。
modify1() 和modify2() 這兩個static 函式雖然作法不同但結果相同。
在modify1() 中所有動作皆於Immutable2 class 完成，而且你可以發現
過程中總共產生四個新的Immutable2 物件；每當val 被重新賦值，前
一個物件就成為垃圾。
在modify2() 中你可以看到，第一個動作是依據Immutable2 y 產出
Mutable(這和先前所見呼叫clone() 是一樣的，但這次產生的是不同型
別的物件)。接著使用Mutable 物件來執行許多修改動作，而不需要產
出許多物件。最後再將該物件轉換回Immutable2。這個過程產生了兩個
物件(Mutable 和最後的Immutable2)而不是四個。
當以下情況發生，上述方法十分有用：
1. 你需要恆常物件(immutable objects)，而且…
2. 你常需要進行大量修改，或是…
3. 產生新的恆常物件需要付出昂貴代價。
恆常不變的Strings
考慮下列程式碼：
//: appendixa:Stringer.java
public class Stringer {
static String upcase(String s) {
return s.toUpperCase();
Appendix A: Passing & Returning Objects 1053
}
public static void main(String[] args) {
String q = new String("howdy");
System.out.println(q); // howdy
String qq = upcase(q);
System.out.println(qq); // HOWDY
System.out.println(q); // howdy
}
} ///:~
當q 被傳入upcase() 時，它實際上是q reference 的一個副本。這個
reference 所指物件停置於某實際位置上(譯註：物件本身並沒有產生副
本)。references 被傳遞時會被複製。
觀察upcase()，你會看到，傳入的reference 名為s，而且s 只存活於
upcase() 本體。當upcase() 執行完畢，區域性的s 便被摧毀。upcase()
會傳回結果，也就是原先字串內容全被轉為大寫後的結果。當然，傳回的
是reference 而不是物件本身。事實上被傳回的那個reference 指向新物
件，原先的q 值並未被改變。這樣的動作是怎麼發生的呢？
不明顯的常數(Implicit constants)
如果你這麼寫：
String s = "asdf";
String x = Stringer.upcase(s);
你會希望upcase() 修改其引數值嗎？一般來說答案是否定的，因為對程
式碼讀者來說，通常引數被視為「提供給函式的一些資訊」，而不是「即
將被修改的某個事物」。這是一個很重要的保證，讓程式碼更易於撰寫和
理解。
在C++ 中，這種保證重要到必須加入一個特殊關鍵字const，讓程式員確
保reference(也就是C++ 的pointer 或reference)無法被用來修改原物
件。但這麼一來C++ 程式員就得多花一些力氣並且絕不能忘記在各個必要
地點運用const。這很容易讓人混淆並且遺忘。
1054 Thinking in Java www.BruceEckel.com
重載後的'+'，以及StringBuffer
透過前述技巧，String 物件被設計成具有恆常性。如果你檢視String
class 的線上說明文件(本章稍後有一些摘要)，你會發現class 之內任何
一個函式，如果會修改String 內容，實際上都會產生一個「含有修改結
果」的String 並傳回。原先的String 不會被更動。Java 並沒有類似
C++ const 這樣的性質可讓編譯器支援物件恆常特性。如果你想要這樣的
性質，你得自己處理一些類似String 所做的動作。
由於String 物件是恆常的(immutable)，所以你可以對某個String 產
生任意個別名(alias)。由於它是唯讀的，所以某個reference 不可能修改
「會影響其他references」的什麼東西。唯讀物件漂亮地解決了別名問
題。
如果你有必要修改物件，藉由「產生一個物件，內含修改後的結果」這種
方式，似乎可以解決。不過有些動作是很沒有效率的，例如將作用於
String 物件上的運算子'+' 加以重載， 便是一個例子。「重載」
(overloading)意味當它被用於某個class 時，有額外的意義。(針對
String 而完成的'+' 和'+='，是Java 唯一能夠(被)重載的運算子。Java
不允許程式員重載其他運算子5。
面對String 物件，'+' 讓你能夠將Strings 內容輕鬆串接在一塊：
String s = "abc" + foo + "def" + Integer.toString(47);
5 C++ 允許程式員任意重載運算子。由於這往往是個複雜的過程(請參考《Thinking in
C++ ，2nd edition》第10 章，Prentice-Hall, 2000)，所以Java 設計者認為這是個「不好」
的功能，不應該放到Java 裡頭。它其實沒有差勁到不適合擺到Java 裡頭。而且諷刺得很，
運算子重載在Java 中應該比在C++ 中輕鬆多了。從Python(具有垃圾回收機制和簡單易
行的運算子重載)中可以觀察到這一點。
Appendix A: Passing & Returning Objects 1055
你可以想像它可能的運作方式：String "abc" 可能有個append()，它會
產出新的String 物件，後者含有"abc" 並串接foo 的內容。新的String
物件接著再產生一個新的String 物件，附加"def "，依此類推。
這麼做當然行得通，但這種作法會產生許多String 物件，最終卻只是為了
將它們組成新的String。最後你會得到許多中間產物(String 物件)，
它們還得被垃圾回收機制收回去。我猜想Java 設計者曾經嘗試過這種作法
(軟體設計的第一課：除非你寫了程式親做嘗試，並讓某些機制動起來，
否則永遠不會對系統有任何了解)。我也猜想Java 設計者發現這種作法有
著難以被接受的低效率。
解決辦法便是具恆常性的副手類別(mutable companion class)，類似稍
早前示範的例子。對String 來說，StringBuffer 就是扮演其副手角色。
編譯器會自動產出一個StringBuffer 來評估某些算式，尤其當(重載版
的)運算子+ 和+= 用於String 物件時。下面這個例子展示發生的動作：
//: appendixa:ImmutableStrings.java
// Demonstrating StringBuffer.
public class ImmutableStrings {
public static void main(String[] args) {
String foo = "foo";
String s = "abc" + foo +
"def" + Integer.toString(47);
System.out.println(s);
// The "equivalent" using StringBuffer:
StringBuffer sb =
new StringBuffer("abc"); // Creates String!
sb.append(foo);
sb.append("def"); // Creates String!
sb.append(Integer.toString(47));
System.out.println(sb);
}
} ///:~
當產生String s 時，編譯器所做的事情，效果大約和之後使用sb 所做的
事情一樣：產出StringBuffer 並使用append() 將新字元直接加到
1056 Thinking in Java www.BruceEckel.com
StringBuffer 物件中(而不再是每次都產出一份新物件)。雖然這種作
法較有效率，但每次當你產生諸如"abc" 或"def" 之類以雙引數括住的字串
時，編譯器會將它們轉換為String 物件。所以產出的物件個數，會超過你
的預期。儘管如此StringBuffer 還是能夠提供較好的效率。
String 和StringBuffer
下面是一份簡單說明，對象是String 和StringBuffer 都擁有的函式。或
許你能夠從中體會兩者的互動方式。這個表格並未涵蓋每一個函式，只涵
蓋本討論主題中的重要函式。經過重載的函式會被摘要整理於同一列中。
首先是String class：
函式名稱Arguments(引數),
Overloading(重載)
用途
Constructor 重載：default 建構式、
String、
StringBuffer、
char 陣列、byte 陣列。
產生一個String 物件
length( ) 獲知String 字元個數。
charAt() int 索引獲知String 中某位置上
的字元。
getChars( ),
getBytes( )
來源端的起始和結束位
置，目的端的陣列名
稱，及其起始放置點
(索引)。
將chars 或bytes 複製
到外部陣列。
toCharArray( ) 得到一個char [ ]，內
含String 所有字元
equals( ), equals-
IgnoreCase( )
一個用於比較的
String。
進行兩個Strings 的相
等性測試。
compareTo( ) 一個用於比較的
String。
將本身的String 和傳入
的引數兩者依字典排列
Appendix A: Passing & Returning Objects 1057
函式名稱Arguments(引數),
Overloading(重載)
用途
次序(lexicographical
order)比較結果，傳回
負值、零、或正值。注
意，大小寫有別！
regionMatches( ) 本身這個String 的偏
移位置、另一個
String(引數)及其
偏移位置和比較長度。
重載版本提供了一個
「不分大小寫」的選項
傳回一個boolean，代
表指定的段落是否內容
相符。
startsWith( ) 做為測試標準(是否為
起首)的String。重
載版本提供一個用於引
數身上的起始偏移位
置。
傳回一個boolean，代
表本身字串是否以引數
內容為起首。
endsWith( ) 做為測試標準(是否為
結尾)的String。
傳回一個boolean，代
表本身字串是否以引數
內容為結尾。
indexOf( ),
lastIndexOf( )
重載：char、char 和
起始索引、String、
String 和起始索引。
如果傳入的引數不為
String 所涵蓋，傳回-
1。反之則傳回該引數在
String 中的起始位置。
lastIndexOf() 從末端
反向搜尋。
substring( ) 重載：起始索引、起始
索引和終止索引。
傳回一個新的String，
內含指定的字元(s)。
concat( ) 一個String，將被用
來做為串接內容。
傳回一個新的String，
內含原始字串內容和新
增字串內容。
replace( ) 欲被取代的舊字元、欲
取代的新字元。
傳回一個取代後的新
String。如果條件不
1058 Thinking in Java www.BruceEckel.com
函式名稱Arguments(引數),
Overloading(重載)
用途
符，則傳回舊String。
toLowerCase( )
toUpperCase( )
傳回大小寫更換後的新
String。如果不需變
動，傳回舊String。
trim( ) 傳回移除前後空白字元
後的新String。如果不
需變動，傳回舊String
valueOf( ) 重載：Object、char
[]、char[] 和偏移和
長度，
boolean、char、
int、long、float、
double。
傳回一個String，內含
引數的「字元表述」
(character
representation)
intern( ) 產生唯一一個String，
代表每個獨一無二的字
元序列。
你會發現，每個String 函式在它們改變字串內容時，都小心翼翼地傳回一
個新的String 物件。也請注意，如果字串內容無需更動，那麼該函式便會
直接傳回一個reference 指向原本的String。這種作法可以節省儲存空間
以及非必要的額外負擔。
以下是StringBuffer class：
函式名稱Arguments(引數),
overloading(重載)
用途
Constructor 重載：default 建構式, 欲產
生的緩衝區長度，String 的
來源。
產生一個新的
StringBuffer 物件。
Appendix A: Passing & Returning Objects 1059
toString( ) 根據StringBuffer 產
生一個String 物件。
length( ) StringBuffer 內的字
元個數。
capacity( ) 傳回目前配置的空間大
小。
ensure-
Capacity( )
一個整數，指出需求容量。要求StringBuffer 持
有至少某數量的空間。
setLength( ) 一個整數，用來表示緩衝區
內的字元字串的新長度。
截短或擴展原本的字元
字串。如果是擴展，新
增空間全部填nulls。
charAt( ) 一個整數，用來表示某個元
素位置。
傳回緩衝區某位置上的
char。
setCharAt( ) 一個整數，用來表示某個元
素位置；一個新的char ，
用來放置於該位置上。
修改某位置上的值。
getChars( ) 來源端的起始和結束位置，
目的端的陣列名稱，及其起
始放置點(索引)。
將chars 複製到一個
外部陣列中。注意，並
不像String 那樣有個
getBytes( )。
append( ) 重載：Object, String,
char[], char[]，，，，偏移位置
和長度；另一重載版本：
boolean, char, int, long,
float, double.
引數將被轉換為一個字
串，並附加於目前緩衝
區的尾端。如果必要，
緩衝區會變大。
insert( ) 重載，每一個版本都有第一
引數，用來指示安插起始位
置：Object, String,
char[], boolean, char,
int, long, float, double.
第二引數被轉換為一個
字串，並安插於目前緩
衝區中的安插起始位置
上。如果必要，緩衝區
會變大。
reverse( ) 將緩衝區內的字元全數
逆轉位置。
1060 Thinking in Java www.BruceEckel.com
最常被使用的函式是append()。當編譯器評估含有"+" 和"+=" 的
String 運算式時，便會使用它。insert() 的形式與其類似。兩個函式都會
在緩衝區中進行大量修改而不產生出新物件。
Strings 是特殊的東西
現在，你已經看到了，String class 不只是Java 中的一個普通class。
String 存在許多特殊情況，不僅僅只是一個Java 內建型別。事實上由雙
引號括起的字串都會被編譯器和特殊的重載運算子"+" 和"+=" 轉換為
String。這份附錄還告訴了你其他一些特殊情況：String 透過提供輔助功
能的StringBuffer() 十分小心地維護恆常性(immutability)。
摘要
由於Java 的一切事物都是reference，也由於每個物件都被生成於heap 之
中，當它不再被使用時，會被垃圾回收機制收回，所以改變了物件操作方
式，尤其是在傳遞和回傳物件時。在C 或C++ 裡頭，如果你想在函式內初
始化某一塊儲存空間，你或許會要求使用者將該儲存空間的位址傳入，否
則你就必須為「究竟誰會移除那塊儲存空間」傷腦筋。因此這種函式的介
面和可理解度就比較複雜。在Java 中你完全不需要為了「儲存空間的移
除」或「需要某個物件時它是否存在」等問題而煩惱，因為Java 已經自動
為你處理掉了。你可以在需要物件的時候產生它，並從那個時候開始永遠
都不需要考量物件傳遞責任上的技巧。是的，只要傳遞reference 就好了。
有時候這種方式帶來的簡化不值一哂，但有時候它的影響力十分驚人。
Appendix A: Passing & Returning Objects 1061
所有這些神奇力量，衍生出兩個缺點：
1. 由於額外的記憶體管理動作而付出效率上的代價(雖然可能極輕
微)。而且當程式執行時，總會摻雜些許的不確定性(因為當可用
記憶體不足時，垃圾回收器便會強行介入)。不過對大多數應用程
式而言，好處大過於缺點。程式中特別著重效率的部份，可使用原
生函式(native methods，請參考附錄B)來撰寫。
2. 別名(aliasing)：有時候在非刻意情況下，兩個references 會指向
同一個物件。只有當兩個references 被假設指向同一個明確物件
時，這才會成為問題。這正是你需要多加注意的地方。必要時請對
物件執行clone()，以避免另一個reference 對於非預期的改變感到
驚訝。你也可以撰寫「恆常物件」來提供別名上的效率。此種恆常
物件的所有操作函式都會傳回一個同型(或不同型)物件，但無論
如何不會更改原始物件的內容，因此，任何人即使對原始物件有個
別名，也絕不會遇上物件內容被改變的情況。
某些人認為Java 克隆機制是一種笨拙的設計，並對此感到厭煩，於是實作
出自己的克隆機制6，並且完全不使用Object.clone()。因而規免了實作
Cloneable 和捕捉CloneNotSupportedException 的必要性。這當然
是一種合理的方法，而且由於Java 標準程式庫很少支援clone()，所以這
種方法似乎也很安全。只要你不呼叫Object.clone()，你就不需要實作
Cloneable，也不需要捕捉相關異常，因此這麼做似乎頗能被接受。
6 Doug Lea(他協助我解決這個主題)對我提出了這樣的建議。他說他只不過是為每一個
class 產生一個名為duplicate( ) 的函式，就行了。
1062 Thinking in Java www.BruceEckel.com
練習
某些經過挑選的題目，其解答置於《The Thinking in Java Annotated Solution Guide》電子文件中。
僅需小額費用便可自www.BruceEckel.com.網站取得。
1. 請說明別名(aliasing)的第二個層次。撰寫一個函式，令它接受一
個reference，但並不修改該reference 所指物件的內容。不過這個
函式會呼叫另一個函式並將該reference 傳入，而第二個函式卻會
修改reference 所指物件。
2. 撰寫一個myString class，其中包含一個String 物件，可於建構
式中透過引數來設定初值。加入toString() 和concatenate()。
後者會將String 物件附加於你的內部字串尾端。請為myString
實作clone()。撰寫兩個static 函式，令它們都接收myString
reference x 引數並呼叫x.concatenate("test")。但第二個函式會
先呼叫clone()。請測試這兩個函式並展示其不同的結果。
3. 撰寫一個Battery class，其中內含int 值，代表電池的編碼(獨一
無二的識別名稱)。將它宣告為Cloneable 並為它撰寫一個
toString()。接著撰寫一個Toy class，其內包含一個Battery 陣
列和一個toString()，後者可印出所有Battery 物件。為Toy 撰
寫clone()，由它自動克隆所有Battery 物件。測試方法：克隆
Toy 並列印結果。
4. 修改CheckCloneable.java ， 讓所有clone() 都捕捉
CloneNotSupportedException，而不是直接將異常傳遞給呼叫
者。
5. 運用搭配「可修改之副手類別」(mutable-companion-class)的技
巧，撰寫含有int、double、char 陣列的恆常類別(immutable
class)。
6. 修改Compete.java ， 將更多物件加到Thing2 和Thing4
classes 中，並試著觀察時間和複雜度之間的變化- 是否為單純的
線性關係？或是更複雜？
Appendix A: Passing & Returning Objects 1063
7. 從Snake.java 著手，撰寫Snake 的深層拷貝(deep copy)版
本。
8. 繼承ArrayList，並讓其clone() 執行深層拷貝(deep copy)。
1064 Thinking in Java www.BruceEckel.com
1065
B: Java 原生介面
The Java Native Interface，JNI
這份附錄由Andrea Provaglio(www.AndreProvaglio.com)撰寫，並在
他的允許之下用於此處。
Java 程式語言及其標準API 十分豐富，可堪用來撰寫成熟
的應用程式。但是，在某些特殊情況中，你得呼叫non-
Java 程式碼。例如，如果你想存取作業系統特有的功能、
想要和特殊的硬體設備溝通、想要重複使用過去撰寫的
non-Java 程式碼、或是想要實作極重視時間效率的程式
碼，你就會想呼叫non-Java 程式碼。
想要和non-Java 程式碼銜接，編譯器和虛擬機器必須提供專門的支援才
行。而且還得有額外的工具，將Java 程式碼對應至non-Java 程式碼。
Non-Java 程式碼的呼叫標準，是由JavaSoft 提供的所謂「Java 原生介面
(Java Native Interface，JNI)」，也正是本附錄的介紹內容。這並不是
一份非常深入的論述，甚至某些例子還會假設你已經具備小部分相關觀念
和技術。
JNI 是個頗為豐富的編程介面，它讓你得以於Java 應用程式中呼叫原生函
式(native methods)。JNI 於Java 1.1 被加入，和Java 1.0 的對等機制-
也就是「原生函式介面(Native Method Interface，NMI)」- 維持了某
種程度的相容性。NMI 的設計特質不適用於所有虛擬機制。基於這個原
因，Java 語言的未來版本中可能不會再支援NMI。本處亦不介紹NMI。
目前JNI 的設計只能用來和C 或C++ 所寫成的原生函式(native
methods)相接。透過JNI，你的原生函式可以：
. 產生Java 物件(包括陣列和Strings)，取得並更新Java 物件值。
. 呼叫Java 函式。
1066 Thinking in Java www.BruceEckel.com
. 捕捉、擲出異常(exceptions)
. 載入classes，並取得class 的相關資訊。
. 執行動態時期型別檢驗(run-time type checking)
因此，可在一般Java 程式中對classes 和其物件進行的動作，也皆可於原
生函式中為之。
原生函式(Native method)的調用
讓我們從一個簡單的例子開始。這是一個呼叫原生函式的Java 程式。它會
依序呼叫C 標準程式庫的printf() 函式。
第一個步驟便是撰寫一份Java 程式碼，宣告原生函式和其引數：
//: appendixb:ShowMessage.java
public class ShowMessage {
private native void ShowMessage(String msg);
static {
System.loadLibrary("MsgImpl");
// Linux hack, if you can't get your library
// path set in your environment:
// System.load(
// "/home/bruce/tij2/appendixb/MsgImpl.so");
}
public static void main(String[] args) {
ShowMessage app = new ShowMessage();
app.ShowMessage("Generated with JNI");
}
} ///:~
接續在原生函式宣告式之後的是個static 區段， 其內呼叫
System.loadLibrary() (你其實可以在任何地點呼叫它，但這種安排比
較恰當)。System.loadLibrary() 會將DLL 載入記憶體，並加以連結。
DLL 必須位於你的系統程式庫路徑中。JVM 會自動補上副檔名，副檔名視
平台的不同而異。
Appendix B: The Java Native Interface (JNI) 1067
上述程式碼中你可以看到，呼叫System.load() 的地方被註解掉了。這裡
指定的是個絕對路徑，與環境變數無關。使用環境變數當然比較好，也更
具移植性。但如果你無法得知環境變數，你可以將loadLibrary() 呼叫動
作註解掉，取消對System.load() 的註解，並將路徑改為你自己的目錄。
表頭檔產生器：javah
接下來請編譯你的Java 原始檔。針對你所得到的.class 檔執行javah，
並指定-jni 選項(本書所附原始碼中的makefile 會自動執行該動作)：
javah -jni ShowMessage
javah 會讀取Java class 檔，針對其中每一個原生函式宣告，以C 或C++
標頭檔的型式產生出函式原型宣告。以下便是本例的輸出結果
ShowMessage.h(略加編修以符合書頁編排)：
/* DO NOT EDIT THIS FILE
- it is machine generated */
#include <jni.h>
/* Header for class ShowMessage */
#ifndef _Included_ShowMessage
#define _Included_ShowMessage
#ifdef __cplusplus
extern "C" {
#endif
/*
* Class: ShowMessage
* Method: ShowMessage
* Signature: (Ljava/lang/String;)V
*/
JNIEXPORT void JNICALL
Java_ShowMessage_ShowMessage
(JNIEnv *, jobject, jstring);
#ifdef __cplusplus
}
#endif
#endif
1068 Thinking in Java www.BruceEckel.com
如你所見，透過前處理器指令#ifdef __cplusplus，此檔案可被C 或
C++ 編譯器加以編譯。第一個#include 指令會括入jin.h，那是個標頭
檔， 定義了檔案中其餘部份會用到的各種型別。JNIEXPORT 和
JNICALL 都是巨集，會被展開為平台專有指令。JNIEnv、jobject、
jstring 都是JNI 資料型別的定義，我馬上會為你介紹這些指令。
名稱重整(Name mangling)與
函式標記(function signatures)
JNI 對於原生函式的名稱，規範了一種獨一無二的名稱重整(name
mangling)手法。這很重要，因為這是「虛擬機器將Java 呼叫動作連結至
原生函式」機制的一部份。基本上所有原生函式皆以"Java" 起首，其後跟
著「Java native 宣告」所棲身的class 的名稱，再跟著Java 原生函式名
稱，其間各以底線字元('_')分隔。如果重載(overload)Java 原生函
式，函式標記(signature)便會被附加於名稱之後；你可以在上例的原型
宣告前的註解中，看到原生標記式(native signature)。如果你想獲得名
稱重整和原生函式標記式的進一步資訊，請參考JNI 說明文件。
實作出你自己的DLL
接下來撰寫C 或C++ 原始碼，並在其中含入javah 所產生的表頭檔，並
實作出原生函式。編譯之後會產生一個動態連結程式庫(dynamic link
library, DLL)。以上會因平台的不同而有所不同。例如下列程式碼會被編
譯和連結，在Windows 上產出一個MsgImpl.dll，在Unix/Linux 上產
出一個MsgImpl.so。你可以在本書所附光碟中找到和程式碼置放在一起
的makefile(亦可自www.BruceEckel.com 免費下載)，其中包含上述動
作所需指令。
//: appendixb:MsgImpl.cpp
//# Tested with VC++ & BC++. Include path must
//# be adjusted to find the JNI headers. See
Appendix B: The Java Native Interface (JNI) 1069
//# the makefile for this chapter (in the
//# downloadable source code) for an example.
#include <jni.h>
#include <stdio.h>
#include "ShowMessage.h"
extern "C" JNIEXPORT void JNICALL
Java_ShowMessage_ShowMessage(JNIEnv* env,
jobject, jstring jMsg) {
const char* msg=env->GetStringUTFChars(jMsg,0);
printf("Thinking in Java, JNI: %s\n", msg);
env->ReleaseStringUTFChars(jMsg, msg);
} ///:~
傳入原生函式的那些引數，是原生函式用來和Java 程式溝通的管道。第一
引數的型別為JNIEnv，其中包含所有必要的hook(扣鉤)，讓你得以回
呼(callback)JVM(下一節我會探討這個動作)。第二引數的意義依函式
的類型而有不同。對non-static 函式(如上例)來說，第二引數和C++
的this 指標功用相同，而且類似Java 的this：是個reference，指向原生
函式的呼叫者(某個物件)。對static 函式來說，它是個reference，指向
原生函式的實作者(以某個Class 物件做為代表)。
其餘引數代表的是傳入原生函式的各個Java 物件。基本型別的傳遞也是透
過這種方式，不過卻是採用傳值(by value)的方式。
接下來的數節，我會探討上述程式碼，焦點是如何在原生函式內存取、控
制JVM。
取用JNI 函式：
透過JNIEnv 引數
所謂JNI 函式，就是程式員可於原生函式中用來和JVM溝通的函式。一如
你在上述例中所見，每個JNI 原生函式都收到一個特殊引數(JNIEnv 引
數)做為其第一參數。那是一個指標，指向型別為JNIEnv_ 的一個特殊
的JNI 資料結構。JNI 資料結構中有個元素也是指標，指向JVM 所產生的
1070 Thinking in Java www.BruceEckel.com
陣列， 其內每個元素都是指標， 分別指向各個JNI 函式。提取
(dereference)這些指標後(實際動作很簡單)，便可自原生函式中呼叫
JNI 函式。每個JVM 都提供有自己的JNI 函式實作版本，永遠位於預先定
義好的偏移位置(offset)上。
程式員透過JNIEnv 引數便可取用許多函式。這些函式可以下述分類方式
加以編組：
. 取得版本資訊
. 執行class 和物件相關動作
. 處理指向Java 物件的一些全域性references 和區域性references
. 存取instance fields(譯註：隸屬於物件)和static fields(譯註：隸屬於類
別)
. 呼叫instance 函式(譯註：non-static 函式)和static 函式
. 執行字串動作和陣列動作
. 產生或處理Java 異常
JNI 函式的個數很多，這裡並不一一探討。我會說明這些函式被運用時的
背後基本原理。如果你想獲得更細節的資訊，請參考編譯器附的JNI 說明
文件。
如果你檢視jni.h 表頭檔，你會看到#ifdef __cplusplus 這個前處理器
條件句，它說如果這個檔案被C++ 編譯器編譯，JNIEnv_ 結構體會被定
義為class 形式，其中有許多inline 函式，讓你得以透過簡單、熟悉的語法
來取用JNI 函式。例如前例中的這行C++ 程式碼：
env->ReleaseStringUTFChars(jMsg, msg);
可以以這樣的C 形式被呼叫：
(*env)->ReleaseStringUTFChars(env, jMsg, msg);
Appendix B: The Java Native Interface (JNI) 1071
我想你會注意到，C 形式(當然)更為複雜- 你需要對env 指標進行雙重
提領(deferencing)，而且你得將env 做為第一個引數傳給JNI 函式。本
附錄中的所有例子用的都是C++ 形式。
存取Java Strings
讓我們看看取用JNI 函式的一個例子，請看MsgImpl.cpp 中的程式碼。
在這個程式中，型別為JNIEnv 的引數env 被用來存取Java String。
Java String 的編碼採用Unicode，所以如果你接收String，而且想將它
傳入沒有能力處理Unicode 的函式中(例如printf())，那麼你得先以
JNI 函式GetStringUTFChars() 將它轉換為ASCII 字元。這個函式會接
收Java String 並將它轉換成UTF-8 字元。(一個用以儲存ASCII 值的
UTF-8 字元，寬度為8-bits，而如果用以儲存Unicode，寬度為16-bits。
如果原始字串全由ASCII 組成，那麼所得結果也會是個ASCII。)
GetStringUTFChars() 是JNIEnv 中的成員函式之一。若想取用JNI
函式，我們可以使用C++ 語法透過指標呼叫成員函式。這種形式可以取用
所有JNI 函式。
傳遞和運用Java 物件
前一個例子中我將String 傳入原生函式。你也可以將你自己撰寫的Java
物件傳入原生函式，並於後者之內存取接收到的物件的各個資料成員
(fields)和函式(methods)。
如果想傳遞物件，請在宣告原生函式時使用一般Java 語法。下例中的
MyJavaClass 擁有一個public 資料成員和一個public 函式。
UserObjects 則宣告一個原生函式，其中接收一個MyJavaClass 物件。
為了觀察原生函式能否操控其引數，這個程式將引數的public 資料成員設
值，然後呼叫原生函式，然後印出public 資料成員之值。
1072 Thinking in Java www.BruceEckel.com
//: appendixb:UseObjects.java
class MyJavaClass {
public int aValue;
public void divByTwo() { aValue /= 2; }
}
public class UseObjects {
private native void
changeObject(MyJavaClass obj);
static {
System.loadLibrary("UseObjImpl");
// Linux hack, if you can't get your library
// path set in your environment:
// System.load(
//"/home/bruce/tij2/appendixb/UseObjImpl.so");
}
public static void main(String[] args) {
UseObjects app = new UseObjects();
MyJavaClass anObj = new MyJavaClass();
anObj.aValue = 2;
app.changeObject(anObj);
System.out.println("Java: " + anObj.aValue);
}
} ///:~
編譯並執行javah 後，你便可以開始實作原生函式。下例取得資料成員ID
和函式ID 後，透過JNI 函式加以存取。
//: appendixb:UseObjImpl.cpp
//# Tested with VC++ & BC++. Include path must
//# be adjusted to find the JNI headers. See
//# the makefile for this chapter (in the
//# downloadable source code) for an example.
#include <jni.h>
extern "C" JNIEXPORT void JNICALL
Java_UseObjects_changeObject(
JNIEnv* env, jobject, jobject obj) {
jclass cls = env->GetObjectClass(obj);
jfieldID fid = env->GetFieldID(
cls, "aValue", "I");
jmethodID mid = env->GetMethodID(
Appendix B: The Java Native Interface (JNI) 1073
cls, "divByTwo", "()V");
int value = env->GetIntField(obj, fid);
printf("Native: %d\n", value);
env->SetIntField(obj, fid, 6);
env->CallVoidMethod(obj, mid);
value = env->GetIntField(obj, fid);
printf("Native: %d\n", value);
} ///:~
C++ 函式內忽略this 指標；它所接收的jobject，是「Java 程式碼傳遞過
來的Java object reference」在原生端(native side)的形式。我們很單純
地取得aValue、列印其值、改變其值、呼叫jobject 的divByTwo()、
再次列印其值。
如果想存取Java 資料成員或函式， 你得先使用GetFieldID() 或
GetMethodID() 分別取得資料成員和函式的識別碼。這兩個函式接收(1)
class object、(2) 一個字串，內含元素名稱、(3) 一個字串，代表型別相關
資訊：要不就是資料成員的型別，要不就是函式的標記資訊(JNI 說明文
件提供有更詳細的資訊)。你可運用這些函式回傳的識別碼來存取你所要
的元素。這個方法似乎像在繞路，但畢竟你的原生函式並不知道Java 物件
的內部佈局，所以它必須透過JVM 回傳的索引值來存取資料成員和函式
s。這就允許不同的JVMs 擁有不同的物件佈局，卻不致對你的原生函式造
成影響。
如果你執行了Java 程式，你會發現從Java 端傳入的物件會被原生函式改
變。但是傳遞的東西實際上是什麼呢？是個C++ pointer 還是個Java
reference 呢？而且，在原生函式呼叫過程中，垃圾回收器會採取怎樣的處
理方式呢？
當原生函式運行，垃圾回收器持續運作。但是這個機制保證在原生函式被
呼叫過程中，你的物件不會被垃圾回收機制撿走。為了確保此點，呼叫原
生函式之前程式會先產出一個local references，並於呼叫之後立刻摧毀。
由於其壽命長於整個原生函式呼叫過程，所以你可以確定在原生函式執行
期間，這些物件都可被合法使用。
1074 Thinking in Java www.BruceEckel.com
由於每次原生函式被呼叫前都會產生上述references，並於呼叫後被摧
毀，所以你無法在你的原生函式中以static 方式製作區域性副本。如果你
所需的reference，得在不同的函式叫用動作中持續存活，你得使用全域性
reference。然而全域性reference 並不由JVM 產生，不過你可以呼叫特定
的JNI 函式來產生代表某個區域性reference 的全域性reference。當你產
生全域性reference，你就得負責處理它所指向的物件的生命。全域性
reference(及其所指物件)會持續存活於記憶體中，直到程式員透過適當
的JNI 函式(類似C malloc() 和free())加以釋放。
JNI 和Java 異常
透過JNI 可擲出或捕捉Java 異常，並可列印其值或重擲，這些和在Java
程式中都一樣。但程式員有權決定是否呼叫特定的JNI 函式來處理異常。
以下是一些用來異常處理的JNI 函式：
. Throw( )
擲出既有的異常物件。用於原生函式中重擲異常。
. ThrowNew( )
產生新的異常物件並擲出。
. ExceptionOccurred( )
判斷某個異常是否已被擲出且尚未被清除。
. ExceptionDescribe( )
列印異常及堆疊追蹤結果(stack trace)。
. ExceptionClear( )
清除懸而未決(pending)的異常。
. FatalError( )
引發一個致命錯誤(fatal error)。不回返。
在上述這些函式中， 你絕不能忽略ExceptionOccurred() 和
ExceptionClear()。大多數JNI 函式都可能產生異常，而沒有任何語言
功能可供你取代Java 的try 區段。所以，你得在每次呼叫JNI 函式之後一
Appendix B: The Java Native Interface (JNI) 1075
律呼叫ExceptionOccurred()，藉此檢驗某個異常是否被擲出。如果偵
測到異常，你可能會選擇加以處理(而且可能會重新擲出)。無論如何你
得確定異常最終會被清除。你可以在你的函式中使用ExceptionClear()
完成清除動作，或在異常被重新擲出時於其他函式中加以清除。不論如
何，一定得清除。
你必須確保異常被清除。如果不這麼做，當某個異常處於懸而未決
(pending)的狀態時，呼叫JNI 函式的結果將不可預期。異常期間還能
夠安全運作的JNI 函式非常少，即使有，也都是用來處理異常。
JNI 和多緒(threading)
由於Java 是個多緒程式語言，所以可能有多個執行緒同時呼叫同一個原生
函式。當某個原生函式執行未完，第二個執行緒加以呼叫，該原生函式的
執行便有可能被暫停。一個原生函式是否為thread-safe(也就是不會在未
受監督的情況下修改共用資料)，完全取決於程式員。基本上你有兩種選
擇：將原生函式宣告為synchronized，或採用其他策略來實作原生函
式，確保正確的並行(concurrent)資料處理。
你不應該在執行緒之間傳遞彼此的JNIEnv 指標，因為此一指標所指的內
部結構，在每一個執行緒中都會被配置一份，其中所含的資訊只對該執行
緒有意義。
使用既有的程式碼
實作JNI 原生函式(native methods)的最簡單方式，就是撰寫Java class
中的原生函式原型，編譯該class，並執行javah 於該.class 身上。但如
果你手上已經有個十分龐大、已經存在的程式碼，而你希望從Java 這一端
呼叫這些程式碼，又該怎麼辦呢？修改DLL 中的所有函式名稱，使它們符
合Java 的名稱重整(name mangling)規格，並不是可行的作法。最好的
方法便是撰寫一個包裝用的DLL，將它包裝於原程式外圍。Java 程式呼叫
新的DLL 中的函式，後者再呼叫原始DLL 中的函式。這種解決方式不僅
1076 Thinking in Java www.BruceEckel.com
被廣泛運用，大多數情況下你甚至非得這麼做不可，因為在你能夠使用
object references 之前，得於這些object references 之上呼叫JNI 函式。
補充資訊
你可以在本書第一版(納於本書所附光碟，亦可於www.BruceEckel.com
中免費下載)可以找到更多簡介性資料，包括C(不是C++)範例和
Microsoft 相關討論議題。你可以在java.sun.com 中找到更多補充資訊
(可在搜尋引擎中敲入關鍵字"training & tutorials" 和(或)"native
methods")。《Core Java 2, Volume II》(by Horstmann and Cornell,
Prentice-Hall, 2000)第11 章對於原生函式有極佳的說明。
1077
C: Java 編程準則
(Programming Guidelines)
這份附錄所提供的建議，可以幫助你進行低階的程式設
計，並幫助你寫碼。
當然，這些都只是一種方針而不是硬性規則。你應該視它們為一種靈感來
源。記住，某些情況下你需要加以變通或甚至打破規則。
設計
1. 優雅需要付出代價。從短期利益來看，對某個問題提出優雅的解決
方法，似乎可能花你更多的時間。但當它終於能夠正確執行並可輕
易套用於新案例中，不需要花上數以時計，甚至以天計或以月計的
辛苦代價時，你會看得到先前所花功夫的回報(即使沒有人可以衡
量這一點)。這不僅給你一個可更容易開發和除錯的程式，也更易
於理解和維護。這正是它在金錢上的價值所在。這一點有賴某種人
生經驗才能夠了解，因為當你努力讓某一段程式碼變得比較優雅
時，你並不是處於一種具生產力的狀態下。但是，請抗拒那些催促
你趕工的人們，因為那麼做只會減緩你的速度罷了。
2. 先求能動，再求快。即使你已確定某段程式碼極為重要，而且是系
統的重要瓶頸，這個準則依然成立。儘可能簡化設計，讓系統能夠
先正確運作。如果程式的執行不夠快，再量測其效能。幾乎你總是
會發現，你所認為的「瓶頸」其實都不是問題所在。把你的時間花
在刀口上吧。
1078 Thinking in Java www.BruceEckel.com
3. 記住「各個擊破」的原理。如果你所探討的問題過於混雜，試著想
像該問題的基本動作會是什麼，並假設這一小塊東西能夠神奇地處
理掉最難的部份。這「一小塊」東西其實就是物件- 請撰寫運用該
物件的程式碼，然後檢視物件，並將其中困難的部份再包裝成其他
物件，依此類推。
4. 區分class 開發者和class 使用者(使用端程式員)。class 使用者扮
演著「客戶」角色，不需要(也不知道)class 的底層運作方式。
class 開發者必須是class 設計專家，並撰寫class，使它能夠儘可能
被大多數新手程式員所用，而且在程式中能夠穩當執行。一套程式
庫只有在具備通透性的情況下，使用起來才會容易。
5. 當你撰寫class 時，試著給予明瞭易懂的名稱，減少不必要的註解。
你給客戶端程式員的介面，應該保持概念上的單純性。為了這個目
的，當函式的重載(overloading)適合製作出直覺、易用的介面
時，請善加使用。
6. 你的分析和設計必須讓系統中的classes 保持最少，也必須讓其
public interfaces 保持最少，以及讓這些classes 和其他classes 之間
的關聯性(尤其是base classes)保持最少。如果你的設計所得結果
更甚於此，請問問自己，是否其中每一樣東西在整個程式生命期中
都饒富價值？如果並非如此，那麼，維護它們會使你付出代價。開
發團隊的成員都有不維護「無益於生產力提昇」的任何東西的傾
向；這是許多設計方法論無法解釋的現象。
7. 讓所有東西儘量自動化。先撰寫測試用的程式碼(在你撰寫class 之
前)，並讓它和class 結合在一起。請使用makefile 或類似工具，
自動進行測試動作。透過這種方式，只要執行測試程式，所有的程
式變動就可以自動獲得驗證，而且可以立即發現錯誤。由於你知道
你的測試架構所具備的安全性，所以當你發現新的需求時，你會更
勇於進行全面修改。請記住，程式語言最大的改進，是來自型別檢
查、異常處理等機制所賦予的內建測試動作。但這些功能只能協助
Appendix C: Java Programming Guidelines 1079
你到達某種程度。開發一個穩固系統時，你得自己驗證自己的
classes 或程式的性質。
8. 在你撰寫class 之前先寫測試碼，以便驗證你的class 是否設計完
備。如果你無法撰寫測試碼，你便無法知道你的class 的可能長相。
撰寫測試碼通常能夠顯現出額外的特性( features ) 或限制
(constraints) - 它們並不一定總是能夠在分析和設計過程中出
現。測試碼也可做為展示class 用法的範例程式。
9. 所有軟體設計上的問題，都可以透過「引入額外的概念性間接層
(conceptual indirection)」加以簡化。這個軟體工程上的基礎法
則1 是抽象化概念的根據，而抽象化概念正是物件導向程式設計的主
要性質。
10. 間接層(indirection)應該要有意義(和準則9 一致)。這裡所指
的意義可以像「將共用程式碼置於唯一函式」這麼簡單。如果你加
入的間接層(或抽象化、或封裝等等)不具意義，它可能就和沒有
適當的間接層一樣糟糕。
11. 讓class 儘可能微小而無法切割(atomic)。賦予每個class 單一而
清楚的用途。如果你的classes 或你的系統成長得過於複雜，請將複
雜的classes 切割成比較簡單的幾個classes。最明顯的一個判斷指標
就是class 的大小：如果它很大，那麼它工作量過多的機會就可能很
高， 那就應該被切割。重新設計class 的建議線索是：
1)複雜的switch 述句：請考慮運用多型( polymorphism) 。
2) 許多函式各自處理類型極為不同的動作：請考慮切割為多個不同
的classes。
1這是Andrew Koenig 對我說的。
1080 Thinking in Java www.BruceEckel.com
12. 小心冗長的引數列(argument lists)。冗長的引數列會使函式的叫
用動作不易撰寫、閱讀、維護。你應該試著將函式搬移到更適當的
class 中，並儘量以物件為引數。
13. 不要一再重複。如果某段程式碼不斷出現於許多derived class 函式
中，請將該段程式碼置於某個base class 函式內，然後在derived
class 函式中呼叫。這麼做不僅可以省下程式碼空間，也可以讓修改
該段程式碼的動作更易於進行。有時候，找出此種共通程式碼還可
以為介面增加實用功能。
14. 小心switch 述句或成串的if-else 子句。通常這種情況代表所謂的
"type-check coding"，也就是說究竟會執行哪一段程式碼，乃是依據
某種型別資訊來做抉擇(最初，確切型別可能不十分明顯)。你通
常可以使用繼承和多型來取代此類程式碼；polymorphical method
(多型函式)的叫用會自動執行此類型別檢驗，並提供更可靠更容
易的擴充性。
15. 從設計觀點來看，請找出變動的事物，並使它和不變的事物分離。
也就是說，找出系統中可能被你改變的元素，將它們封裝於classes
中。你可以在《Thinking in Patterns with Java》(可免費下載於
www.BruceEckel.com)大量學習到這種觀念。
16. 不要利用subclassing 來擴充基礎功能。如果某個介面元素對class
而言極重要，它應該被放在base class 裡頭，而不是直到衍生
(derivation)時才被加入。如果你在繼承過程中加入了函式，或許
你應該重新思考整個設計。
17. 少就是多。從class 的最小介面開始發展，儘可能在解決問題的前提
下讓它保持既小又單純。不要預先考量你的class 被使用的所有可能
方式。一旦class 被實際運用，你自然會知道你得如何擴充介面。不
過，一旦class 被使用後，你就無法在不影響用戶程式碼的情況下縮
減其介面。如果你要加入更多函式倒是沒有問題- 不會影響既有的
用戶程式碼，它們只需重新編譯即可。但即使新函式取代了舊函式
的功能，也請你保留既有介面。如果你得透過「加入更多引數」的
Appendix C: Java Programming Guidelines 1081
方式來擴充既有函式的介面，請你以新引數寫出一個重載化的函
式；透過這種方式就不會影響既有函式的任何用戶了。
18. 大聲唸出你的classes，確認它們符合邏輯。請讓base class 和
derived class 之間的關係是"is-a"(是一種)，讓class 和成員物件
之間的關係是"has-a"(有一個)。
19. 當你猶豫不決於繼承(inheritance)或合成(複合，composition)
時，請你問問自己，是否需要向上轉型(upcast)為基礎型別。如
果不需要，請優先選擇合成(也就是使用成員物件)。這種作法可
以消除「過多基礎型別」。如果你採用繼承，使用者會認為他們應
該可以向上轉型。
20. 運用資料成員來表示數值的變化，運用經過覆寫的函式(overrided
method)來代表行為的變化。也就是說，如果你找到了某個class，
帶有一些狀態變數，而其函式會依據這些變數值切換不同的行為，
那麼你或許就應該重新設計，在subclasses 和覆寫後的函式
(overrided methods)中展現行為上的差異。
21. 小心重載(overloading)。函式不應該依據引數值條件式地選擇執
行某一段程式碼。這種情況下你應該撰寫兩個或更多個重載函式
(overloaded methods)。
22. 使用異常體系(exception hierarchies) - 最好是從Java 標準異常
體系中衍生特定的classes，那麼，捕捉異常的人便可以捕捉特定異
常，之後才捕捉基本異常。如果你加入新的衍生異常，原有的用戶
端程式仍能透過其基礎型別來捕捉它。
23. 有時候簡單的聚合(aggregation)就夠了。飛機上的「旅客舒適系
統」包括數個分離的元素：座椅、空調、視訊設備…等等，你會需
要在飛機上產生許多這樣的東西。你會將它們宣告為private 成員並
開發出一個全新的介面嗎？不會的，在這個例子中，元素也是
public 介面的一部份，所以你應該產生public 成員物件。這些物件
1082 Thinking in Java www.BruceEckel.com
具有它們自己的private 實作，所以仍然是安全的。當然啦，簡單聚
合並不是一個常被運用的解法，但有時候的確是。
24. 試著從用戶程式員和程式維護者的角度思考。你的class 應該設計得
儘可能容易使用。你應該預先考量可能有的變動，並針對這些可能
的變動進行設計，使這些變動日後可輕易完成。
25. 小心「巨大物件併發症」。這往往是剛踏入OOP 領域的程序式
(procedural)程式員的一個苦惱，因為他們往往最終還是寫出一
個程序式程式，並將它們擺放到一個或兩個巨大物件中。注意，除
了application framework(應用程式框架，譯註：一種很特殊的、
大型OO 程式庫，幫你架構程式本體)之外，物件代表的是程式中
的觀念，而不是程式本身。
26. 如果你得用某種醜陋的方式來達成某個動作，請將醜陋的部份侷限
在某個class 裡頭。
27. 如果你得使用某種不可移植方式來達成某個動作，請將它抽象化並
侷限於某個class 裡頭。這樣一個「額外間接層」能夠防止不可移植
的部份擴散到整個程式。這種作法的具體呈現便是Bridge 設計樣式
(design pattern)。
28. 物件不應僅僅只用來持有資料。物件也應該具有定義明確界限清楚
的行為。有時候使用「資料物件」是適當的，但只有在通用型容器
不適用時，才適合刻意以資料物件來包裝、傳輸一群資料項。
29. 欲從既有的classes 身上產生新的classes 時， 請以複合
(composition)為優先考量。你應該只在必要時才使用繼承。如果
在複合適用之處你卻選擇了繼承，你的設計就滲雜了非必要的複雜
性。
30. 運用繼承和函式覆寫機制來展現行為上的差異，運用fields(資料成
員)來展現狀態上的差異。這句話的極端例子，就是繼承出不同的
classes 來表現各種不同的顏色，而不使用"color" field。
Appendix C: Java Programming Guidelines 1083
31. 當心變異性(variance)。語意相異的兩個物件擁有相同的動作(或
說責任)是可能的。OO 世界中存在著一種天生的引誘，讓人想要從
某個class 繼承出另一個subclass，為的是獲得繼承帶來的福利。這
便是所謂「變異性」。但是，沒有任何正當理由足以讓我們強迫製
造出某個其實並不存在的superclass/subclass 關係。比較好的解決
方式是寫出一個共用的base class，它為兩個derived classes 製作出
共用介面- 這種方式會耗用更多空間，但你可以如你所盼望地從繼
承機制獲得好處，而且或許能夠在設計上獲得重大發現。
32. 注意繼承上的限制。最清晰易懂的設計是將功能加到繼承得來的
class 裡頭；繼承過程中拿掉舊功能(而非增加新功能)則是一種可
疑的設計。不過，規則可以打破。如果你所處理的是舊有的class 程
式庫，那麼在某個class 的subclass 中限制功能，可能會比重新制定
整個結構(俾使新class 得以良好地相稱於舊class)有效率得多。
33. 使用設計樣式(design patterns)來減少「赤裸裸無加掩飾的機能
(naked functionality)」。舉個例子，如果你的class 只應該產出
唯一一個物件，那麼請不要以不加思索毫無設計的手法來完成它，
然後撰寫「只該產生一份物件」這樣的註解就拍拍屁股走人。請將
它包裝成singleton(譯註：一個有名的設計樣式，可譯為「單
件」)。如果主程式中有多而混亂的「用以產生物件」的程式碼，
請找出類似factory method 這樣的生成樣式( creational
patterns)，使你可用以封裝生成動作。減少「赤裸裸無加掩飾的機
能」(naked functionality)不僅可以讓你的程式更易理解和維護，
也可以阻止出於好意卻帶來意外的維護者。
34. 當心「因分析而導致的癱瘓(analysis paralysis)」。請記住，你往
往必須在獲得所有資訊之前讓專案繼續前進。而且理解未知部份的
最好也最快的方式，通常就是實際前進一步而不只是紙上談兵。除
非找到解決辦法，否則無法知道解決辦法。Java 擁有內建的防火
牆，請讓它們發揮作用。你在單一class 或一組classes 中所犯的錯
誤，並不會傷害整個系統的完整性。
1084 Thinking in Java www.BruceEckel.com
35. 當你認為你已經獲得一份優秀的分析、設計或實作時，請試著加以
演練。將團隊以外的某些人帶進來- 他不必非得是個顧問不可，他
可以是公司其他團隊的成員。請那個人以新鮮的姿態審視你們的成
果，這樣可以在尚可輕易修改的階段找出問題，其收穫會比因演練
而付出的時間和金錢代價來得高。
實作(Implementation)
36. 一般來說，請遵守Sun 的程式編寫習慣。你可以在以下網址找到相
關文件：java.sun.com/docs/codeconv/index.html。本書儘可能遵
守這些習慣。眾多Java 程式員看到的程式碼，都是由這些習慣構成
的。如果你固執地停留在過去的編寫風格中，你的(程式碼)讀者
會比較辛苦。不論你決定採用什麼編寫習慣，請在整個程式中保持
一致。你可以在home.wtal.de/software-solutions/jindent 上找到
一個用來重排Java 程式的免費工具。
37. 無論使用何種編寫風格，如果你的團隊(或整個公司，那就更好
了)能夠加以標準化，那麼的確會帶來顯著效果。這代表每個人都
可以在其他人不遵守編寫風格時修改其作品，這是個公平的遊戲。
標準化的價值在於，分析程式碼時所花的腦力較小，因而可以專心
於程式碼的實質意義。
38. 遵守標準的大小寫規範。將class 名稱的第一個字母應為大寫。資料
成員、函式、物件(references)的第一個字母應為小寫。所有識別
名稱的每個字都應該連在一塊兒，所有非首字的第一個字母都應該
大寫。例如：
ThisIsAClassName
thisIsAMethodOrFieldName
如果你在static final 基本型別的定義處指定了常數初始式
(constant initializers)，那麼該識別名稱應該全為大寫，代表一個
編譯期常數。
Packages 是個特例，其名稱皆為小寫，即使非首字的字母亦是如
Appendix C: Java Programming Guidelines 1085
此。域名(com, org, net, edu 等等)皆應為小寫。(這是Java 1.1
遷移至Java 2 時的一項改變)
39. 不要自己發明「裝飾用的」private 資料成員名稱。通常這種名稱的
形式是在最前端加上底線和其他字元。匈牙利命名法(Hungarian
notation)是其中最差的示範。在這種命名法中，你得加入額外字元
來表示資料的型別、用途、位置等等。彷佛你用的是組合語言
(assembly langauge)而編譯器沒有提供任何協助似的。這樣的命
名方式容易讓人混淆又難以閱讀，也不易推行和維護。就讓classes
和packages 來進行「名稱上的範圍制定(name scoping)」吧。
40. 當你撰寫通用性的class 時，請遵守正規形式(canonical form)。
包括equals()、hashCode()、toString()、clone()(實作出
Cloneable)，並實作出Comparable 和Serialiable 等等。
41. 對於那些「取得或改變private 欄位值」的函式，請使用JavaBeans
的"get"、"set"、"is" 等命名習慣，即使你當時不認為自己正在撰寫
JavaBean。這麼做不僅可以輕易以Bean 的運用方式來運用你的
class，也是對此類函式的一種標準命名方式，使讀者更易於理解。
42. 對於你所撰寫的每一個class，請考慮為它加入static public test()，
其中含有class 功能測試碼。你不需要移除該測試碼就可將程式納入
專案。而且如果有所變動，你可以輕易重新執行測試。這段程式碼
也可以做為class 的使用範例。
43. 有時候你需要透過繼承，才得以存取base class 的protected 成員。
這可能會引發對多重基礎類別(multiple base types)的認知需求。
如果你不需要向上轉型， 你可以先衍生新的class 以便執行
protected 存取動作，然後在「需要用到上述protected 成員」的所
有classes 中，將新class 宣告為成員物件，而非直接繼承。
1086 Thinking in Java www.BruceEckel.com
44. 避免純粹為了效率考量而使用final 函式。只有在程式能動但執行不
夠快時，而且效能量測工具(profiler)顯示某個函式的叫用動作成
為瓶頸時，才使用final 函式。
45. 如果兩個classes 因某種功能性原因而產生了關聯(例如容器
containers 和迭代器iterators)，那麼請試著讓其中某個class 成為
另一個class 的內隱類別(inner class)。這不僅強調二者間的關
聯，也是透過「將class 名稱巢狀置於另一個class 內」而使同一個
class 名稱在單一package 中可被重複使用。Java 容器程式庫在每個
容器類別中都定義了一個內隱的(inner)Iterator class，因而能夠
提供容器一份共通介面。運用內隱類別的另一個原因是讓它成為
private 實作物的一部份。在這裡，內隱類別會為資訊隱藏帶來好
處，而不是對上述的class 關聯性提供助益，也不是為了防止命名空
間污染問題(namespace pollution)。
46. 任何時候你都要注意那些高度耦合(coupling)的classes。請考慮
內隱類別(inner classes)為程式撰寫和維護帶來的好處。內隱類別
的使用並不是要去除classes 間的耦合，而是要讓耦合關係更明顯也
更便利。
47. 不要成為「過早最佳化」的犧牲品。那會讓人神經錯亂。尤其在系
統建構初期，先別煩惱究竟要不要撰寫(或避免)原生函式(native
methods)、要不要將某些函式宣告為final、要不要調校程式碼效
率等等。你的主要問題應該是先證明設計的正確性，除非設計本身
需要某種程度的效率。
48. 讓範圍(作用域，scope)儘可能愈小愈好，這麼一來物件的可視範
圍和壽命都將儘可能地小。這種作法可降低「物件被用於錯誤場
所，因而隱藏難以察覺的臭蟲」的機會。假設你有個容器，以及一
段走訪該容器的程式片段。如果你複製該段程式碼，將它用於新的
容器身上，你可能會不小心以舊容器的大小做為新容器的走訪上限
值。如果舊容器已不在存取範圍內，那麼編譯期便可找出這樣的錯
誤。
Appendix C: Java Programming Guidelines 1087
49. 使用Java 標準程式庫提供的容器。請熟悉它們的用法，你將因此大
幅提昇你的生產力。請優先選擇ArrayList 來處理序列
( sequences ) ， 選擇HashSet 來處理集合( sets ) 、選擇
HashMap 來處理關聯式陣列( associative arrays ) ， 選擇
LinkedList(而不是Stack)來處理stacks 和queues。
50. 對一個強固的(robust)程式而言，每一個組成都必須強固。請在
你所撰寫的每個class 中運用Java 提供的所有強固提昇工具：存取
權限、異常、型別檢驗…等等。透過這種方式，你可以在建構系統
時安全地移往抽象化的下一個層次。
51. 寧可在編譯期發生錯誤，也不要在執行期發生錯誤。試著在最靠近
問題發生點的地方處理問題。請優先在「擲出異常之處」處理問
題，並在擁有足夠資訊以處理異常的最接近處理常式(handler)中
捕捉異常。請進行現階段你能夠對該異常所做的處理；如果你無法
解決問題，應該再次擲出異常。
52. 當心冗長的函式定義。函式應該是一種簡短的、「描述並實作class
介面中某個可分離部份」的功能單元。過長且複雜的函式不僅難以
維護，維護代價也高。或許它嘗試做太多事情了。如果你發現這一
類函式，代表它應該被切割成多個函式。這種函式也提醒你或許得
撰寫新的class。小型函式同樣能夠在你的class 中被重複運用。
(有時候函式必須很大才行，但它們應該只做一件事情)
53. 儘可能保持"private"。一旦你對外公開了程式庫的概況(method、
class、或field)，你便再也無法移除它們。因為如果移除它們，便
會破壞某個現有的程式碼，使得它們必須重新被編寫或重新設計。
如果你只公開必要部份，那麼你便可以改變其他東西而不造成傷
害。設計總是會演化，所以這是個十分重要的自由度。透過這種方
式，實作碼的更動對derived class 造成的衝擊會降到最低。在多緒
環境下，私密性格外重要- 只有private 欄位可受保護而不被unsynchronized(
未受同步控制)的運用所破壞。
1088 Thinking in Java www.BruceEckel.com
54. 大量運用註解，並使用javadoc 的「註解文件語法」來產生程式的
說明文件。不過，註解應該賦予程式碼真正的意義；如果只是重申
程式碼已經明確表示的內容，那是很煩人的。請注意，通常Java
class 和其函式的名稱都很長，為的便是降低註解量。
55. 避免使用「魔術數字」，也就是那種寫死在程式碼裡頭的數字- 如
果你想改變它們，它們就會成為你的惡夢，因為你永遠都沒有辦法
知道"100" 究竟是代表「陣列大小」或其他東西。你應該產生具描
述性的常數名稱，並在程式中使用該常數名稱。這使程式更易於理
解也更易於維護。
56. 撰寫建構式時，請考慮異常狀態。最好情境下，建構式不執行任何
會擲出異常的動作。次佳情境下，class 只繼承自(或合成自)強固
的(robust)classes，所以如有任何異常被擲出，並不需要清理。
其他情況下，你就得在finally 子句中清理合成後的classes。如果
某個建構式一定會失敗，適當的動作就是擲出異常，使呼叫者不至
於盲目認為物件已被正確產生而繼續執行。
57. 如果你的class 需要在「用戶程式員用完物件」後進行清理動作，請
將清理動作放到單一而定義明確的函式中，最好令其名稱為
cleanup() 以便能夠將用途告訴他人。此外請將boolean 旗標放
到class 中，用以代表物件是否已被清理，使finalize() 得以檢驗其
死亡條件(請參考第4 章)。
58. finalize() 只可用於物件死亡條件的檢驗(請參考第4 章)，俾有
益於除錯。特殊情況下可能需要釋放一些不會被垃圾回收器回收的
記憶體。因為垃圾回收器可能不會被喚起處理你的物件，所以你無
法使用finalize() 執行必要的清理動作。基於這個原因，你得撰寫
自己的「清理用」函式。在class finalize()中，請檢查確認物件的
確已被清理， 並在物件尚未被清理時， 擲出衍生自
RuntimeException 的異常。使用這種架構前， 請先確認
finalize() 在你的系統上可正常運作( 這可能需要呼叫
System.gc() 來確認)。
Appendix C: Java Programming Guidelines 1089
59. 如果某個物件在某個特定範圍(scope)內必須被清理(cleaned
up)，而不是被垃圾回收機制收回，請使用以下方法：將物件初始
化，成功後立刻進入擁有finally 子句的一個try 區段內。finally
子句會引發清理動作。
60. 當你在繼承過程中覆寫了finalize() ， 請記得呼叫
super.finalize() 。但如果你的「直接上一層superclass 」是
Object，就不需要這個動作。你應該讓super.finalize() 成為被
覆寫(overridden)之finalize() 的最後一個動作而不是第一個動
作，用以確保base class 的組件在你需要它們的時候仍然可用。
61. 當你撰寫固定大小的物件容器，請將它們轉換為陣列- 尤其是從某
個函式回傳此一容器時。透過這種方式，你可以獲得陣列的「編譯
期型別檢驗」的好處，而且陣列接收者可能不需要「先將陣列中的
物件加以轉型」便能加以使用。請注意，容器程式庫的base class
(Java.util.Collection)具有兩個toArray()，能夠達到這個目
的。
62. 在interface(介面)和abstract class(抽象類別)之間，優先選擇
前者。如果你知道某些東西即將被設計為一個base class，你的第一
選擇應該是讓它成為interface；只有在一定得放進函式或資料成
員時，才應該將它改為abstract class。interface 只和「用戶端想
進行什麼動作」有關，class 則比較把重心放在實作細節上。
1090 Thinking in Java www.BruceEckel.com
63. 在建構式中只做唯一必要動作：將物件設定至適當狀態。避免呼叫
其他函式(除了final 函式)，因為這些函式可能會被其他人覆寫
因而使你在建構過程中得到不可預期的結果(請參考第7 章以取得
更詳細的資訊)。小型而簡單的建構式比較不可能擲出異常或引發
問題。
64. 為了避免一個十分令人洩氣的經驗，請確認你的classpath 中的每個
名稱，都只有一個未被放到packages 裡頭的class。否則編譯器會
先找到另一個名稱相同的class，並回報錯誤訊息。如果你懷疑你的
classpath 出了問題，試著從classpath 中的每個起點搜尋同名的
.class 檔案。最好還是將所有classes 都放到packages 裡頭。
65. 留意一不小心犯下的重載(overloading)錯誤。如果你覆寫base
class 函式時沒有正確拼寫其名稱，那麼便會增加一個新的函式，而
不是覆寫原有的函式。但是這種情況完全合法，所以你不會從編譯
器或執行期系統得到任何錯誤訊息- 你的程式碼只是無法正確作
用，如此而已。
66. 當心過早最佳化。先讓程式動起來，再讓它快- 但只有在你必須
(也就是說只有在程式被證明在某段程式碼上遭遇效能瓶頸)時才
這麼做。除非你已經使用效能量測工具(profiler)找出瓶頸所在，
否則你可能只是在浪費你的時間。效能調校的「隱藏成本」便是讓
你的程式碼變得更不可讀、更難維護。
67. 記住，程式碼被閱讀的時間多於它被撰寫的時間。清晰的設計能夠
製作出易懂的程式。註解、細節說明、範例都是無價的。這些東西
能夠幫助你和你的後繼者。如果沒有其他資訊，那麼從Java 線上文
件找出一些有用的資訊時，你所遭遇的挫敗應該足以讓你相信這一
點。
1091
D: 資源
軟體
從java.sun.com 取得JDK(Java Development Kid)。即使你選擇其他
廠商的開發環境，當你懷疑可能是編譯器出錯的時候，手邊有個JDK 還是
不錯的。JDK 是檢驗標準，而且如果JDK 中有個臭蟲，這隻臭蟲廣為人知
的機會應該很高。
從java.sun.com 取得Java 說明文件HTML 版本。我看過的每一本介紹標
準Java 程式庫的書，不是跟不上最新資訊，就是有所遺漏。雖然Sun 的這
份文件存在一些小錯誤，而且有些項目的資訊過少，但起碼所有的classes
和函式都在裡頭。相對於紙本，人們初期對線上資源的運用或許並不那麼
稱手，但的確值得花上一些時間加以克服。無論如何請先打開它(HTML
文件)，那麼至少可以先取得整個概觀。如果這時候你還是無法理解，再
回到紙本書吧。
書籍
Thinking in Java, 1st Edition. 本書所附光碟裡頭就有此書經過完全索
引並以顏色標註語法的一個HTML 版本。你也可以從www.BruceEckel.
com 免費下載。此書涵蓋比較舊的、不適合被放進第二版的一些材料。
Core Java 2, by Horstmann & Cornell, Volume I ： Fundamentals
(Prentice-Hall, 1999). Volume II：Advanced Features, 2000。資訊量龐大
又完整。每當我需要搜尋某些答案時，總會先翻開這兩本書。當你讀完
Thinking in Java 後還需要撒出更大的網時，我推薦這兩本書。
Java in a Nutshell: A Desktop Quick Reference, 2nd Edition, by
David Flanagan (O’Reilly, 1997)。Java 線上文件的一份簡潔摘要。從個人
1092 Thinking in Java www.BruceEckel.com
觀點來說，我偏好線上瀏覽java.sun.com 的各種文件，尤其因為它們的內
容常會更動。不過許多人還是偏好紙本文件，而且這樣也比較有付費的質
感。本書提供比線上文件更豐富的討論內容。
The Java Class Libraries: An Annotated Reference, by Patrick
Chan and Rosanna Lee (Addison-Wesley, 1997)。線上文件應該這樣：有
足夠的說明讓讀者可以實際運用。Thinking in Java 的一位技術審稿者這
麼說：『如果我只能有一本Java 書籍，那就是上面這本了(好啦，當然還
有你那本 )』。我並不像這位審稿者對這本書那麼感到興奮。這是一本
很龐大很昂貴的書，其中提供的範例品質並不能滿足我。但是當你遇到某
個難解問題時，到這本書來找尋答案是個不錯的主意。而且本書似乎也較
Java in a Nutshell 有深度(以及厚度)。
Java Network Programming, by Elliotte Rusty Harold (O’Reilly,
1997)。直到閱讀了這本書，我才開始了解Java 的網絡機制。我發現作者
的網站Cafe au Lait 在Java 開發上提供了讓人倍感興奮、有主見、最即時
的觀點，而且不帶任何廠商色彩。作者定期更新網站內容，使網站內容得
以跟上Java 快速變動的各種消息。請看matalab.unc.edu/javafaq/。
JDBC Database Access with Java, by Hamilton, Cattell & Fisher
(Addison-Wesley, 1997)。如果你對SQL 和資料庫一無所知，這是一本極
好的入門書。它同時也含括了某些API 細節介紹，以及「帶有註釋的」
API 參考資料(這也是線上參考文件所應具備的)。本書缺點和The
Java Series(唯一由JavaSoft 認可的系列書籍)一樣，過於粉飾太平，
只講Java 美好的一面。該系列中你找不到任何負面資訊。
Java Programming with CORBA, by Andreas Vogel & Keith Duddy
(John Wiley & Sons, 1997)。附有三種Java ORBs(Visibroker、Orbix、
Joe)程式範例，對CORBA 課題有深入的探討。
Design Patterns, by Gamma, Helm, Johnson & Vlissides (Addison-
Wesley, 1995)。在程式設計領域中帶動設計樣式(design patterns)風潮
的一本種子書。
Appendix D: Resources 1093
Practical Algorithms for Programmers, by Binstock & Rex
(Addison-Wesley, 1995)。書中演算法以C 呈現，很容易轉換為Java。每
個演算法都有極完整的解說。
分析& 設計
Extreme Programming Explained, by Kent Beck (Addison-Wesley,
2000)。我愛這本書。是的，我傾向於採用根本方法來解決問題，但我總
認為應該會有更不一樣、更好的程式開發過程，我認為XP(eXtreme
Porgramming)已經很逼近這個境界了。對我而言，唯一有相似影響力的
另一本書就是PeopleWare(待會兒為你介紹)，主要探討環境和團體文
化的處理。eXtreme Programming Explained 探討的是程式設計，
而且顛覆一般人所知的絕大多數方法- 甚至顛覆最新的「研究結果」。他
們甚至誇張到認為任何描述只要別花你太多時間，而且你願意將它們丟
掉，就可以採用- 喔，你會發現該書封面並沒有"UML stamp of
approval"(UML 認同標籤)。我會以某家公司是否採用XP 來決定是否為
他們工作。這是一本小書，章節少，讀起來不費力，而且能夠激勵思考。
你會開始想像自己彷彿工作在這樣的氛圍當中，它會帶給你全新視野。
UML Distilled, 2nd Edition, by Martin Fowler (Addison-Wesley, 2000).
初次接觸UML 時你大概會有怯步的感覺。因為裡頭的圖示法和細節實在
太多了。根據Fowler 的說法，大部份內容都非必要，所以他直接討論本
質。對大多數專案來說，你只需要知道少數幾種圖示工具就夠了。Fowler
的目的便是提供一份好的設計，而不是去考慮所有達成這一份好設計所需
要的所有工具。這是一本優秀、輕薄、易讀的書籍；如果你需要了解
UML，它是你應該讀的第一本。
UML Toolkit, by Hans-Erik Eriksson & Magnus Penker, (John Wiley &
Sons, 1997)。本書解說UML 本身及其運用方式。並以Java 進行個例探
討。書附光碟內含Java 程式碼和Rational Rose 陽春版。在UML 以及
「如何運用UML 建構真實系統」上，這是一份出色的簡介性書籍。
The Unified Software Development Process, by Ivar Jacobsen,
Grady Booch, and James Rumbaugh (Addison-Wesley, 1999)。我原本做
好了不喜歡這本書的心理準備。此書似乎具備煩人的大學教科書所具備的
1094 Thinking in Java www.BruceEckel.com
一切必要條件。我甚至帶點竊喜地發現，此書有少數幾個觀念好像連作者
也不甚明白似的。本書不僅清晰，甚至帶點閱讀樂趣。本書最好的一點
是，整個過程帶來許多實用價值。這不僅是eXtreme Programming 也是
UML 的駭人力量之一。縱使你無法接受XP，由於大多數人都已搭上
「UML 就是好」的時尚流行(不論他們實際經驗為何)，所以你或許可以
接受本書。我認為此書應該是UML 旗艦書品。當你讀完Fowler 的UML
Distilled 後，如果想知道更詳細的資訊，可以選擇這本書。
選擇任何方法(論)之前，先從那些非狂熱份子身上獲得一些看法，會有
幫助。人們往往在尚未真正了解某種方法，或尚未知道某種方法能為你做
些什麼之前，就輕率選擇了它們。「其他人正在使用」似乎是個令人信服
的理由，但人們都有一種奇怪的心理怪癖：如果人們想要相信某個東西真
能解決問題，他們就會去嘗試(這種實驗態度很好)，但如果它不能解決
問題，他們便可能加倍努力並開始大聲宣稱，他們發現了很偉大的東西
(這種拒絕承認的態度不好)。這裡的假設是，或許有了一些人和你在同
一艘船上，你就不感到孤單了，即使那艘船駛往不知名的地方(甚至正在
下沉)。
我並不是暗示所有方法論都沒有價值，而是提醒你應該使用一些精神上的
工具來武裝自己，這個工具能夠幫助你繼續停留在實驗模式(『這種方法
不可行，讓我們試試其他方法』)而脫離否認模式(『噢不，這其實不是
問題。一切都是那麼美好，我們不需要改變』)。我認為在你選擇某種方
法(論)之前，先讀過下列幾本書，會給你帶來這樣子的工具。
Software Creativity, by Robert Glass (Prentice-Hall, 1995)。在討論整
個方法論問題的觀點上，這是我見過最好的一本書。本書集合了Glass 所
撰寫或取得(P.J. Pluger 是其中一位作者)的許多短文和論文，這些文章
反映出他多年來對這個課題的思考和研究。這些文章十分有趣，而且長度
恰好；既非信手塗鴉，也不會讓你感到無聊。作者不是在放煙霧彈，書中
參考的其他論文和研究報告數以百計。所有程式員和管理者在陷入方法論
的泥沼前，都應該好好閱讀這本書。
Appendix D: Resources 1095
Software Runaways: Monumental Software Disasters, by
Robert Glass (Prentice-Hall, 1997)。這本書最棒的地方就是，它將我們帶
到我們沒有討論的最前線去：有多少專案不僅失敗，而且一敗塗地。我發
現大多數人仍然認為「這不可能發生在我身上」(或是「這不會再重
演」)，而我認為這會使你處於劣勢。把「任何事都可能出錯」牢記心
中，你便比較能夠站在較好的位置來修正發生的問題。
Peopleware, 2nd Edition, by Tom Demarco and Timothy Lister (Dorset
House, 1999)。雖然這些人的背景是軟體開發，但這本書所討論的是一般
專案和團隊，重心擺在人與人的需求，而不是技術與技術的需求。作者所
討論的是如何建立一個讓人們能夠快樂工作並且有高生產力的環境，而不
是討論這些人應該遵守那些規則才能夠成為稱職的機器零件。我認為後一
種態度正是程式員「面對某種方法時陽奉陰違」的最大肇因。
Complexity, by M. Mitchell Waldrop (Simon & Schuster, 1992)。這本書
記錄了一群來自不同領域的科學家，聚集於新墨西哥州聖塔菲亞(Santa
Fe)，一起討論他們各自學科領域無法解決的現實問題(經濟學裡的股市
問題、生物學裡的生命初始問題、社會學裡的人類行為問題…等等)。藉
著跨越物理、經濟、化學、數學、計算機科學、社會學、以及其他種種學
科的方式，針對這些問題發展出跨學科解決方案。更重要的是，思考這類
極複雜問題的另一種方式正在成形：捨棄「數學決定論」和「能以方程式
預測所有行為」的錯誤認知，邁向「先觀察、找出模式、試著以任何可能
的手段模擬」的方式。舉個例子，此書記錄了遺傳演算法( genetic
algorithms)的面世。我相信這種思考方式對我們觀察愈來愈複雜的軟體
專案十分有用。
Python
Learning Python, by Mark Lutz and David Ascher (O’Reilly, 1999)。一
份很好的針對程式員的介紹。它所介紹的東西短時間內就成了我最喜歡的
程式語言。和Java 搭配使用更是一級棒。本書還包括對JPython 的介紹。
透過JPython，你可以將Java 和Python 合併於同一個程式裡(JPython
直譯器會被編譯成純粹的Java bytecodes；所以不需要加入任何特別的東
1096 Thinking in Java www.BruceEckel.com
西就可以達成這樣的目的)。這個語言的相關組織承諾為我們帶來最大的
可能性。
我的著作
以下以出版順序排列。並非所有書籍都能在市面上找到。
Computer Interfacing with Pascal & C, (透過Eisys imprint 自行印
製, 1998)只能於www.BruceEckle.com 取得。這是在CP/M 稱王DOS 崛
起的時代，一本帶有電子學基礎的簡介書。我過去常常使用高階語言透過
電腦平行埠進行控制，完成各種電子專案。本書內容改寫自我在Micro
Cornucopia 雜誌上的專欄文章。那本雜誌是我的第一個(也是最好的一
個)專欄舞台。但是，唉，在Internet 出現的很久之前Micro Cornucopia
雜誌就已經消失了。本書帶給我極滿意的出版經驗。
Using C++, (Osborne/McGraw-Hill, 1989)。我的第一本C++ 書籍。本
書已經絕版，被其後繼者C++ Inside & Out 取代。
C++ Inside & Out, (Osborne/McGraw-Hill, 1993)。就如上段所提，本
書實際上是Using C++的第二版。本書內容已經相當精確，但1992 左右我
以Thinking in C++取代之。你可以在www.BruceEckel.com 中找到更多
本書資訊，也可以下載取得原始碼。
Thinking in C++, 1st Edition, (Prentice-Hall, 1995).
Thinking in C++, 2nd Edition, Volume 1, (Prentice-Hall, 2000). 可自
www.BruceEckel.com下載。
Black Belt C++, the Master’s Collection, 由Bruce Eckel 編纂而成，
M&T Books 出版, 1994。本書已絕版，其內容乃是收集我擔任「軟體開發
會議(Software Development Conference)」大會主席期間，許多C++ 傑
出人物的投稿文章。本書封面促使我想要控制日後所有我的書籍的封面設
計。
Appendix D: Resources 1097
Thinking in Java, 1st Edition, (Prentice-Hall, 1998)。這是你手上這本
書的第一版，贏得Software Development Magazine 生產力獎、Java
Developer’s Journal 編輯優選獎、JavaWorld Reader 最優選書籍獎。可
於www.BruceEckel.com 下載取得。
1098 Thinking in Java www.BruceEckel.com
1099
索引
請注意，某些名稱會以大寫型式重複一次。以下遵循Java
風格，也就是大寫名稱代表Java classes，小寫名稱代表一
般概念。
- . 139
! . 143
!= . 141; operator . 1025
& . 146
&& . 143
&= . 147
@deprecated . 128
[ ]: indexing operator [ ] . 231
^ . 146
^= . 147
| . 146
|| . 143
|= . 147
‘+’: operator + for String . 1054
+ . 139
< . 141
<< . 147
<<= . 147
<= . 141
== . 141; operator . 1025; vs. equals( ) . 645
> . 141
>= . 141
>> . 147
>>= . 147
A
abstract: class . 326; inheriting from an
abstract class . 326; vs. interface . 356
abstract keyword . 327
Abstract Window Toolkit (AWT) . 689
AbstractButton . 734
abstraction . 30
AbstractSequentialList . 502
AbstractSet . 461
accept( ) . 909
access: class . 263; control . 243, 267;
inner classes & access rights . 376;
package access and friendly . 255;
specifiers . 36, 243, 255; within a
directory, via the default package . 257
action command . 765
ActionEvent . 766, 814
ActionListener . 712
actor, in use cases . 77
adapters: listener adapters . 729
add( ), ArrayList . 450
addActionListener( ) . 811, 857
addChangeListener . 771
addition . 137
addListener . 722
addXXXListener( ) . 723
Adler32 . 608
aggregate array initialization . 231
aggregation . 37
aliasing . 136; and String . 1054; during a
method call . 1014
align . 697
alphabetic vs. lexicographic sorting . 436
AlreadyBoundException . 978
analysis: and design, object-oriented . 71;
paralysis . 72; requirements analysis . 75
AND: bitwise . 154; logical (&&) . 143
anonymous inner class . 370, 576, 709, 875;
and constructors . 375
anonymous inner class, and table-driven
code . 502
applet . 692; advantages for client/server
systems . 693; align . 697; and
packages . 699; archive tag, for HTML
and JAR files . 793; classpath . 699;
codebase . 697; combined applets and
applications . 700; displaying a Web
page from within an applet . 923; name .
697; packaging applets in a JAR file to
optimize loading . 793; parameter . 697;
1100
placing inside a Web page . 695;
restrictions . 692
Applet: combined with application . 839;
initialization parameters . 839
appletviewer . 698
application: application builder . 800;
application framework . 394; combined
applets and applications . 700;
combined with Applet . 839; windowed
applications . 700
application framework, and applets . 694
archive tag, for HTML and JAR files . 793
argument: constructor . 193; final . 298,
577; passing a reference into a method .
1014; variable argument lists (unknown
quantity and type of arguments) . 235
array . 407; associative array . 477;
associative array, Map . 442; bounds
checking . 232; comparing arrays . 431;
copying an array . 429; dynamic
aggregate initialization syntax . 412;
element comparisons . 431; first-class
objects . 409; initialization . 231;
length . 232, 409; multidimensional .
236; of objects . 409; of primitives . 409;
return an array . 413
ArrayList . 456, 463, 467, 500, 505;
add( ) . 450; and deep copying . 1030;
get( ) . 450, 456; size( ) . 451; typeconscious
ArrayList . 454; used with
HashMap . 652
Arrays class, container utility . 415
Arrays.asList( ) . 519
Arrays.binarySearch( ) . 437
Arrays.fill( ) . 428
assigning objects . 134
assignment . 134
associative array . 439, 477
associative arrays (Maps) . 442
auto-decrement operator . 139
auto-increment operator . 139
automatic type conversion . 273
available( ) . 598
B
bag . 440
base: types . 39
base 16 . 156
base 8 . 156
base class . 260, 275, 315; abstract base
class . 326; base-class interface . 320;
constructor . 332; constructors and
exceptions . 281; initialization . 278
Basic: Microsoft Visual Basic . 800
basic concepts of object-oriented
programming (OOP) . 29
BASIC language . 92
BasicArrowButton . 735
beanbox Bean testing tool . 817
BeanInfo: custom BeanInfo . 818
Beans: and Borland’s Delphi . 800; and
Microsoft’s Visual Basic . 800; and
multithreading . 854; application
builder . 800; beanbox Bean testing
tool . 817; bound properties . 818;
component . 801; constrained
properties . 818; custom BeanInfo . 818;
custom property editor . 818; custom
property sheet . 818; events . 801;
EventSetDescriptors . 808;
FeatureDescriptor . 818;
getBeanInfo( ) . 805;
getEventSetDescriptors( ) . 808;
getMethodDescriptors( ) . 808;
getName( ) . 808;
getPropertyDescriptors( ) . 808;
getPropertyType( ) . 808;
getReadMethod( ) . 808;
getWriteMethod( ) . 808; indexed
property . 818; Introspector . 805; JAR
files for packaging . 816; manifest file .
816; Method . 808; MethodDescriptors .
808; naming convention . 802;
properties . 801; PropertyChangeEvent .
818; PropertyDescriptors . 808;
ProptertyVetoException . 818;
reflection . 801, 804; Serializable . 814;
visual programming . 800
Beck, Kent . 1093
Bill Joy . 141
binary: numbers . 156; operators . 146
binary numbers, printing . 150
binarySearch( ) . 437
bind( ) . 976
binding: dynamic binding . 316; dynamic,
late, or run-time binding . 311; early . 45;
late . 45; late binding . 316; method call
binding . 315; run-time binding . 316
BitSet . 522
bitwise: AND . 154; AND operator (&) . 146;
EXCLUSIVE OR XOR (^) . 146; NOT ~ .
1101
146; operators . 146; OR . 154; OR
operator (|) . 146
bitwise copy . 1024
blank final . 297
blocking: and available( ) . 598; and
threads . 859; on I/O . 869
Booch, Grady . 1093
book: errors, reporting . 23; updates of the
book . 22
boolean: operators that won’t work with
boolean . 141
Boolean . 169; algebra . 146; and casting .
155; vs. C and C++ . 144
BorderLayout . 713
Borland . 820; Delphi . 800
bound properties . 818
bounds checking, array . 232
Box, for BoxLayout . 718
BoxLayout . 717
break keyword . 175
browser: class browser . 263
BufferedInputStream . 586
BufferedOutputStream . 588
BufferedReader . 563, 591, 597
BufferedWriter . 591, 599
business objects/logic . 796
button: creating your own . 730; radio
button . 750
button, Swing . 706
ButtonGroup . 736, 750
buttons . 734
ByteArrayInputStream . 582
ByteArrayOutputStream . 583
C
C/C++, interfacing with . 1065
C++ . 141; copy constructor . 1042;
Standard Container Library aka STL .
440; strategies for transition to . 93;
templates . 455; vector class, vs. array
and ArrayList . 408; why it succeeds . 91
callback . 432, 575, 708
callbacks: and inner classes . 391
capacity, of a HashMap or HashSet . 491
capitalization: Java capitalization style
source-code checking tool . 645; of
package names . 116
case statement . 183
cast . 47, 201, 661; and containers . 450;
and primitive types . 170; from float or
double to integral, truncation . 186;
operators . 154
catch: catching an exception . 534;
catching any exception . 543; keyword .
535
CD ROM for book . 20
CGI: Common-Gateway Interface . 948
change: vector of change . 397
CharArrayReader . 590
CharArrayWriter . 590
check box . 748
CheckedInputStream . 606
CheckedOutputStream . 606
Checksum . 608
class . 32, 262; abstract class . 326; access .
263; anonymous inner . 709;
anonymous inner class . 370, 576, 875;
anonymous inner class and
constructors . 375; base class . 260, 275,
315; browser . 263; class hierarchies and
exception handling . 567; class literal .
664, 669; creators . 35; defining the
interface . 88; derived class . 315;
equivalence, and
instanceof/isInstance( ) . 672; final
classes . 301; inheritance diagrams . 293;
inheriting from an abstract class . 326;
inheriting from inner classes . 384;
initialization & class loading . 304;
initialization of data members . 220;
initializing members at point of
definition . 221; initializing the base
class . 278; inner class . 365; inner class
nesting within any arbitrary scope . 372;
inner classes . 799; inner classes &
access rights . 376; inner classes and
overriding . 385; inner classes and
super . 385; inner classes and Swing .
722; inner classes and upcasting . 368;
inner classes in methods & scopes . 370;
inner classes, identifiers and .class files .
387; instance of . 31; intializing the
derived class . 278; keyword . 38;
loading . 305; member initialization .
273; multiply-nested . 383; order of
initialization . 223; private inner
classes . 397; public class, and
compilation units . 245; read-only
classes . 1047; referring to the outer
class object in an inner class . 381; static
inner classes . 379; style of creating
classes . 262; subobject . 278
1102
Class . 737; Class object . 633, 662, 848;
forName( ) . 664, 727; getClass( ) . 544;
getConstructors( ) . 681;
getInterfaces( ) . 676; getMethods( ) .
681; getName( ) . 677; getSuperclass( ) .
676; isInstance . 671; isInterface( ) . 677;
newInstance( ) . 676; printInfo( ) . 677;
RTTI using the Class object . 674
Class object . 227
ClassCastException . 345, 666
classpath . 248, 699; and rmic . 979
class-responsibility-collaboration (CRC)
cards . 79
cleanup: and garbage collector . 283;
performing . 209; with finally . 554
cleanup, guaranteeing with finalize( ) . 214
client programmer . 35; vs. library creator .
243
client, network . 907
clipboard: system clipboard . 790
clone( ) . 1021; and composition . 1027;
and inheritance . 1034; Object.clone( ) .
1025; removing/turning off
cloneability . 1036; super.clone( ) . 1025,
1041; supporting cloning in derived
classes . 1036
Cloneable interface . 1022
CloneNotSupportedException . 1024
close( ) . 597
closure, and inner classes . 391
code: calling non-Java code . 1065; coding
standards . 22, 1077; organization . 255;
re-use . 271
codebase . 697
Collection . 440
collection class . 407
Collections . 511
Collections.enumeration( ) . 520
Collections.fill( ) . 443
Collections.reverseOrder() . 434
collision: name . 250
collisions, during hashing . 488
com.bruceeckel.swing . 703
combo box . 751
comma operator . 152, 175
Command Pattern . 575
comments: and embedded
documentation . 122
common interface . 325
common pitfalls when using operators .
153
Common-Gateway Interface (CGI) . 948
Comparable . 432, 475
Comparator . 434, 475
compareTo( ), in java.lang.Comparable .
432
comparing arrays . 431
compilation unit . 245
compile-time constant . 294
compiling a Java program . 121
component, and JavaBeans . 801
composition . 37, 271; and cloning . 1027;
and design . 340; and dynamic behavior
change . 341; choosing composition vs.
inheritance . 288; combining
composition & inheritance . 281; vs.
inheritance . 294, 642
compression: compression library . 606
concept, high . 75
ConcurrentModificationException . 515
conditional operator . 151
conference, Software Development
Conference . 10
Console: Swing display framework in
com.bruceeckel.swing . 702
console input . 597
const, in C++ . 1053
constant: compile-time constant . 294;
folding . 294; groups of constant values .
359; implicit constants, and String .
1053
constrained properties . 818
constructor . 191; and anonymous inner
classes . 370; and exception handling .
562; and exceptions . 561; and finally .
562; and overloading . 194; and
polymorphism . 330; arguments . 193;
base-class constructor . 332; base-class
constructors and exceptions . 281;
behavior of polymorphic methods inside
constructors . 337; C++ copy
constructor . 1042; calling base-class
constructors with arguments . 280;
calling from other constructors . 205;
default . 202; default constructors . 196;
initialization during inheritance and
composition . 281; name . 192; no-arg
constructors . 196; order of constructor
calls with inheritance . 330; return
value . 193; static construction clause .
228; synthesized default constructor
access . 681
Constructor: for reflection . 678
1103
consulting & mentoring provided by Bruce
Eckel . 23
container: class . 407, 439; of primitives .
412
container classes, utilities for . 444
continue keyword . 175
control: access . 36
control framework, and inner classes . 394
controlling access . 267
conversion: automatic . 273; narrowing
conversion . 155, 201; widening
conversion . 155
cookies: and JSP . 971
cookies, and servlets . 955
copy: deep copy . 1020; shallow copy .
1019
copying an array . 429
CORBA . 980
costs, startup . 95
coupling . 537
CRC, class-responsibility-collaboration
cards . 79
CRC32 . 608
createStatement( ) . 930
critical section, and synchronized block .
852
D
daemon threads . 840
data: final . 294; primitive data types and
use with operators . 159; static
initialization . 225
data type: equivalence to class . 33
database: flat-file database . 932; Java
DataBase Connectivity (JDBC) . 927;
relational database . 933; URL . 928
DatabaseMetaData . 938
DataFlavor . 792
Datagram . 923; User Datagram Protocol
(UDP) . 923
DataInput . 593
DataInputStream . 586, 591, 597, 599
DataOutput . 593
DataOutputStream . 588, 592, 599
dead, Thread . 859
deadlock, multithreading . 865, 872
death condition, and finalize( ) . 214
decorator design pattern . 585
decoupling: via polymorphism . 46
decoupling through polymorphism . 311
decrement operator . 139
deep copy . 1020, 1027; and ArrayList .
1030; using serialization to perform
deep copying . 1032
default constructor . 196, 202;
synthesizing a default constructor . 279
default constructor, access the same as the
class . 681
default keyword, in a switch statement .
183
default package . 257
DefaultMutableTreeNode . 784
defaultReadObject( ) . 629
DefaultTreeModel . 784
defaultWriteObject( ) . 629
DeflaterOutputStream . 606
Delphi, from Borland . 800
Demarco, Tom . 1095
dequeue . 440
derived: derived class . 315; derived class,
initializing . 278; types . 39
design . 342; adding more methods to a
design . 268; analysis and design,
object-oriented . 71; and composition .
340; and inheritance . 339; and
mistakes . 268; five stages of object
design . 82; library design . 243; of
object hierarchies . 307; patterns . 86,
94
design patterns . 266; decorator . 585;
singleton . 266
destroy( ) . 877
destructor . 208, 209, 554; Java doesn’t
have one . 283
development, incremental . 291
diagram: inheritance . 47; use case . 77
diagram, class inheritance diagrams . 293
dialog box . 771
dialog, file . 776
dialog, tabbed . 755
dictionary . 477
digital signing . 692
directory: and packages . 254; creating
directories and paths . 578; lister . 574
display framework, for Swing . 702
dispose( ) . 772
division . 137
documentation: comments & embedded
documentation . 122
Domain Name System (DNS) . 905
dotted quad . 905
double, literal value marker (D) . 156
1104
do-while . 173
downcast . 293, 343, 666; type-safe
downcast in run-time type
identification . 665
Drawing lines in Swing . 768
drop-down list . 751
dynamic: behavior change with
composition . 341; binding . 311, 316
dynamic aggregate initialization syntax for
arrays . 412
E
early binding . 45, 315
East, BorderLayout . 713
editor, creating one using the Swing
JTextPane . 747
efficiency: and arrays . 408; and final . 302;
and threads . 828; when using the
synchronized keyword . 853
EJB . 990
elegance, in programming . 87
else keyword . 171
encapsulation . 261
Enterprise JavaBeans (EJB) . 990
enum, groups of constant values in C &
C++ . 359
Enumeration . 520
equals( ) . 142, 475; and hashed data
structures . 485; overriding for
HashMap . 484; vs. == . 645
equivalence: == . 141; object equivalence .
141
error: handling with exceptions . 531;
recovery . 568; reporting errors in
book . 23; standard error stream . 538
event: event-driven system . 394;
JavaBeans . 801; multicast . 796;
multicast event and JavaBeans . 854;
responding to a Swing event . 707;
Swing event model . 794; unicast . 796
event listener . 722; order of execution .
796
event model, Swing . 722
event-driven programming . 707
events and listeners . 723
EventSetDescriptors . 808
evolution, in program development . 85
exception: and base-class constructors .
281; and constructors . 561; and
inheritance . 558, 566; catching an
exception . 534; catching any exception .
543; changing the point of origin of the
exception . 547; class hierarchies . 567;
constructors . 562; creating your own .
537; design issues . 565; Error class .
549; Exception class . 549; exception
handler . 535; exception handling . 531;
exception matching . 566;
FileNotFoundException . 565;
fillInStackTrace( ) . 545; finally . 552;
guarded region . 535; handler . 532;
handling . 283; losing an exception,
pitfall . 557; NullPointerException . 550;
printStackTrace( ) . 545; restrictions .
558; re-throwing an exception . 545;
RuntimeException . 550; specification .
542; termination vs. resumption . 536;
Throwable . 543; throwing an
exception . 533; try . 554; try block . 535;
typical uses of exceptions . 568
exceptional condition . 532
exceptions: and JNI . 1074
executeQuery( ) . 930
Exponential notation . 156
extending a class during inheritance . 41
extends . 260, 277, 342; and interface . 359;
keyword . 275
extensible: program . 320
extension: pure inheritance vs. extension .
341
extension, sign . 147
extension, zero . 147
Externalizable . 620; alternative approach
to using . 626
Extreme Programming (XP) . 88, 1093
F
fail fast containers . 515
false . 143
FeatureDescriptor . 818
Field, for reflection . 678
fields, initializing fields in interfaces . 361
FIFO . 472
file: characteristics of files . 578;
File.list( ) . 574; incomplete output files,
errors and flushing . 599; JAR file . 245
File . 582, 592, 655; class . 574
file dialogs . 776
File Transfer Protocol (FTP) . 699
FileDescriptor . 582
1105
FileInputReader . 597
FileInputStream . 582
FilenameFilter . 574, 653
FileNotFoundException . 565
FileOutputStream . 583
FileReader . 563, 590
FileWriter . 590, 599
fillInStackTrace( ) . 545
FilterInputStream . 582
FilterOutputStream . 583
FilterReader . 591
FilterWriter . 591
final . 350; and efficiency . 302; and
private . 299; and static . 294;
argument . 298, 577; blank finals . 297;
classes . 301; data . 294; keyword . 294;
method . 316; methods . 299, 339; static
primitives . 296; with object references .
295
finalize( ) . 207, 566; and inheritance . 333;
and super . 335; calling directly . 210;
order of finalization of objects . 336
finally . 283, 286; and constructors . 562;
keyword . 552; pitfall . 557
finding .class files during loading . 247
flat-file database . 932
flavor, clipboard . 790
float, literal value marker(F) . 156
floating point: true and false . 144
FlowLayout . 714
flushing output files . 599
focus traversal . 691
folding, constant . 294
for keyword . 173
forName( ) . 664, 727
FORTRAN . 156
forward referencing . 222
Fowler, Martin . 72, 85, 1093
framework: application framework and
applets . 694; control framework and
inner classes . 394
friendly . 243, 368; and interface . 350;
and protected . 290; less accessible than
protected . 335
FTP: File Transfer Protocol (FTP) . 699
function: member function . 35;
overriding . 42
functor . 575
G
garbage collection . 207, 210, 333; and
cleanup . 283; and native method
execution . 1073; forcing finalization .
286; how the collector works . 215;
order of object reclamation . 286;
reachable objects . 495; setting
references to null to allow cleanup . 397
generator . 443
generator object, to fill arrays and
containers . 416
get( ), ArrayList . 450, 456
get( ), HashMap . 481
getBeanInfo( ) . 805
getBytes( ) . 598
getClass( ) . 544, 674
getConstructor( ) . 737
getConstructors( ) . 681
getContentPane( ) . 695
getContents( ) . 792
getEventSetDescriptors( ) . 808
getFloat( ) . 930
getInputStream( ) . 909
getInt( ) . 930
getInterfaces( ) . 676
getMethodDescriptors( ) . 808
getMethods( ) . 681
getModel( ) . 784
getName( ) . 677, 808
getOutputStream( ) . 909
getPriority( ) . 878
getPropertyDescriptors( ) . 808
getPropertyType( ) . 808
getReadMethod( ) . 808
getSelectedValues( ) . 753
getState( ) . 765
getString( ) . 930
getSuperclass( ) . 676
getTransferData( ) . 792
getTransferDataFlavors( ) . 792
getWriteMethod( ) . 808
Glass, Robert . 1094
glue, in BoxLayout . 717
goto: lack of goto in Java . 177
graphical user interface (GUI) . 394, 689
graphics . 776
Graphics . 768
greater than (>) . 141
greater than or equal to (>=) . 141
GridBagLayout . 716
GridLayout . 715, 894
1106
guarded region, in exception handling .
535
GUI: graphical user interface . 394, 689
GUI builders . 690
guidelines: object development . 83
guidelines, coding standards . 1077
GZIPInputStream . 606
GZIPOutputStream . 606
H
handler, exception . 535
hardware devices, interfacing with . 1065
has-a . 37
has-a relationship, composition . 289
hash code . 477, 488
hash function . 488
hashCode( ) . 473, 477; and hashed data
structures . 485; issues when writing .
492; overriding for HashMap . 484
hashing . 485; external chaining . 488;
perfect hashing function . 488
HashMap . 476, 500, 733; used with
ArrayList . 652
HashSet . 473, 506
Hashtable . 510, 521
hasNext( ), Iterator . 457
Hexadecimal . 156
hiding: implementation . 35
hiding, implementation . 261
high concept . 75
HTML . 948; name . 839; param . 839;
value . 839
HTML on Swing components . 779
I
I/O: and threads, blocking . 860;
available( ) . 598; blocking on I/O . 869;
blocking, and available( ) . 598;
BufferedInputStream . 586;
BufferedOutputStream . 588;
BufferedReader . 563, 591, 597;
BufferedWriter . 591, 599;
ByteArrayInputStream . 582;
ByteArrayOutputStream . 583;
characteristics of files . 578;
CharArrayReader . 590;
CharArrayWriter . 590;
CheckedInputStream . 606;
CheckedOutputStream . 606; close( ) .
597; compression library . 606; console
input . 597; controlling the process of
serialization . 619; DataInput . 593;
DataInputStream . 586, 591, 597, 599;
DataOutput . 593; DataOutputStream .
588, 592, 599; DeflaterOutputStream .
606; directory lister . 574; directory,
creating directories and paths . 578;
Externalizable . 620; File . 582, 592, 655;
File class . 574; File.list( ) . 574;
FileDescriptor . 582; FileInputReader .
597; FileInputStream . 582;
FilenameFilter . 574, 653;
FileOutputStream . 583; FileReader .
563, 590; FileWriter . 590, 599;
FilterInputStream . 582;
FilterOutputStream . 583; FilterReader .
591; FilterWriter . 591; from standard
input . 602; GZIPInputStream . 606;
GZIPOutputStream . 606;
InflaterInputStream . 606; input . 581;
InputStream . 581, 913;
InputStreamReader . 589, 590, 913;
internationalization . 590; library . 573;
lightweight persistence . 613;
LineNumberInputStream . 586;
LineNumberReader . 591; mark( ) . 593;
mkdirs( ) . 580; nextToken( ) . 654;
ObjectOutputStream . 614; output . 581;
OutputStream . 581, 583, 913;
OutputStreamWriter . 589, 590, 913;
pipe . 581; piped stream . 869; piped
streams . 602; PipedInputStream . 582;
PipedOutputStream . 582, 583;
PipedReader . 590; PipedWriter . 590;
PrintStream . 588; PrintWriter . 591,
599, 913; pushBack( ) . 654;
PushbackInputStream . 586;
PushBackReader . 591;
RandomAccessFile . 592, 593, 599;
read( ) . 581; readChar( ) . 600;
readDouble( ) . 600; Reader . 581, 589,
590, 913; readExternal( ) . 620;
readLine( ) . 565, 591, 599, 600, 603;
readObject( ) . 614; redirecting standard
I/O . 604; renameTo( ) . 580; reset( ) .
593; seek( ) . 593, 601;
SequenceInputStream . 582, 592;
Serializable . 620; setErr(PrintStream) .
604; setIn(InputStream) . 604;
1107
setOut(PrintStream) . 604;
StreamTokenizer . 591, 639, 653, 682;
StringBuffer . 582;
StringBufferInputStream . 582;
StringReader . 590, 597; StringWriter .
590; System.err . 602; System.in . 597,
602; System.out . 602; transient . 624;
typical I/O configurations . 594;
Unicode . 590; write( ) . 581;
writeBytes( ) . 600; writeChars( ) . 600;
writeDouble( ) . 600; writeExternal( ) .
620; writeObject( ) . 614; Writer . 581,
589, 590, 913; ZipEntry . 610;
ZipInputStream . 606;
ZipOutputStream . 606
Icon . 738
IDL . 982
idltojava . 984
if-else statement . 151, 171
IllegalMonitorStateException . 866
ImageIcon . 738
immutable objects . 1047
implementation . 34; and interface . 288,
350; and interface, separating . 36; and
interface, separation . 262; hiding . 35,
261, 368; separation of interface and
implementation . 722
implements keyword . 350
import keyword . 244
increment operator . 139
incremental development . 291
indexed property . 818
indexing operator [ ] . 231
indexOf( ): String . 576, 681
InflaterInputStream . 606
inheritance . 38, 260, 271, 275, 311; and
cloning . 1034; and final . 302; and
finalize( ) . 333; and synchronized . 858;
choosing composition vs. inheritance .
288; class inheritance diagrams . 293;
combining composition & inheritance .
281; designing with inheritance . 339;
diagram . 47; extending a class during .
41; extending interfaces with
inheritance . 358; from an abstract
class . 326; from inner classes . 384;
inheritance and method overloading vs.
overriding . 286; initialization with
inheritance . 304; multiple inheritance
in C++ and Java . 354; pure inheritance
vs. extension . 341; specialization . 289;
vs composition . 642; vs. composition .
294
initial capacity, of a HashMap or HashSet .
491
initialization: and class loading . 304;
array initialization . 231; base class . 278;
class member . 273; constructor
initialization during inheritance and
composition . 281; initializing class
members at point of definition . 221;
initializing with the constructor . 191;
instance initialization . 229, 375;
member initializers . 332; non-static
instance initialization . 229; of class
data members . 220; of method
variables . 220; order of initialization .
223, 338; static . 306; with inheritance .
304
inizialization: lazy . 273
inline method calls . 299
inner class . 365, 799; access rights . 376;
and super . 385; and overriding . 385;
and control frameworks . 394; and
Swing . 722; and upcasting . 368;
anonymous . 709; anonymous inner
class . 576, 875; anonymous inner class
and constructors . 375; anonymous, and
table-driven code . 502; callback . 391;
closure . 391; hidden reference to the
object of the enclosing class . 378;
identifiers and .class files . 387; in
methods & scopes . 370; inheriting from
inner classes . 384; nesting within any
arbitrary scope . 372; private . 833;
private inner classes . 397; referring to
the outer class object . 381; static inner
classes . 379
input: console input . 597
InputStream . 581, 913
InputStreamReader . 589, 590, 913
insertNodeInto( ) . 784
instance: instance initialization . 375; nonstatic
instance initialization . 229
instance of a class . 31
instanceof: dynamic instanceof . 671;
keyword . 666
Integer: parseInt( ) . 776
Integer wrapper class . 233
interface: and implementation,
separation . 262; and inheritance . 358;
base-class interface . 320; Cloneable
interface used as a flag . 1022; common
1108
interface . 325; defining the class . 88;
for an object . 32; graphical user
interface (GUI) . 394, 689;
implementation, separation of . 36;
initializing fields in interfaces . 361;
keyword . 349; nesting interfaces within
classes and other interfaces . 362;
private, as nested interfaces . 364;
Runnable . 836; separation of interface
and implementation . 722; upcasting to
an interface . 353; user . 78; vs.
abstract . 356; vs. implemenation . 288
Interface Definition Language (IDL) . 982
interfaces: name collisions when
combining interfaces . 356
interfacing with hardware devices . 1065
internationalization, in I/O library . 590
Internet: Internet Protocol . 905; Internet
Service Provider (ISP) . 699
interrupt( ) . 873
InterruptedException . 827
intranet . 693; and applets . 693
Introspector . 805
IP (Internet Protocol) . 905
is-a . 341; relationship, inheritance . 289;
relationship, inheritance & upcasting .
292; vs. is-like-a relationships . 42
isDaemon( ) . 840
isDataFlavorSupported( ) . 792
isInstance . 671
isInterface( ) . 677
is-like-a . 342
ISP (Internet Service Provider) . 699
iteration, in program development . 84
iterator . 456
Iterator . 456, 463, 500; hasNext( ) . 457;
next( ) . 457
iterator( ) . 463
J
Jacobsen, Ivar . 1093
JApplet . 713; menus . 759
JAR . 816; archive tag, for HTML and JAR
files . 793; file . 245; jar files and
classpath . 249; packaging applets to
optimize loading . 793
JAR utility . 611
Java . 99; and pointers . 1013; and set-top
boxes . 146; capitalization style sourcecode
checking tool . 645; compiling and
running a program . 121; containers
library . 440; public Java seminars . 11;
versions . 22
Java 1.1: I/O streams . 589
Java AWT . 689
Java Foundation Classes (JFC/Swing) .
689
Java operators . 133
Java programs, running from the
Windows Explorer . 705
Java Server Pages (JSP) . 960
Java Virtual Machine . 662
JavaBeans: see Beans . 800
javac . 121
javah . 1067
JButton . 738
JButton, Swing . 706
JCheckBox . 738, 748
JCheckboxMenuItem . 765
JCheckBoxMenuItem . 760
JComboBox . 751
JComponent . 740, 768
JDBC: createStatement( ) . 930; database
URL . 928; DatabaseMetaData . 938;
executeQuery( ) . 930; flat-file
database . 932; getFloat( ) . 930;
getInt( ) . 930; getString( ) . 930; Java
DataBase Connectivity . 927; join . 932;
relational database . 933; ResultSet .
930; SQL stored procedures . 935;
Statement . 930; Structured Query
Language (SQL) . 927
JDialog . 771; menus . 759
JDK: downloading and installing . 121
JFC: Java Foundation Classes
(JFC/Swing) . 689
JFileChooser . 776
JFrame . 704, 713; menus . 759
Jini . 1003
JIT: Just-In Time compilers . 98
JLabel . 695, 743
JList . 753
JMenu . 759, 765
JMenuBar . 759, 766
JMenuItem . 738, 759, 765, 766, 768
JNI functions . 1069
JNICALL . 1068
JNIEnv . 1069
JNIEXPORT . 1068
join . 932
JOptionPane . 756
JPanel . 713, 736, 768, 894
1109
JPopupMenu . 766
JProgressBar . 781
JRadioButton . 738, 750
JScrollPane . 712, 744, 755, 784
JSlider . 781
JSP . 960
JTabbedPane . 755
JTable . 784
JTextArea . 711, 790
JTextField . 708, 740
JTextPane . 747
JToggleButton . 736
JTree . 781
JVM (Java Virtual Machine) . 662
K
keyboard navigation, and Swing . 691
keyboard shortcuts . 765
keySet( ) . 511
keywords: class . 32, 38
Koenig, Andrew . 1079
L
label . 178
labeled break . 178
labeled continue . 178
late binding . 45, 311, 316
layout: controlling layout with layout
managers . 712
lazy inizialization . 273
left-shift operator (<<) . 147
length, array member . 232
length, for arrays . 409
less than (<) . 141
less than or equal to (<=) . 141
lexicographic vs. alphabetic sorting . 436
library: creator, vs. client programmer .
243; design . 243; use . 244
LIFO . 471
lightweight: Swing components . 691
lightweight persistence . 613
LineNumberInputStream . 586
LineNumberReader . 591
linked list . 440
LinkedList . 467, 472, 505
list: drop-down list . 751
List . 408, 439, 440, 467, 753; sorting and
searching . 511
list boxes . 753
listener adapters . 729
listener classes . 799
listener interfaces . 728
listeners and events . 723
Lister, Timothy . 1095
ListIterator . 467
literal: class literal . 664, 669; double . 156;
float . 156; long . 156; values . 155
load factor, of a HashMap or HashSet . 491
loading: .class files . 247; initialization &
class loading . 304; loding a class . 305
local loopback IP address . 907
localhost . 907; and RMI . 977
lock, for multithreading . 848
logarithms: natural logarithms . 156
logical: AND . 154; operator and shortcircuiting
. 144; operators . 143; OR .
154
long, literal value marker (L) . 156
Look & Feel: Pluggable . 787
lvalue . 134
M
main( ) . 277
maintenance, program . 85
management obstacles . 95
manifest file, for JAR files . 611, 816
map . 477
Map . 408, 439, 440, 476, 508
Map.Entry . 486
mark( ) . 593
Math.random( ) . 480; values produced
by . 186
mathematical operators . 137
max( ) . 512
member: member function . 35; object . 37
member initializers . 332
memory exhaustion, solution via
References . 495
mentoring: and training . 95, 96
menu: JPopupMenu . 766
menus: JDialog, JApplet, JFrame . 759
message box, in Swing . 756
message, sending . 33
meta-class . 662
method: adding more methods to a
design . 268; aliasing during a method
1110
call . 1014; aliasing during method calls .
136; behavior of polymorphic methods
inside constructors . 337; distinguishing
overloaded methods . 196; final . 316,
339; final methods . 299; initialization
of method variables . 220; inline
method calls . 299; inner classes in
methods & scopes . 370; lookup tool .
724; method call binding . 315;
overloading . 194; passing a reference
into a method . 1014; polymorphic
method call . 311; private . 339;
protected methods . 290; recursive . 459;
static . 206; synchronized method and
blocking . 860
Method . 808; for reflection . 678
MethodDescriptors . 808
methodology, analysis and design . 71
Meyers, Scott . 35
Microsoft . 820; Visual Basic . 800
min( ) . 512
mission statement . 75
mistakes, and design . 268
mkdirs( ) . 580
mnemonics (keyboard shortcuts) . 765
modulus . 137
monitor, for multithreading . 848
multicast . 814; event, and JavaBeans . 854;
multicast events . 796
multidimensional arrays . 236
Multimedia CD ROM for book . 20
multiparadigm programming . 31
multiple inheritance, in C++ and Java .
354
multiplication . 137
multiply-nested class . 383
MultiStringMap . 652
multitasking . 825
multithreading . 825, 917; and containers .
514; and JavaBeans . 854; blocking .
859; deadlock . 865; deciding what
methods to synchronize . 858;
drawbacks . 899; Runnable . 891;
servlets . 954; when to use it . 899
multi-tiered systems . 796
N
name . 697; clash . 244; collisions . 250;
creating unique package names . 247;
spaces . 244
name collisions when combining
interfaces . 356
name, HTML keyword . 839
Naming: bind( ) . 976; rebind( ) . 978;
unbind( ) . 978
narrowing conversion . 155, 170, 201
native method interface (NMI) in Java
1.0 . 1065
natural logarithms . 156
nesting interfaces . 362
network programming . 904; accept( ) .
909; client . 907; Common-Gateway
Interface (CGI) . 948; datagrams . 923;
dedicated connection . 917; displaying a
Web page from within an applet . 923;
DNS (Domain Name System) . 905;
dotted quad . 905; getInputStream( ) .
909; getOutputStream( ) . 909; HTML .
948; identifying machines . 905;
Internet Protocol (IP) . 905; Java
DataBase Connectivity (JDBC) . 927;
local loopback IP address . 907;
localhost . 907; multithreading . 917;
port . 908; reliable protocol . 923;
server . 907; serving multiple clients .
917; showDocument( ) . 924; Socket .
915; stream-based sockets . 923; testing
programs without a network . 907;
Transmission Control Protocol (TCP) .
923; unreliable protocol . 923; URL .
925; User Datagram Protocol (UDP) .
923
new operator . 207; and primitives, array .
233
newInstance( ) . 737; reflection . 676
next( ), Iterator . 457
nextToken( ) . 654
NMI: Java 1.0 native method interface .
1065
no-arg: constructors . 196
non-Java code, calling . 1065
North, BorderLayout . 713
NOT: logical (!) . 143
not equivalent (!=) . 141
notify( ) . 860
notifyAll( ) . 860
notifyListeners( ) . 858
null . 107, 411; garbage collection, allowing
cleanup . 397
NullPointerException . 550
numbers, binary . 156
1111
O
object . 31; aliasing . 136; arrays are firstclass
objects . 409; assigning objects by
copying references . 134; assignment
and reference copying . 134; business
object/logic . 796; Class object . 633,
662, 848; creation . 192; equals( )
method . 142; equivalence . 141;
equivalence vs reference equivalence .
142; final . 295; five stages of object
design . 82; guidelines for object
development . 83; immutable objects .
1047; interface to . 32; lock, for
multithreading . 848; member . 37;
object-oriented programming . 660;
order of finalization of objects . 336;
process of creation . 227; reference
equivalence vs. object equivalence .
1025; serialization . 613; web of objects .
614, 1020
Object . 408; clone( ) . 1021, 1025;
getClass( ) . 674; hashCode( ) . 477;
standard root class, default inheritance
from . 275; wait( ) and notify( )
methods . 866
object-oriented: analysis and design . 71;
basic concepts of object-oriented
programming (OOP) . 29
ObjectOutputStream . 614
obstacles, management . 95
Octal . 156
ODBC . 928
OMG . 981
ones complement operator . 146
OOP . 262; analysis and design . 71; basic
characteristics . 31; basic concepts of
object-oriented programming . 29;
protocol . 350; Simula programming
language . 32; substitutability . 31
operator . 133; + and += overloading for
String . 277; +, for String . 1054; ==
and != . 1025; binary . 146; bitwise . 146;
casting . 154; comma . 152; comma
operator . 175; common pitfalls . 153;
indexing operator [ ] . 231; logical . 143;
logical operators and short-circuiting .
144; ones-complement . 146; operator
overloading for String . 1054;
overloading . 153; precedence . 134;
precedence mnemonic . 158; relational .
141; shift . 147; ternary . 151; unary . 139,
146
optional methods, in the Java 2
containers . 516
OR . 154; (||) . 143
order: of constructor calls with
inheritance . 330; of finalization of
objects . 336; of initialization . 223, 304,
338
organization, code . 255
OutputStream . 581, 583, 913
OutputStreamWriter . 589, 590, 913
overflow: and primitive types . 169
overloading: and constructors . 194;
distinguishing overloaded methods . 196;
lack of name hiding during inheritance .
286; method overloading . 194; on
return values . 202; operator + and +=
overloading for String . 277; operator
overloading . 153; operator overloading
for String . 1054; overloading vs.
overriding . 286; vs. overriding . 324
overriding: and inner classes . 385;
function . 42; overloading vs.
overriding . 286; vs. overloading . 324
P
package . 244; access, and friendly . 255;
and applets . 699; and directory
structure . 254; creating unique package
names . 247; default package . 257;
names, capitalization . 116; visibility,
friendly . 368
paintComponent( ) . 768, 776
Painting on a JPanel in Swing . 768
pair programming . 90
paralysis, analysis . 72
param, HTML keyword . 839
parameter, applet . 697
parameterized type . 455
parseInt( ) . 776
pass: pass by value . 1018; passing a
reference into a method . 1014
Pattern: Command Pattern . 575
patterns, design . 86, 94
patterns, design patterns . 266
perfect hashing function . 488
performance: and final . 302
performance issues . 96
Perl programming language . 705
1112
persistence . 630; lightweight persistence .
613
PhantomReference . 495
pipe . 581
piped stream . 869
piped streams . 602
PipedInputStream . 582
PipedOutputStream . 582, 583
PipedReader . 590
PipedWriter . 590
planning, software development . 74
Plauger, P.J. . 1094
Pluggable Look & Feel . 787
pointer: Java exclusion of pointers . 391
pointers, and Java . 1013
polymorphism . 44, 311, 346, 660, 685;
and constructors . 330; behavior of
polymorphic methods inside
constructors . 337
port . 908
portability in C, C++ and Java . 158
position, absolute, when laying out Swing
components . 716
precedence: operator precedence
mnemonic . 158
prerequisites, for this book . 29
primitive: comparison . 142; containers of
primitives . 412; data types, and use
with operators . 159; dealing with the
immutability of primitive wrapper
classes . 1047; final . 294; final static
primitives . 296; initialization of class
data members . 220; wrappers . 481
primitive types . 105
printInfo( ) . 677
printing arrays . 417
println( ) . 458
printStackTrace( ) . 543, 545
PrintStream . 588
PrintWriter . 591, 599, 913
priority: default priority for a Thread
group . 882; thread . 877
private . 36, 243, 255, 258, 290, 848;
illusion of overriding private methods .
299; inner class . 833; inner classes .
397; interfaces, when nested . 364;
methods . 339
problem space . 30, 291
process, and threading . 825
program: maintenance . 85
programmer, client . 35
programming: basic concepts of objectoriented
programming (OOP) . 29;
coding standards . 1077; event-driven
programming . 707; Extreme
Programming (XP) . 88, 1093; in the
large . 92; multiparadigm . 31; objectoriented
. 660; pair . 90
progress bar . 780
promotion: of primitive types . 169; type
promotion . 157
Properties . 652
property . 801; bound properties . 818;
constrained properties . 818; custom
property editor . 818; custom property
sheet . 818; indexed property . 818
PropertyChangeEvent . 818
PropertyDescriptors . 808
ProptertyVetoException . 818
protected . 36, 243, 255, 260, 290; and
friendly . 290; is also friendly . 261;
more accessible than friendly . 335; use
in clone( ) . 1021
protocol . 350; unreliable protocol . 923
prototyping: rapid . 86
public . 36, 243, 255, 256; and interface .
350; class, and compilation units . 245
pure: substitution . 42
pure inheritance, vs. extension . 341
pure substitution . 342
pushBack( ) . 654
PushbackInputStream . 586
PushBackReader . 591
put( ), HashMap . 481
Python . 81, 99
Q
queue . 440, 472
R
RAD (Rapid Application Development) .
678
radio button . 750
random number generator, values
produced by . 186
random( ) . 480
RandomAccessFile . 592, 593, 599
rapid prototyping . 86
1113
reachable objects and garbage collection .
495
read( ) . 581
readChar( ) . 600
readDouble( ) . 600
Reader . 581, 589, 590, 869, 913
readExternal( ) . 620
reading from standard input . 602
readLine( ) . 565, 591, 599, 600, 603
readObject( ) . 614; with Serializable . 627
rebind( ) . 978
recursion, unintended via toString() . 459
redirecting standard I/O . 604
refactoring . 85
reference: assigning objects by copying
references . 134; equivalence vs object
equivalence . 142; final . 295; finding
exact type of a base reference . 662;
null . 107; reference equivalence vs.
object equivalence . 1025
Reference, from java.lang.ref . 495
referencing, forward referencing . 222
reflection . 677, 678, 724, 804; and Beans .
801; difference between RTTI and
reflection . 679
reflection example . 736
registry: remote object registry . 976
relational: database . 933; operators . 141
reliable protocol . 923
Remote Method Invocation (RMI) . 973
RemoteException . 980
removeActionListener( ) . 812, 857
removeXXXListener( ) . 723
renameTo( ) . 580
reporting errors in book . 23
request, in OOP . 33
requirements analysis . 75
reset( ) . 593
ResultSet . 930
resume( ) . 860, 864; and deadlocks . 873;
deprecation in Java 2 . 875
resumption, termination vs. resumption,
exception handling . 536
re-throwing an exception . 545
return: an array . 413; constructor return
value . 193; overloading on return
value . 202
reusability . 37
reuse . 83; code reuse . 271; existing class
libraries . 94; reusable code . 800
right-shift operator (>>) . 147
RMI: AlreadyBoundException . 978; and
CORBA . 989; bind( ) . 976; localhost .
977; rebind( ) . 978; Remote . 974;
remote interface . 974; Remote Method
Invocation . 973; remote object registry .
976; RemoteException . 974, 980; rmic .
979; rmic and classpath . 979;
rmiregistry . 976;
RMISecurityManager . 976; Serializable
arguments . 978; skeleton . 978; stub .
978; TCP/IP . 977; unbind( ) . 978;
UnicastRemoteObject . 974
rmic . 979
rmiregistry . 976
RMISecurityManager . 976
rollover . 740
RTTI: and cloning . 1025; cast . 661; Class .
737; Class object . 662;
ClassCastException . 666; Constructor .
678; difference between RTTI and
reflection . 679; downcast . 666; Field .
678; getConstructor( ) . 737; instanceof
keyword . 666; isInstance . 671; metaclass
. 662; Method . 678;
newInstance( ) . 737; reflection . 677;
run-time type identification (RTTI) .
344; type-safe downcast . 665; using the
Class object . 674
Rumbaugh, James . 1093
runFinalizersOnExit( ) . 335
Runnable . 891; interface . 836; Thread .
859
running a Java program . 121
run-time binding . 316; polymorphism .
311
run-time type identification: (RTTI) . 344;
misuse . 685; shape example . 659;
when to use it . 685
RuntimeException . 408, 550
rvalue . 134
S
safety, and applet restrictions . 692
scenario . 77
scheduling . 79
scope: inner class nesting within any
arbitrary scope . 372; inner classes in
methods & scopes . 370; use case . 84
scrolling in Swing . 712
searching: sorting and searching Lists . 511
1114
searching an array . 437
section, critical section and synchronized
block . 852
seek( ) . 593, 601
seminars: public Java seminars . 11;
training, provided by Bruce Eckel . 23
sending a message . 33
separating business logic from UI logic .
796
separation of interface and
implementation . 36, 262, 722
SequenceInputStream . 582, 592
Serializable . 613, 620, 625, 637, 814;
readObject( ) . 627; writeObject( ) . 627
serialization: and object storage . 630; and
transient . 624; controlling the process
of serialization . 619;
defaultReadObject( ) . 629;
defaultWriteObject( ) . 629; RMI
arguments . 978; to perform deep
copying . 1032; Versioning . 630
server . 907
servlet . 948; multithreading . 954;
running servlets with Tomcat . 960;
session tracking . 955
session: and JSP . 969
session tracking, with servlets . 955
Set . 408, 439, 440, 473, 506
setActionCommand( ) . 765
setBorder( ) . 743
setContents( ) . 792
setDaemon( ) . 840
setDefaultCloseOperation( ) . 704
setErr(PrintStream) . 604
setIcon( ) . 740
setIn(InputStream) . 604
setLayout( ) . 713
setMnemonic( ) . 765
setOut(PrintStream) . 604
setPriority( ) . 878
setToolTipText( ) . 740
shallow copy . 1019, 1027
shape: example . 39, 316; example, and
run-time type identification . 659
shift operators . 147
short-circuit, and logical operators . 144
shortcut, keyboard . 765
show( ) . 773
showDocument( ) . 924
shuffle( ) . 512
side effect . 133, 141, 202, 1016
sign extension . 147
signed two’s complement . 151
Simula programming language . 32
Simula-67 . 262
sine wave . 768
singleton: design pattern . 266
size( ), ArrayList . 451
Size, of a HashMap or HashSet . 491
sizeof( ): lack of in Java . 158
skeleton, RMI . 978
sleep( ) . 827, 846, 860, 862
slider . 780
Smalltalk . 31, 207
Socket . 915
sockets, stream-based . 923
SoftReference . 495
software: development methodology . 72
Software Development Conference . 10
solution space . 30
sorting . 431; and searching Lists . 511
source code copyright notice . 20
South, BorderLayout . 713
space: problem . 30; solution . 30
specialization . 289
specification: system specification . 75
specification, exception . 542
specifier: access specifiers . 36, 243, 255
SQL: stored procedures . 935; Structured
Query Language . 927
Stack . 471, 521
standard input: Reading from standard
input . 602
standards: coding standards . 22, 1077
startup costs . 95
stateChanged( ) . 771
statement: mission . 75
Statement . 930
static . 350; and final . 294; block . 228;
clause . 664; construction clause . 228;
data initialization . 225; final static
primitives . 296; initialization . 306;
inner classes . 379; keyword . 206;
method . 206; synchronized static . 848
STL: C++ . 440
stop( ): and deadlocks . 873; deprecation
in Java 2 . 873
stored procedures in SQL . 935
stream, I/O . 581
stream-based sockets . 923
StreamTokenizer . 591, 639, 653, 682
String: automatic type conversion . 454;
class methods . 1052; concatenation
with operator + . 153; immutability .
1115
1052; indexOf( ) . 576, 681;
lexicographic vs. alphabetic sorting .
436; methods . 1056; operator + . 454;
Operator + . 153; operator + and +=
overloading . 277; toString( ) . 272, 452
StringBuffer . 582; methods . 1058
StringBufferInputStream . 582
StringReader . 590, 597
StringSelection . 792
StringTokenizer . 642
StringWriter . 590
struts, in BoxLayout . 717
stub, RMI . 978
style of creating classes . 262
subobject . 278, 288
substitutability, in OOP . 31
substitution: principle . 42
subtraction . 137
super . 280; and finalize( ) . 335; and inner
classes . 385
super keyword . 278
super.clone( ) . 1021, 1025, 1041
superclass . 278
suspend( ) . 860, 864; and deadlocks . 873;
deprecation in Java 2 . 875
Swing . 689
Swing component examples . 734
Swing components, using HTML with .
779
Swing event model . 722, 794
switch keyword . 183
synchronized . 59, 848; and inheritance .
858; and wait( ) & notify( ) . 866;
containers . 514; deciding what methods
to synchronize . 858; efficiency . 853;
method, and blocking . 860; static . 848;
synchronized block . 852
system clipboard . 790
system specification . 75
System.arraycopy( ) . 429
System.err . 538, 602
System.gc( ) . 213
System.in . 597, 602
System.out . 602
System.out.println( ) . 458
System.runFinalization( ) . 213
T
tabbed dialog . 755
table . 784
table-driven code, and anonymous inner
classes . 502
TCP, Transmission Control Protocol . 923
TCP/IP, and RMI . 977
template: in C++ . 455
termination vs. resumption, exception
handling . 536
ternary operator . 151
testing: automated . 89; Extreme
Programming (XP) . 88; unit testing .
277
testing techniques . 381
this keyword . 203
Thread . 825, 827; and JavaBeans . 854;
and Runnable . 891; blocked . 859;
combined with main class . 834;
daemon threads . 840; dead . 859;
deadlock . 872; deciding what methods
to synchronize . 858; destroy( ) . 877;
drawbacks . 899; getPriority( ) . 878;
I/O and threads, blocking . 860;
interrupt( ) . 873; isDaemon( ) . 840;
new Thread . 859; notify( ) . 860;
notifyAll( ) . 860; order of execution of
threads . 831; priority . 877; properly
suspending & resuming . 874;
resume( ) . 860, 864; resume( ) ,
deprecation in Java 2 . 875; resume( ),
and deadlocks . 873; run( ) . 829;
Runnable . 859; Runnable interface .
836; setDaemon( ) . 840; setPriority( ) .
878; sharing limited resources . 842;
sleep( ) . 846, 860, 862; start( ) . 830;
states . 859; stop( ) , deprecation in Java
2 . 873; stop( ), and deadlocks . 873;
stopping . 873; suspend( ) . 860, 864;
suspend( ) , deprecation in Java 2 . 875;
suspend( ), and deadlocks . 873;
synchronized method and blocking .
860; thread group . 882; thread group,
default priority . 882; threads and
efficiency . 828; wait( ) . 860, 866; when
they can be suspended . 847; when to
use threads . 899; yield( ) . 860
throw keyword . 534
Throwable . 547; base class for Exception .
543
throwing an exception . 533
time-critical code sections . 1065
toArray( ) . 511
token . 639
Tokenizing . 639
1116
Tomcat, standard servlet container . 960
tool tips . 740
TooManyListenersException . 796, 814
toString( ) . 272, 452, 458, 500
training . 93; and mentoring . 95, 96
training seminars provided by Bruce
Eckel . 23
Transferable . 792
transient keyword . 624
translation unit . 245
Transmission Control Protocol (TCP) . 923
tree . 781
TreeMap . 476, 510, 642
TreeSet . 473, 506
true . 143
try . 286, 554; try block in exceptions . 535
two’s complement, signed . 151
type: base . 39; data type equivalence to
class . 33; derived . 39; finding exact
type of a base reference . 662;
parameterized type . 455; primitive . 105;
primitive data types and use with
operators . 159; type checking and
arrays . 408; type safety in Java . 154;
type-safe downcast in run-time type
identification . 665; weak typing . 45
TYPE field, for primitive class literals . 665
type safe sets of constants . 361
type-conscious ArrayList . 454
U
UDP, User Datagram Protocol . 923
UML . 81; indicating composition . 37;
Unified Modeling Language . 35, 1093
unary: minus (-) . 139; operator . 146;
operators . 139; plus (+) . 139
unbind( ) . 978
unicast . 814; unicast events . 796
UnicastRemoteObject . 974
Unicode . 590
Unified Modeling Language (UML) . 35,
1093
unit testing . 277
unmodifiable, making a Collection or Map
unmodifiable . 513
unsupported methods, in the Java 2
containers . 516
UnsupportedOperationException . 516
upcasting . 47, 291, 312, 660; and
interface . 353; inner classes and
upcasting . 368
updates of the book . 22
URL . 925
use case . 76; iteration . 84; scope . 84
User Datagram Protocol (UDP) . 923
user interface . 78; and threads, for
responsiveness . 831; responsive, with
threading . 826
V
value: preventing change at run-time . 294
value, HTML keyword . 839
variable: defining a variable . 174;
initialization of method variables . 220;
variable argument lists (unknown
quantity and type of arguments) . 235
vector: of change . 86
Vector . 505, 519, 521
vector of change . 397
versioning, serialization . 630
versions of Java . 22
visibility, package visibility, (friendly) .
368
visual: programming . 800
Visual Basic, Microsoft . 800
visual programming environments . 690
W
wait( ) . 860, 866
Waldrop, M. Mitchell . 1095
weak: weakly typed language . 45
WeakHashMap . 498
WeakReference . 495
Web: displaying a Web page from within
an applet . 923; placing an applet inside
a Web page . 695; safety, and applet
restrictions . 692
web of objects . 614, 1020
West, BorderLayout . 713
while . 172
widening conversion . 155
wild-card . 73
WindowAdapter . 704
windowClosing( ) . 704, 771
windowed applications . 700
1117
Windows Explorer, running Java
programs from . 705
wrapper, dealing with the immutability of
primitive wrapper classes . 1047
write( ) . 581
writeBytes( ) . 600
writeChars( ) . 600
writeDouble( ) . 600
writeExternal( ) . 620
writeObject( ) . 614; with Serializable . 627
Writer . 581, 589, 590, 869, 913
X
XOR . 146
XP, Extreme Programming . 88
Y
yield( ) . 860
Z
zero extension . 147
ZipEntry . 610
ZipInputStream . 606
ZipOutputStream . 606
1118
Check www.BruceEckel.com
for in-depth details
and the date and location
of the next
Hands-On Java Seminar
• Based on this book
• Taught by Bruce Eckel
• Personal attention from Bruce Eckel
and his seminar assistants
• Includes in-class programming exercises
• Intermediate/Advanced seminars also offered
• Hundreds have already enjoyed this seminar-
1119
Bruce Eckel’s Hands-On Java Seminar
Multimedia CD
It’s like coming to the seminar!
Available at www.BruceEckel.com
  The Hands-On Java Seminar captured on a Multimedia CD!
  Overhead slides and synchronized audio voice narration for all
the lectures. Just play it to see and hear the lectures!
  Created and narrated by Bruce Eckel.
  Based on the material in this book.
  Demo lecture available at www.BruceEckel.com
1120
End-User License Agreement for Microsoft Software
IMPORTANT-READ CAREFULLY: This Microsoft End-User License Agreement
("EULA") is a legal agreement between you (either an individual or a single
entity) and Microsoft Corporation for the Microsoft software product included in
this package, which includes computer software and may include associated
media, printed materials, and "online" or electronic documentation
("SOFTWARE PRODUCT"). The SOFTWARE PRODUCT also includes any updates
and supplements to the original SOFTWARE PRODUCT provided to you by
Microsoft. By installing, copying, downloading, accessing or otherwise using
the SOFTWARE PRODUCT, you agree to be bound by the terms of this EULA. If
you do not agree to the terms of this EULA, do not install, copy, or otherwise
use the SOFTWARE PRODUCT.
SOFTWARE PRODUCT LICENSE
The SOFTWARE PRODUCT is protected by copyright laws and international
copyright treaties, as well as other intellectual property laws and treaties. The
SOFTWARE PRODUCT is licensed, not sold.
1. GRANT OF LICENSE. This EULA grants you the following rights:
1.1 License Grant. Microsoft grants to you as an individual, a personal
nonexclusive license to make and use copies of the SOFTWARE PRODUCT for
the sole purposes of evaluating and learning how to use the SOFTWARE
PRODUCT, as may be instructed in accompanying publications or
documentation. You may install the software on an unlimited number of
computers provided that you are the only individual using the SOFTWARE
PRODUCT.
1.2 Academic Use. You must be a "Qualified Educational User" to use the
SOFTWARE PRODUCT in the manner described in this section. To determine
whether you are a Qualified Educational User, please contact the Microsoft
Sales Information Center/One Microsoft Way/Redmond, WA 98052-6399 or the
Microsoft subsidiary serving your country. If you are a Qualified Educational
User, you may either:
(i) exercise the rights granted in Section 1.1, OR
(ii) if you intend to use the SOFTWARE PRODUCT solely for instructional
purposes in connection with a class or other educational program, this EULA
grants you the following alternative license models:
(A) Per Computer Model. For every valid license you have acquired for the
SOFTWARE PRODUCT, you may install a single copy of the SOFTWARE
PRODUCT on a single computer for access and use by an unlimited number of
1121
student end users at your educational institution, provided that all such end
users comply with all other terms of this EULA, OR
(B) Per License Model. If you have multiple licenses for the SOFTWARE
PRODUCT, then at any time you may have as many copies of the SOFTWARE
PRODUCT in use as you have licenses, provided that such use is limited to
student or faculty end users at your educational institution and provided that
all such end users comply with all other terms of this EULA. For purposes of
this subsection, the SOFTWARE PRODUCT is "in use" on a computer when it is
loaded into the temporary memory (i.e., RAM) or installed into the permanent
memory (e.g., hard disk, CD ROM, or other storage device) of that computer,
except that a copy installed on a network server for the sole purpose of
distribution to other computers is not "in use". If the anticipated number of
users of the SOFTWARE PRODUCT will exceed the number of applicable
licenses, then you must have a reasonable mechanism or process in place to
ensure that the number of persons using the SOFTWARE PRODUCT
concurrently does not exceed the number of licenses.
2. DESCRIPTION OF OTHER RIGHTS AND LIMITATIONS.
• Limitations on Reverse Engineering, Decompilation, and Disassembly. You
may not reverse engineer, decompile, or disassemble the SOFTWARE
PRODUCT, except and only to the extent that such activity is expressly
permitted by applicable law notwithstanding this limitation.
• Separation of Components. The SOFTWARE PRODUCT is licensed as a single
product. Its component parts may not be separated for use on more than one
computer.
• Rental. You may not rent, lease or lend the SOFTWARE PRODUCT.
• Trademarks. This EULA does not grant you any rights in connection with any
trademarks or service marks of Microsoft.
• Software Transfer. The initial user of the SOFTWARE PRODUCT may make a
one-time permanent transfer of this EULA and SOFTWARE PRODUCT only
directly to an end user. This transfer must include all of the SOFTWARE
PRODUCT (including all component parts, the media and printed materials, any
upgrades, this EULA, and, if applicable, the Certificate of Authenticity). Such
transfer may not be by way of consignment or any other indirect transfer. The
transferee of such one-time transfer must agree to comply with the terms of
this EULA, including the obligation not to further transfer this EULA and
SOFTWARE PRODUCT.
• No Support. Microsoft shall have no obligation to provide any product
support for the SOFTWARE PRODUCT.
• Termination. Without prejudice to any other rights, Microsoft may terminate
this EULA if you fail to comply with the terms and conditions of this EULA. In
1122
such event, you must destroy all copies of the SOFTWARE PRODUCT and all of
its component parts.
3. COPYRIGHT. All title and intellectual property rights in and to the
SOFTWARE PRODUCT (including but not limited to any images, photographs,
animations, video, audio, music, text, and "applets" incorporated into the
SOFTWARE PRODUCT), the accompanying printed materials, and any copies of
the SOFTWARE PRODUCT are owned by Microsoft or its suppliers. All title and
intellectual property rights in and to the content which may be accessed
through use of the SOFTWARE PRODUCT is the property of the respective
content owner and may be protected by applicable copyright or other
intellectual property laws and treaties. This EULA grants you no rights to use
such content. All rights not expressly granted are reserved by Microsoft.
4. BACKUP COPY. After installation of one copy of the SOFTWARE PRODUCT
pursuant to this EULA, you may keep the original media on which the
SOFTWARE PRODUCT was provided by Microsoft solely for backup or archival
purposes. If the original media is required to use the SOFTWARE PRODUCT on
the COMPUTER, you may make one copy of the SOFTWARE PRODUCT solely
for backup or archival purposes. Except as expressly provided in this EULA,
you may not otherwise make copies of the SOFTWARE PRODUCT or the printed
materials accompanying the SOFTWARE PRODUCT.
5. U.S. GOVERNMENT RESTRICTED RIGHTS. The SOFTWARE PRODUCT and
documentation are provided with RESTRICTED RIGHTS. Use, duplication, or
disclosure by the Government is subject to restrictions as set forth in
subparagraph (c)(1)(ii) of the Rights in Technical Data and Computer Software
clause at DFARS 252.227-7013 or subparagraphs (c)(1) and (2) of the
Commercial Computer Software-Restricted Rights at 48 CFR 52.227-19, as
applicable. Manufacturer is Microsoft Corporation/One Microsoft Way/Redmond,
WA 98052-6399.
6. EXPORT RESTRICTIONS. You agree that you will not export or re-export the
SOFTWARE PRODUCT, any part thereof, or any process or service that is the
direct product of the SOFTWARE PRODUCT (the foregoing collectively referred
to as the "Restricted Components"), to any country, person, entity or end user
subject to U.S. export restrictions. You specifically agree not to export or reexport
any of the Restricted Components (i) to any country to which the U.S.
has embargoed or restricted the export of goods or services, which currently
include, but are not necessarily limited to Cuba, Iran, Iraq, Libya, North Korea,
Sudan and Syria, or to any national of any such country, wherever located,
who intends to transmit or transport the Restricted Components back to such
country; (ii) to any end-user who you know or have reason to know will utilize
the Restricted Components in the design, development or production of
nuclear, chemical or biological weapons; or (iii) to any end-user who has been
1123
prohibited from participating in U.S. export transactions by any federal agency
of the U.S. government. You warrant and represent that neither the BXA nor
any other U.S. federal agency has suspended, revoked, or denied your export
privileges.
7. NOTE ON JAVA SUPPORT. THE SOFTWARE PRODUCT MAY CONTAIN
SUPPORT FOR PROGRAMS WRITTEN IN JAVA. JAVA TECHNOLOGY IS NOT
FAULT TOLERANT AND IS NOT DESIGNED, MANUFACTURED, OR INTENDED
FOR USE OR RESALE AS ON-LINE CONTROL EQUIPMENT IN HAZARDOUS
ENVIRONMENTS REQUIRING FAIL-SAFE PERFORMANCE, SUCH AS IN THE
OPERATION OF NUCLEAR FACILITIES, AIRCRAFT NAVIGATION OR
COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE SUPPORT
MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF JAVA
TECHNOLOGY COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR
SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE.
MISCELLANEOUS
If you acquired this product in the United States, this EULA is governed by the
laws of the State of Washington.
If you acquired this product in Canada, this EULA is governed by the laws of
the Province of Ontario, Canada. Each of the parties hereto irrevocably attorns
to the jurisdiction of the courts of the Province of Ontario and further agrees to
commence any litigation which may arise hereunder in the courts located in
the Judicial District of York, Province of Ontario.
If this product was acquired outside the United States, then local law may
apply.
Should you have any questions concerning this EULA, or if you desire to
contact Microsoft for any reason, please contact
Microsoft, or write: Microsoft Sales Information Center/One Microsoft
Way/Redmond, WA 98052-6399.
LIMITED WARRANTY
LIMITED WARRANTY. Microsoft warrants that (a) the SOFTWARE PRODUCT will
perform substantially in accordance with the accompanying written materials
for a period of ninety (90) days from the date of receipt, and (b) any Support
Services provided by Microsoft shall be substantially as described in applicable
written materials provided to you by Microsoft, and Microsoft support
engineers will make commercially reasonable efforts to solve any problem. To
the extent allowed by applicable law, implied warranties on the SOFTWARE
PRODUCT, if any, are limited to ninety (90) days. Some states/jurisdictions do
1124
not allow limitations on duration of an implied warranty, so the above
limitation may not apply to you.
CUSTOMER REMEDIES. Microsoft's and its suppliers' entire liability and your
exclusive remedy shall be, at Microsoft's option, either (a) return of the price
paid, if any, or (b) repair or replacement of the SOFTWARE PRODUCT that
does not meet Microsoft's Limited Warranty and that is returned to Microsoft
with a copy of your receipt. This Limited Warranty is void if failure of the
SOFTWARE PRODUCT has resulted from accident, abuse, or misapplication.
Any replacement SOFTWARE PRODUCT will be warranted for the remainder of
the original warranty period or thirty (30) days, whichever is longer. Outside
the United States, neither these remedies nor any product support services
offered by Microsoft are available without proof of purchase from an authorized
international source.
NO OTHER WARRANTIES. TO THE MAXIMUM EXTENT PERMITTED BY
APPLICABLE LAW, MICROSOFT AND ITS SUPPLIERS DISCLAIM ALL OTHER
WARRANTIES AND CONDITIONS, EITHER EXPRESS OR IMPLIED, INCLUDING,
BUT NOT LIMITED TO, IMPLIED WARRANTIES OR CONDITIONS OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NONINFRINGEMENT,
WITH REGARD TO THE SOFTWARE PRODUCT, AND THE
PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES. THIS LIMITED
WARRANTY GIVES YOU SPECIFIC LEGAL RIGHTS. YOU MAY HAVE OTHERS,
WHICH VARY FROM STATE/JURISDICTION TO STATE/JURISDICTION.
LIMITATION OF LIABILITY. TO THE MAXIMUM EXTENT PERMITTED BY
APPLICABLE LAW, IN NO EVENT SHALL MICROSOFT OR ITS SUPPLIERS BE
LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL
DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS
INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE
OF OR INABILITY TO USE THE SOFTWARE PRODUCT OR THE FAILURE TO
PROVIDE SUPPORT SERVICES, EVEN IF MICROSOFT HAS BEEN ADVISED OF
THE POSSIBILITY OF SUCH DAMAGES. IN ANY CASE, MICROSOFT'S ENTIRE
LIABILITY UNDER ANY PROVISION OF THIS EULA SHALL BE LIMITED TO THE
GREATER OF THE AMOUNT ACTUALLY PAID BY YOU FOR THE SOFTWARE
PRODUCT OR U.S.$5.00; PROVIDED, HOWEVER, IF YOU HAVE ENTERED INTO
A MICROSOFT SUPPORT SERVICES AGREEMENT, MICROSOFT'S ENTIRE
LIABILITY REGARDING SUPPORT SERVICES SHALL BE GOVERNED BY THE
TERMS OF THAT AGREEMENT. BECAUSE SOME STATES/JURISDICTIONS DO
NOT ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY, THE ABOVE
LIMITATION MAY NOT APPLY TO YOU.
0495 Part No. 64358
LICENSE AGREEMENT FOR MindView, Inc.'s
Thinking in C: Foundations for Java & C++ CD ROM
by Chuck Allison
This CD is provided together with the book "Thinking in Java, 2nd edition."
READ THIS AGREEMENT BEFORE USING THIS "Thinking in C: Foundations for
C++ & Java" (Hereafter called "CD"). BY USING THE CD YOU AGREE TO BE
BOUND BY THE TERMS AND CONDITIONS OF THIS AGREEMENT. IF YOU DO
NOT AGREE TO THE TERMS AND CONDITIONS OF THIS AGREEMENT,
IMMEDIATELY RETURN THE UNUSED CD FOR A FULL REFUND OF MONIES PAID,
IF ANY.
c2000 MindView, Inc. All rights reserved. Printed in the U.S.
SOFTWARE REQUIREMENTS
The purpose of this CD is to provide the Content, not the associated software
necessary to view the Content. The Content of this CD is in HTML for viewing
with Microsoft Internet Explorer 4 or newer, and uses Microsoft Sound Codecs
available in Microsoft's Windows Media Player for Windows. It is your
responsibility to correctly install the appropriate Microsoft software for your
system.
The text, images, and other media included on this CD ("Content") and their
compilation are licensed to you subject to the terms and conditions of this
Agreement by MindView, Inc., having a place of business at 5343 Valle Vista,
La Mesa, CA 91941. Your rights to use other programs and materials included
on the CD are also governed by separate agreements distributed with those
programs and materials on the CD (the "Other Agreements"). In the event of
any inconsistency between this Agreement and the Other Agreements, this
Agreement shall govern. By using this CD, you agree to be bound by the terms
and conditions of this Agreement. MindView, Inc. owns title to the Content and
to all intellectual property rights therein, except insofar as it contains materials
that are proprietary to third-party suppliers. All rights in the Content except
those expressly granted to you in this Agreement are reserved to MindView,
Inc. and such suppliers as their respective interests may appear.
1. LIMITED LICENSE
MindView, Inc. grants you a limited, nonexclusive, nontransferable license to
use the Content on a single dedicated computer (excluding network servers).
This Agreement and your rights hereunder shall automatically terminate if you
fail to comply with any provisions of this Agreement or any of the Other
Agreements. Upon such termination, you agree to destroy the CD and all
copies of the CD, whether lawful or not, that are in your possession or under
your control.
2. ADDITIONAL RESTRICTIONS
a. You shall not (and shall not permit other persons or entities to) directly or
indirectly, by electronic or other means, reproduce (except for archival
purposes as permitted by law), publish, distribute, rent, lease, sell, sublicense,
assign, or otherwise transfer the Content or any part thereof.
b. You shall not (and shall not permit other persons or entities to) use the
Content or any part thereof for any commercial purpose or merge, modify,
create derivative works of, or translate the Content.
c. You shall not (and shall not permit other persons or entities to) obscure
MindView's or its suppliers copyright, trademark, or other proprietary notices
or legends from any portion of the Content or any related materials.
3. PERMISSIONS
a. Except as noted in the Contents of the CD, you must treat this software just
like a book. However, you may copy it onto a computer to be used and you
may make archival copies of the software for the sole purpose of backing up
the software and protecting your investment from loss. By saying, "just like a
book," MindView, Inc. means, for example, that this software may be used by
any number of people and may be freely moved from one computer location to
another, so long as there is no possibility of its being used at one location or
on one computer while it is being used at another. Just as a book cannot be
read by two different people in two different places at the same time, neither
can the software be used by two different people in two different places at the
same time.
b. You may show or demonstrate the un-modified Content in a live
presentation, live seminar, or live performance as long as you attribute all
material of the Content to MindView, Inc.
c. Other permissions and grants of rights for use of the CD must be obtained
directly from MindView, Inc. at http://www.MindView.net. (Bulk copies of the
CD may also be purchased at this site.)
DISCLAIMER OF WARRANTY
The Content and CD are provided "AS IS" without warranty of any kind, either
express or implied, including, without limitation, any warranty of
1127
merchantability and fitness for a particular purpose. The entire risk as to the
results and performance of the CD and Content is assumed by you. MindView,
Inc. and its suppliers assume no responsibility for defects in the CD, the
accuracy of the Content, or omissions in the CD or the Content. MindView, Inc.
and its suppliers do not warrant, guarantee, or make any representations
regarding the use, or the results of the use, of the product in terms of
correctness, accuracy, reliability, currentness, or otherwise, or that the Content
will meet your needs, or that operation of the CD will be uninterrupted or
error-free, or that any defects in the CD or Content will be corrected. MindView,
Inc. and its suppliers shall not be liable for any loss, damages, or costs arising
from the use of the CD or the interpretation of the Content. Some states do
not allow exclusion or limitation of implied warranties or limitation of liability
for incidental or consequential damages, so all of the above limitations or
exclusions may not apply to you.
In no event shall MindView, Inc. or its suppliers' total liability to you for all
damages, losses, and causes of action (whether in contract, tort, or otherwise)
exceed the amount paid by you for the CD.
MindView, Inc., and Prentice-Hall, Inc. specifically disclaim the implied
warrantees of merchantability and fitness for a particular purpose. No oral or
written information or advice given by MindView, Inc., Prentice-Hall, Inc., their
dealers, distributors, agents or employees shall create a warrantee. You may
have other rights, which vary from state to state.
Neither MindView, Inc., Bruce Eckel, Chuck Allison, Prentice-Hall, nor anyone
else who has been involved in the creation, production or delivery of the
product shall be liable for any direct, indirect, consequential, or incidental
damages (including damages for loss of business profits, business interruption,
loss of business information, and the like) arising out of the use of or inability
to use the product even if MindView, Inc., has been advised of the possibility
of such damages. Because some states do not allow the exclusion or limitation
of liability for consequential or incidental damages, the above limitation may
not apply to you.
This CD is provided as a supplement to the book "Thinking in Java 2nd
edition." The sole responsibility of Prentice-Hall will be to provide a
replacement CD in the event that the one that came with the book is defective.
This replacement warrantee shall be in effect for a period of sixty days from
the purchase date. MindView, Inc. does not bear any additional responsibility
for the CD.
NO TECHNICAL SUPPORT IS PROVIDED WITH THIS CD ROM
The following are trademarks of their respective companies in the U.S. and
may be protected as trademarks in other countries: Sun and the Sun Logo,
Sun Microsystems, Java, all Java-based names and logos and the Java Coffee
Cup are trademarks of Sun Microsystems; Internet Explorer, the Windows
Media Player, DOS, Windows 95, and Windows NT are trademarks of Microsoft.
1129
Thinking in C: Foundations for Java & C++
Multimedia Seminar-on-CD ROM
c2000 MindView, Inc. All rights reserved.
WARNING: BEFORE OPENING THE DISC PACKAGE, CAREFULLY
READ THE TERMS AND CONDITIONS OF THE LICENSE
AGREEMENT & WARANTEE LIMITATION ON THE PREVIOUS
PAGES.
The CD ROM packaged with this book is a multimedia seminar consisting
of synchronized slides and audio lectures. The goal of this seminar is to
introduce you to the aspects of C that are necessary for you to move on to
C++ or Java, leaving out the unpleasant parts that C programmers must
deal with on a day-to-day basis but that the C++ and Java languages steer
you away from. The CD also contains this book in HTML form along with
the source code for the book.
This CD ROM will work with Windows (with a sound system). However,
you must:
1. Install the most recent version of Microsoft’s Internet Explorer.
Because of the features provided on the CD, it will NOT work
with Netscape Navigator. The Internet Explorer software
for Windows 9X/NT is included on the CD.
2. Install Microsoft’s Windows Media Player. The Media Player
software for Windows 9X/NT is included on the CD.
You can also go to
http://www.microsoft.com/windows/mediaplayer and
follow the instructions or links there to download and install the
Media Player for your particular platform.
3. At this point you should be able to play the lectures on the CD.
Using the Internet Explorer Web browser, open the file
Install.html that you’ll find on the CD. This will introduce you
to the CD and provide further instructions about the use of the
CD.
